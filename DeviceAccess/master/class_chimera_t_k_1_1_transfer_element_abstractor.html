<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ChimeraTK-DeviceAccess: ChimeraTK::TransferElementAbstractor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ChimeraTK_Logo_whitebg.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ChimeraTK-DeviceAccess
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_chimera_t_k_1_1_transfer_element_abstractor.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_chimera_t_k_1_1_transfer_element_abstractor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ChimeraTK::TransferElementAbstractor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for register accessors abstractors independent of the UserType.  
 <a href="class_chimera_t_k_1_1_transfer_element_abstractor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for ChimeraTK::TransferElementAbstractor:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="class_chimera_t_k_1_1_transfer_element_abstractor__inherit__graph.svg" width="100%" height="535"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5fc3bd8768619d4f4625842b82ecdf2f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a5fc3bd8768619d4f4625842b82ecdf2f">TransferElementAbstractor</a> (boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt; impl)</td></tr>
<tr class="memdesc:a5fc3bd8768619d4f4625842b82ecdf2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> implementation.  <a href="#a5fc3bd8768619d4f4625842b82ecdf2f">More...</a><br /></td></tr>
<tr class="separator:a5fc3bd8768619d4f4625842b82ecdf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28eaff61621c50693b307e232072ab35"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a28eaff61621c50693b307e232072ab35">TransferElementAbstractor</a> ()</td></tr>
<tr class="memdesc:a28eaff61621c50693b307e232072ab35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an uninitialised abstractor - just for late initialisation.  <a href="#a28eaff61621c50693b307e232072ab35">More...</a><br /></td></tr>
<tr class="separator:a28eaff61621c50693b307e232072ab35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ce6abbffcd87c4168594749068dd9d"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#aa2ce6abbffcd87c4168594749068dd9d">getName</a> () const</td></tr>
<tr class="memdesc:aa2ce6abbffcd87c4168594749068dd9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name that identifies the process variable.  <a href="#aa2ce6abbffcd87c4168594749068dd9d">More...</a><br /></td></tr>
<tr class="separator:aa2ce6abbffcd87c4168594749068dd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec6a18f44e33212f7b306d16e7bfb93"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#aaec6a18f44e33212f7b306d16e7bfb93">getUnit</a> () const</td></tr>
<tr class="memdesc:aaec6a18f44e33212f7b306d16e7bfb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the engineering unit.  <a href="#aaec6a18f44e33212f7b306d16e7bfb93">More...</a><br /></td></tr>
<tr class="separator:aaec6a18f44e33212f7b306d16e7bfb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13db8be528e984ee93035b5e584b7af"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#ad13db8be528e984ee93035b5e584b7af">getDescription</a> () const</td></tr>
<tr class="memdesc:ad13db8be528e984ee93035b5e584b7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the description of this variable/register.  <a href="#ad13db8be528e984ee93035b5e584b7af">More...</a><br /></td></tr>
<tr class="separator:ad13db8be528e984ee93035b5e584b7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceda7d828e20665cf3d25195565e4ebe"><td class="memItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#aceda7d828e20665cf3d25195565e4ebe">getValueType</a> () const</td></tr>
<tr class="memdesc:aceda7d828e20665cf3d25195565e4ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>std::type_info</code> for the value type of this transfer element.  <a href="#aceda7d828e20665cf3d25195565e4ebe">More...</a><br /></td></tr>
<tr class="separator:aceda7d828e20665cf3d25195565e4ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc639d986bbab7f30b86c6f8f8596e57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_access_mode_flags.html">AccessModeFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#acc639d986bbab7f30b86c6f8f8596e57">getAccessModeFlags</a> () const</td></tr>
<tr class="memdesc:acc639d986bbab7f30b86c6f8f8596e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="class_chimera_t_k_1_1_access_mode_flags.html" title="Set of AccessMode flags with additional functionality for an easier handling. ">AccessModeFlags</a> for this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#acc639d986bbab7f30b86c6f8f8596e57">More...</a><br /></td></tr>
<tr class="separator:acc639d986bbab7f30b86c6f8f8596e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66980fe7b7c0dc937361e71b1750767f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a66980fe7b7c0dc937361e71b1750767f">read</a> ()</td></tr>
<tr class="memdesc:a66980fe7b7c0dc937361e71b1750767f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from the device.  <a href="#a66980fe7b7c0dc937361e71b1750767f">More...</a><br /></td></tr>
<tr class="separator:a66980fe7b7c0dc937361e71b1750767f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96628a4ab593aff6f21d06cac6661b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#aa96628a4ab593aff6f21d06cac6661b8">readNonBlocking</a> ()</td></tr>
<tr class="memdesc:aa96628a4ab593aff6f21d06cac6661b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next value, if available in the input buffer.  <a href="#aa96628a4ab593aff6f21d06cac6661b8">More...</a><br /></td></tr>
<tr class="separator:aa96628a4ab593aff6f21d06cac6661b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11934cb06f61290f398e22428b26a005"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a11934cb06f61290f398e22428b26a005">readLatest</a> ()</td></tr>
<tr class="memdesc:a11934cb06f61290f398e22428b26a005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the latest value, discarding any other update since the last read if present.  <a href="#a11934cb06f61290f398e22428b26a005">More...</a><br /></td></tr>
<tr class="separator:a11934cb06f61290f398e22428b26a005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3990e6181ae284f48b74b6429b8b88c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a3990e6181ae284f48b74b6429b8b88c4">readAsync</a> ()</td></tr>
<tr class="memdesc:a3990e6181ae284f48b74b6429b8b88c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the device in the background and return a future which will be fulfilled when the data is ready.  <a href="#a3990e6181ae284f48b74b6429b8b88c4">More...</a><br /></td></tr>
<tr class="separator:a3990e6181ae284f48b74b6429b8b88c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05416264bd9c68ac18d9ba5b476cc801"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a05416264bd9c68ac18d9ba5b476cc801">getVersionNumber</a> () const</td></tr>
<tr class="memdesc:a05416264bd9c68ac18d9ba5b476cc801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the version number that is associated with the last transfer (i.e.  <a href="#a05416264bd9c68ac18d9ba5b476cc801">More...</a><br /></td></tr>
<tr class="separator:a05416264bd9c68ac18d9ba5b476cc801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281b905219e719a1a0cdbd9d8d42d1dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a281b905219e719a1a0cdbd9d8d42d1dd">write</a> (<a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> versionNumber={})</td></tr>
<tr class="memdesc:a281b905219e719a1a0cdbd9d8d42d1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the data to device.  <a href="#a281b905219e719a1a0cdbd9d8d42d1dd">More...</a><br /></td></tr>
<tr class="separator:a281b905219e719a1a0cdbd9d8d42d1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53668fb61c4310fa8f1a11d8e414cbc8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a53668fb61c4310fa8f1a11d8e414cbc8">writeDestructively</a> (<a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> versionNumber={})</td></tr>
<tr class="memdesc:a53668fb61c4310fa8f1a11d8e414cbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a281b905219e719a1a0cdbd9d8d42d1dd" title="Write the data to device. ">write()</a>, but allows the implementation to destroy the content of the user buffer in the process.  <a href="#a53668fb61c4310fa8f1a11d8e414cbc8">More...</a><br /></td></tr>
<tr class="separator:a53668fb61c4310fa8f1a11d8e414cbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb675e7a009887922e8975c92cb13435"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#adb675e7a009887922e8975c92cb13435">isReadOnly</a> () const</td></tr>
<tr class="memdesc:adb675e7a009887922e8975c92cb13435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is read only, i.e.  <a href="#adb675e7a009887922e8975c92cb13435">More...</a><br /></td></tr>
<tr class="separator:adb675e7a009887922e8975c92cb13435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6532a803d31c0bcd2f3c63b7610ab8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a4b6532a803d31c0bcd2f3c63b7610ab8">isReadable</a> () const</td></tr>
<tr class="memdesc:a4b6532a803d31c0bcd2f3c63b7610ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is readable.  <a href="#a4b6532a803d31c0bcd2f3c63b7610ab8">More...</a><br /></td></tr>
<tr class="separator:a4b6532a803d31c0bcd2f3c63b7610ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e81454408558284a43b35cf5528c490"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a6e81454408558284a43b35cf5528c490">isWriteable</a> () const</td></tr>
<tr class="memdesc:a6e81454408558284a43b35cf5528c490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is writeable.  <a href="#a6e81454408558284a43b35cf5528c490">More...</a><br /></td></tr>
<tr class="separator:a6e81454408558284a43b35cf5528c490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2e43388030a0136b71430ca8b920b7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a1a2e43388030a0136b71430ca8b920b7">getHardwareAccessingElements</a> ()</td></tr>
<tr class="memdesc:a1a2e43388030a0136b71430ca8b920b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the underlying TransferElements with actual hardware access.  <a href="#a1a2e43388030a0136b71430ca8b920b7">More...</a><br /></td></tr>
<tr class="separator:a1a2e43388030a0136b71430ca8b920b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842ee5157edbfe0e1d5c248c343a6dd4"><td class="memItemLeft" align="right" valign="top">std::list&lt; boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a842ee5157edbfe0e1d5c248c343a6dd4">getInternalElements</a> ()</td></tr>
<tr class="memdesc:a842ee5157edbfe0e1d5c248c343a6dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the full list of TransferElements internally used by this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a842ee5157edbfe0e1d5c248c343a6dd4">More...</a><br /></td></tr>
<tr class="separator:a842ee5157edbfe0e1d5c248c343a6dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa171eea3cb1539fa1370753f5004df8a"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#aa171eea3cb1539fa1370753f5004df8a">getHighLevelImplElement</a> ()</td></tr>
<tr class="memdesc:aa171eea3cb1539fa1370753f5004df8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the highest level implementation <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#aa171eea3cb1539fa1370753f5004df8a">More...</a><br /></td></tr>
<tr class="separator:aa171eea3cb1539fa1370753f5004df8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4016da23732e91a38e484e8cf9808f67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a4016da23732e91a38e484e8cf9808f67">isInitialised</a> () const</td></tr>
<tr class="memdesc:a4016da23732e91a38e484e8cf9808f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if the accessor is properly initialised.  <a href="#a4016da23732e91a38e484e8cf9808f67">More...</a><br /></td></tr>
<tr class="separator:a4016da23732e91a38e484e8cf9808f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67bef82a23eb01b2e9f20de95ca0a75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#aa67bef82a23eb01b2e9f20de95ca0a75">replace</a> (const <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html">TransferElementAbstractor</a> &amp;newAccessor)</td></tr>
<tr class="memdesc:aa67bef82a23eb01b2e9f20de95ca0a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a new accessor to this <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html" title="Base class for register accessors abstractors independent of the UserType. ">TransferElementAbstractor</a>.  <a href="#aa67bef82a23eb01b2e9f20de95ca0a75">More...</a><br /></td></tr>
<tr class="separator:aa67bef82a23eb01b2e9f20de95ca0a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a21c83adc1ea35f76989a98ef1213a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#ae4a21c83adc1ea35f76989a98ef1213a">replace</a> (boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt; newImpl)</td></tr>
<tr class="memdesc:ae4a21c83adc1ea35f76989a98ef1213a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative signature of relace() with the same functionality, used when a pointer to the implementation has been obtained directly (instead of a <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html" title="Base class for register accessors abstractors independent of the UserType. ">TransferElementAbstractor</a>).  <a href="#ae4a21c83adc1ea35f76989a98ef1213a">More...</a><br /></td></tr>
<tr class="separator:ae4a21c83adc1ea35f76989a98ef1213a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19754dfcd367d6b178e782d3fc490a85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a19754dfcd367d6b178e782d3fc490a85">replaceTransferElement</a> (boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt; newElement)</td></tr>
<tr class="memdesc:a19754dfcd367d6b178e782d3fc490a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for all underlying TransferElements which are considered identicel (see mayReplaceOther()) with the given <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#a19754dfcd367d6b178e782d3fc490a85">More...</a><br /></td></tr>
<tr class="separator:a19754dfcd367d6b178e782d3fc490a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781f771e098890bc458ea65e24cea376"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a781f771e098890bc458ea65e24cea376">setPersistentDataStorage</a> (boost::shared_ptr&lt; ChimeraTK::PersistentDataStorage &gt; storage)</td></tr>
<tr class="memdesc:a781f771e098890bc458ea65e24cea376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate a persistent data storage object to be updated on each write operation of this ProcessArray.  <a href="#a781f771e098890bc458ea65e24cea376">More...</a><br /></td></tr>
<tr class="separator:a781f771e098890bc458ea65e24cea376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4c01a7604516958f57d8ec67f4aa5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_transfer_element_i_d.html">TransferElementID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#afb4c01a7604516958f57d8ec67f4aa5e">getId</a> () const</td></tr>
<tr class="memdesc:afb4c01a7604516958f57d8ec67f4aa5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain unique ID for the actual implementation of this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#afb4c01a7604516958f57d8ec67f4aa5e">More...</a><br /></td></tr>
<tr class="separator:afb4c01a7604516958f57d8ec67f4aa5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90726f6d4ebc3d3d0145f43098bff8bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a90726f6d4ebc3d3d0145f43098bff8bc">transferFutureWaitCallback</a> ()</td></tr>
<tr class="memdesc:a90726f6d4ebc3d3d0145f43098bff8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function called by the <a class="el" href="class_chimera_t_k_1_1_transfer_future.html" title="Special future returned by TransferElement::readAsync(). ">TransferFuture</a> before entering a potentially blocking wait().  <a href="#a90726f6d4ebc3d3d0145f43098bff8bc">More...</a><br /></td></tr>
<tr class="separator:a90726f6d4ebc3d3d0145f43098bff8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1faf0fed03eb94768e3127b0eb067fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#ad1faf0fed03eb94768e3127b0eb067fb">setDataValidity</a> (<a class="el" href="namespace_chimera_t_k.html#a9a7d226a45242c6825eb7a26235298df">DataValidity</a> valid=<a class="el" href="namespace_chimera_t_k.html#a9a7d226a45242c6825eb7a26235298dfa444bcb3a3fcf8389296c49467f27e1d6">DataValidity::ok</a>)</td></tr>
<tr class="memdesc:ad1faf0fed03eb94768e3127b0eb067fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current DataValidity for this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.  <a href="#ad1faf0fed03eb94768e3127b0eb067fb">More...</a><br /></td></tr>
<tr class="separator:ad1faf0fed03eb94768e3127b0eb067fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90132a50a99c2bff143b4937ff242789"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_chimera_t_k.html#a9a7d226a45242c6825eb7a26235298df">DataValidity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a90132a50a99c2bff143b4937ff242789">dataValidity</a> () const</td></tr>
<tr class="memdesc:a90132a50a99c2bff143b4937ff242789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return current validity of the data.  <a href="#a90132a50a99c2bff143b4937ff242789">More...</a><br /></td></tr>
<tr class="separator:a90132a50a99c2bff143b4937ff242789"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aea884943cf09b1544983a16d9438ae18"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#aea884943cf09b1544983a16d9438ae18">_impl</a></td></tr>
<tr class="memdesc:aea884943cf09b1544983a16d9438ae18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Untyped pointer to implementation.  <a href="#aea884943cf09b1544983a16d9438ae18">More...</a><br /></td></tr>
<tr class="separator:aea884943cf09b1544983a16d9438ae18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for register accessors abstractors independent of the UserType. </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00043">43</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5fc3bd8768619d4f4625842b82ecdf2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc3bd8768619d4f4625842b82ecdf2f">&#9670;&nbsp;</a></span>TransferElementAbstractor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChimeraTK::TransferElementAbstractor::TransferElementAbstractor </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td>
          <td class="paramname"><em>impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> implementation. </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00046">46</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a28eaff61621c50693b307e232072ab35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28eaff61621c50693b307e232072ab35">&#9670;&nbsp;</a></span>TransferElementAbstractor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChimeraTK::TransferElementAbstractor::TransferElementAbstractor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an uninitialised abstractor - just for late initialisation. </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00049">49</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a90132a50a99c2bff143b4937ff242789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90132a50a99c2bff143b4937ff242789">&#9670;&nbsp;</a></span>dataValidity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_chimera_t_k.html#a9a7d226a45242c6825eb7a26235298df">DataValidity</a> ChimeraTK::TransferElementAbstractor::dataValidity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return current validity of the data. </p>
<p>Will always return <a class="el" href="namespace_chimera_t_k.html#a9a7d226a45242c6825eb7a26235298dfa444bcb3a3fcf8389296c49467f27e1d6">DataValidity::ok</a> if the backend does not support it </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00289">289</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="acc639d986bbab7f30b86c6f8f8596e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc639d986bbab7f30b86c6f8f8596e57">&#9670;&nbsp;</a></span>getAccessModeFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1_access_mode_flags.html">AccessModeFlags</a> ChimeraTK::TransferElementAbstractor::getAccessModeFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the <a class="el" href="class_chimera_t_k_1_1_access_mode_flags.html" title="Set of AccessMode flags with additional functionality for an easier handling. ">AccessModeFlags</a> for this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00066">66</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="class_chimera_t_k_1_1_transfer_element_abstractor_acc639d986bbab7f30b86c6f8f8596e57_icgraph.svg" width="100%" height="476"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="ad13db8be528e984ee93035b5e584b7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13db8be528e984ee93035b5e584b7af">&#9670;&nbsp;</a></span>getDescription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; ChimeraTK::TransferElementAbstractor::getDescription </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the description of this variable/register. </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00059">59</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a1a2e43388030a0136b71430ca8b920b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2e43388030a0136b71430ca8b920b7">&#9670;&nbsp;</a></span>getHardwareAccessingElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;boost::shared_ptr&lt;<a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a>&gt; &gt; ChimeraTK::TransferElementAbstractor::getHardwareAccessingElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the underlying TransferElements with actual hardware access. </p>
<p>If this transfer element is directly reading from / writing to the hardware, it will return a list just containing a shared pointer of itself.</p>
<p>Note: Avoid using this in application code, since it will break the abstraction! </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00170">170</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="aa171eea3cb1539fa1370753f5004df8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa171eea3cb1539fa1370753f5004df8a">&#9670;&nbsp;</a></span>getHighLevelImplElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a>&gt; ChimeraTK::TransferElementAbstractor::getHighLevelImplElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the highest level implementation <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>For TransferElements which are itself an implementation this will directly return a shared pointer to this. If this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> is a user frontend, the pointer to the internal implementation is returned.</p>
<p>Note: Avoid using this in application code, since it will break the abstraction! </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00208">208</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>
<div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="class_chimera_t_k_1_1_transfer_element_abstractor_aa171eea3cb1539fa1370753f5004df8a_icgraph.svg" width="100%" height="388"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="afb4c01a7604516958f57d8ec67f4aa5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4c01a7604516958f57d8ec67f4aa5e">&#9670;&nbsp;</a></span>getId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1_transfer_element_i_d.html">TransferElementID</a> ChimeraTK::TransferElementAbstractor::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain unique ID for the actual implementation of this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>This means that e.g. two instances of <a class="el" href="class_chimera_t_k_1_1_scalar_register_accessor.html" title="Accessor class to read and write scalar registers transparently by using the accessor object like a v...">ScalarRegisterAccessor</a> created by the same call to <a class="el" href="class_chimera_t_k_1_1_device.html#a953db6616908b17380fb1ace248c5a77" title="Get a ScalarRegisterObject object for the given register. ">Device::getScalarRegisterAccessor()</a> (e.g. by copying the accessor to another using NDRegisterAccessorBridge::replace()) will have the same ID, while two instances obtained by to difference calls to <a class="el" href="class_chimera_t_k_1_1_device.html#a953db6616908b17380fb1ace248c5a77" title="Get a ScalarRegisterObject object for the given register. ">Device::getScalarRegisterAccessor()</a> will have a different ID even when accessing the very same register. </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00269">269</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>
<div id="dynsection-3" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-3-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-3-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-3-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="class_chimera_t_k_1_1_transfer_element_abstractor_afb4c01a7604516958f57d8ec67f4aa5e_icgraph.svg" width="100%" height="467"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="a842ee5157edbfe0e1d5c248c343a6dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842ee5157edbfe0e1d5c248c343a6dd4">&#9670;&nbsp;</a></span>getInternalElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;boost::shared_ptr&lt;<a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a>&gt; &gt; ChimeraTK::TransferElementAbstractor::getInternalElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the full list of TransferElements internally used by this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>The function is recursive, i.e. elements used by the elements returned by this function are also added to the list. It is guaranteed that the directly used elements are first in the list and the result from recursion is appended to the list.</p>
<p>Example: A decorator would return a list with its target <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> followed by the result of <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a842ee5157edbfe0e1d5c248c343a6dd4" title="Obtain the full list of TransferElements internally used by this TransferElement. ...">getInternalElements()</a> called on its target <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>.</p>
<p>If this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> is not using any other element, it should return an empty vector. Thus those elements which return a list just containing themselves in <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a1a2e43388030a0136b71430ca8b920b7" title="Obtain the underlying TransferElements with actual hardware access. ">getHardwareAccessingElements()</a> will return an empty list here in <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a842ee5157edbfe0e1d5c248c343a6dd4" title="Obtain the full list of TransferElements internally used by this TransferElement. ...">getInternalElements()</a>.</p>
<p>Note: Avoid using this in application code, since it will break the abstraction! </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00193">193</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="aa2ce6abbffcd87c4168594749068dd9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ce6abbffcd87c4168594749068dd9d">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; ChimeraTK::TransferElementAbstractor::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name that identifies the process variable. </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00052">52</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>
<div id="dynsection-4" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-4-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-4-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-4-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="class_chimera_t_k_1_1_transfer_element_abstractor_aa2ce6abbffcd87c4168594749068dd9d_icgraph.svg" width="100%" height="476"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="aaec6a18f44e33212f7b306d16e7bfb93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec6a18f44e33212f7b306d16e7bfb93">&#9670;&nbsp;</a></span>getUnit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; ChimeraTK::TransferElementAbstractor::getUnit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the engineering unit. </p>
<p>If none was specified, it will default to "n./a." </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00056">56</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="aceda7d828e20665cf3d25195565e4ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceda7d828e20665cf3d25195565e4ebe">&#9670;&nbsp;</a></span>getValueType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::type_info&amp; ChimeraTK::TransferElementAbstractor::getValueType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <code>std::type_info</code> for the value type of this transfer element. </p>
<p>This can be used to determine the type at runtime. </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00063">63</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a05416264bd9c68ac18d9ba5b476cc801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05416264bd9c68ac18d9ba5b476cc801">&#9670;&nbsp;</a></span>getVersionNumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> ChimeraTK::TransferElementAbstractor::getVersionNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the version number that is associated with the last transfer (i.e. </p>
<p>last read or write). See <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation. ">ChimeraTK::VersionNumber</a> for details. </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00135">135</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a4016da23732e91a38e484e8cf9808f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4016da23732e91a38e484e8cf9808f67">&#9670;&nbsp;</a></span>isInitialised()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChimeraTK::TransferElementAbstractor::isInitialised </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return if the accessor is properly initialised. </p>
<p>It is initialised if it was constructed passing the pointer to an implementation (a <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html" title="N-dimensional register accessor. ">NDRegisterAccessor</a>), it is not initialised if it was constructed only using the placeholder constructor without arguments. </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00214">214</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a4b6532a803d31c0bcd2f3c63b7610ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6532a803d31c0bcd2f3c63b7610ab8">&#9670;&nbsp;</a></span>isReadable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChimeraTK::TransferElementAbstractor::isReadable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if transfer element is readable. </p>
<p>It throws an acception if you try to read and <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a4b6532a803d31c0bcd2f3c63b7610ab8" title="Check if transfer element is readable. ">isReadable()</a> is not true. </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00156">156</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>
<div id="dynsection-5" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-5-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-5-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-5-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="class_chimera_t_k_1_1_transfer_element_abstractor_a4b6532a803d31c0bcd2f3c63b7610ab8_icgraph.svg" width="100%" height="476"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="adb675e7a009887922e8975c92cb13435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb675e7a009887922e8975c92cb13435">&#9670;&nbsp;</a></span>isReadOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChimeraTK::TransferElementAbstractor::isReadOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if transfer element is read only, i.e. </p>
<p>it is readable but not writeable. </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00152">152</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>
<div id="dynsection-6" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-6-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-6-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-6-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="class_chimera_t_k_1_1_transfer_element_abstractor_adb675e7a009887922e8975c92cb13435_icgraph.svg" width="100%" height="388"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="a6e81454408558284a43b35cf5528c490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e81454408558284a43b35cf5528c490">&#9670;&nbsp;</a></span>isWriteable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChimeraTK::TransferElementAbstractor::isWriteable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if transfer element is writeable. </p>
<p>It throws an acception if you try to write and <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a6e81454408558284a43b35cf5528c490" title="Check if transfer element is writeable. ">isWriteable()</a> is not true. </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00160">160</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a66980fe7b7c0dc937361e71b1750767f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66980fe7b7c0dc937361e71b1750767f">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChimeraTK::TransferElementAbstractor::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data from the device. </p>
<p>If <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> was set, this function will block until new data has arrived. Otherwise it still might block for a short time until the data transfer was complete. </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00071">71</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>
<div id="dynsection-7" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-7-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-7-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-7-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_chimera_t_k_1_1_transfer_element_abstractor_a66980fe7b7c0dc937361e71b1750767f_icgraph.svg" width="322" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a3990e6181ae284f48b74b6429b8b88c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3990e6181ae284f48b74b6429b8b88c4">&#9670;&nbsp;</a></span>readAsync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1_transfer_future.html">TransferFuture</a> ChimeraTK::TransferElementAbstractor::readAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the device in the background and return a future which will be fulfilled when the data is ready. </p>
<p>When the future is fulfilled, the transfer element will already contain the new data, there is no need to call <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a66980fe7b7c0dc937361e71b1750767f" title="Read the data from the device. ">read()</a> or <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#aa96628a4ab593aff6f21d06cac6661b8" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a> (which would trigger another data transfer).</p>
<p>It is allowed to call this function multiple times, which will return the same (shared) future until it is fulfilled. If other read functions (like <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a66980fe7b7c0dc937361e71b1750767f" title="Read the data from the device. ">read()</a> or <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#aa96628a4ab593aff6f21d06cac6661b8" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>) are called before the future previously returned by this function was fulfilled, that call will be equivalent to the respective call on the future (i.e. <a class="el" href="class_chimera_t_k_1_1_transfer_future.html#ac69099e41046c798d94c8289c335574d" title="Block the current thread until the new data has arrived. ">TransferFuture::wait()</a> resp. <a class="el" href="class_chimera_t_k_1_1_transfer_future.html#a710abb76e96232132a9ace5bf6135e37" title="Check if new data has arrived. ">TransferFuture::hasNewData()</a>) and thus the future will hae been used afterwards.</p>
<p>The future will be fulfilled at the time when normally <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a66980fe7b7c0dc937361e71b1750767f" title="Read the data from the device. ">read()</a> would return. A call to this function is roughly logically equivalent to: boost::async( boost::bind(&amp;TransferElement::read, this) ); (Although such implementation would disallow accessing the user data buffer until the future is fulfilled, which is not the case for this function.)</p>
<p>Design note: A special type of future has to be returned to allow an abstraction from the implementation details of the backend. This allows - depending on the backend type - a more efficient implementation without launching a thread.</p>
<p>Note for implementations: Inside this function and before launching the actual transfer, the flag readTransactionInProgress must be cleared, then preRead() has to be called. Otherwise postRead() will not get executed after the transfer. postRead() on the other hand must not be called inside this function, since this would update the user buffer, which should only happen when waiting on the <a class="el" href="class_chimera_t_k_1_1_transfer_future.html" title="Special future returned by TransferElement::readAsync(). ">TransferFuture</a>. <a class="el" href="class_chimera_t_k_1_1_transfer_future.html#ac69099e41046c798d94c8289c335574d" title="Block the current thread until the new data has arrived. ">TransferFuture::wait()</a> will automatically call postRead() before returning. Decorators must also call preRead() in their implementations of <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a3990e6181ae284f48b74b6429b8b88c4" title="Read data from the device in the background and return a future which will be fulfilled when the data...">readAsync()</a>!</p>
<p>Note: This feature is still experimental. Expect API changes without notice! </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00129">129</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>
<div id="dynsection-8" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-8-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-8-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-8-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="class_chimera_t_k_1_1_transfer_element_abstractor_a3990e6181ae284f48b74b6429b8b88c4_icgraph.svg" width="100%" height="461"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="a11934cb06f61290f398e22428b26a005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11934cb06f61290f398e22428b26a005">&#9670;&nbsp;</a></span>readLatest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChimeraTK::TransferElementAbstractor::readLatest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the latest value, discarding any other update since the last read if present. </p>
<p>Otherwise this function is identical to <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#aa96628a4ab593aff6f21d06cac6661b8" title="Read the next value, if available in the input buffer. ">readNonBlocking()</a>, i.e. it will never wait for new values and it will return whether a new value was available if <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> is set. </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00090">90</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="aa96628a4ab593aff6f21d06cac6661b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96628a4ab593aff6f21d06cac6661b8">&#9670;&nbsp;</a></span>readNonBlocking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChimeraTK::TransferElementAbstractor::readNonBlocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the next value, if available in the input buffer. </p>
<p>If <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> was set, this function returns immediately and the return value indicated if a new value was available (<code>true</code>) or not (<code>false</code>).</p>
<p>If <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> was not set, this function is identical to <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a66980fe7b7c0dc937361e71b1750767f" title="Read the data from the device. ">read()</a>, which will still return quickly. Depending on the actual transfer implementation, the backend might need to transfer data to obtain the current value before returning. Also this function is not guaranteed to be lock free. The return value will be always true in this mode. </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00084">84</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="aa67bef82a23eb01b2e9f20de95ca0a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67bef82a23eb01b2e9f20de95ca0a75">&#9670;&nbsp;</a></span>replace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChimeraTK::TransferElementAbstractor::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html">TransferElementAbstractor</a> &amp;&#160;</td>
          <td class="paramname"><em>newAccessor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a new accessor to this <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html" title="Base class for register accessors abstractors independent of the UserType. ">TransferElementAbstractor</a>. </p>
<p>Since another <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html" title="Base class for register accessors abstractors independent of the UserType. ">TransferElementAbstractor</a> is passed as argument, both <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html" title="Base class for register accessors abstractors independent of the UserType. ">TransferElementAbstractor</a> will then point to the same accessor and thus are sharing the same buffer. To obtain a new copy of the accessor with a distinct buffer, the corresponding getXXRegisterAccessor() function of <a class="el" href="class_chimera_t_k_1_1_device.html" title="Class allows to read/write registers from device. ">Device</a> must be called. </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00222">222</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="ae4a21c83adc1ea35f76989a98ef1213a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a21c83adc1ea35f76989a98ef1213a">&#9670;&nbsp;</a></span>replace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChimeraTK::TransferElementAbstractor::replace </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td>
          <td class="paramname"><em>newImpl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternative signature of relace() with the same functionality, used when a pointer to the implementation has been obtained directly (instead of a <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html" title="Base class for register accessors abstractors independent of the UserType. ">TransferElementAbstractor</a>). </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00227">227</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a19754dfcd367d6b178e782d3fc490a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19754dfcd367d6b178e782d3fc490a85">&#9670;&nbsp;</a></span>replaceTransferElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChimeraTK::TransferElementAbstractor::replaceTransferElement </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td>
          <td class="paramname"><em>newElement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for all underlying TransferElements which are considered identicel (see mayReplaceOther()) with the given <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>These TransferElements are then replaced with the new element. If no underlying element matches the new element, this function has no effect. </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00235">235</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>
<div id="dynsection-9" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-9-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-9-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-9-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="class_chimera_t_k_1_1_transfer_element_abstractor_a19754dfcd367d6b178e782d3fc490a85_icgraph.svg" width="100%" height="388"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="ad1faf0fed03eb94768e3127b0eb067fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1faf0fed03eb94768e3127b0eb067fb">&#9670;&nbsp;</a></span>setDataValidity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChimeraTK::TransferElementAbstractor::setDataValidity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_chimera_t_k.html#a9a7d226a45242c6825eb7a26235298df">DataValidity</a>&#160;</td>
          <td class="paramname"><em>valid</em> = <code><a class="el" href="namespace_chimera_t_k.html#a9a7d226a45242c6825eb7a26235298dfa444bcb3a3fcf8389296c49467f27e1d6">DataValidity::ok</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current DataValidity for this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a>. </p>
<p>Will do nothing if the backend does not support it </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00285">285</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a781f771e098890bc458ea65e24cea376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781f771e098890bc458ea65e24cea376">&#9670;&nbsp;</a></span>setPersistentDataStorage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChimeraTK::TransferElementAbstractor::setPersistentDataStorage </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; ChimeraTK::PersistentDataStorage &gt;&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associate a persistent data storage object to be updated on each write operation of this ProcessArray. </p>
<p>If no persistent data storage as associated previously, the value from the persistent storage is read and send to the receiver.</p>
<p>Note: A call to this function will be ignored, if the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> does not support persistent data storage (e.g. read-only variables or device registers)</p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000060">Todo:</a></b></dt><dd>TODO does this make sense? </dd></dl>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00256">256</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a90726f6d4ebc3d3d0145f43098bff8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90726f6d4ebc3d3d0145f43098bff8bc">&#9670;&nbsp;</a></span>transferFutureWaitCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChimeraTK::TransferElementAbstractor::transferFutureWaitCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function called by the <a class="el" href="class_chimera_t_k_1_1_transfer_future.html" title="Special future returned by TransferElement::readAsync(). ">TransferFuture</a> before entering a potentially blocking wait(). </p>
<p>In contrast to a wait callback of a boost::future/promise, this function is not called when just checking whether the result is ready or not. Usually it is not necessary to implement this function, but decorators should pass it on. One use case is the ApplicationCore TestDecoratorRegisterAccessor, which needs to be informed before blocking the thread execution. Note: The <a class="el" href="class_chimera_t_k_1_1_read_any_group.html" title="Group several registers (= TransferElement) to allow waiting for an update of any of the registers...">ReadAnyGroup</a> will trigger a call to this function of the first <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> with <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read. ">AccessMode::wait_for_new_data</a> in the group before potentially blocking. </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00281">281</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a281b905219e719a1a0cdbd9d8d42d1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281b905219e719a1a0cdbd9d8d42d1dd">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChimeraTK::TransferElementAbstractor::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a>&#160;</td>
          <td class="paramname"><em>versionNumber</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the data to device. </p>
<p>The return value is true, old data was lost on the write transfer (e.g. due to an buffer overflow). In case of an unbuffered write transfer, the return value will always be false. </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00140">140</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>
<div id="dynsection-10" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-10-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-10-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-10-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_chimera_t_k_1_1_transfer_element_abstractor_a281b905219e719a1a0cdbd9d8d42d1dd_icgraph.svg" width="322" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a53668fb61c4310fa8f1a11d8e414cbc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53668fb61c4310fa8f1a11d8e414cbc8">&#9670;&nbsp;</a></span>writeDestructively()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChimeraTK::TransferElementAbstractor::writeDestructively </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a>&#160;</td>
          <td class="paramname"><em>versionNumber</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just like <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a281b905219e719a1a0cdbd9d8d42d1dd" title="Write the data to device. ">write()</a>, but allows the implementation to destroy the content of the user buffer in the process. </p>
<p>This is an optional optimisation, hence there is a default implementation which just calls the normal doWriteTransfer(). In any case, the application must expect the user buffer of the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup. ">TransferElement</a> to contain undefined data after calling this function. </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00146">146</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aea884943cf09b1544983a16d9438ae18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea884943cf09b1544983a16d9438ae18">&#9670;&nbsp;</a></span>_impl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a>&gt; ChimeraTK::TransferElementAbstractor::_impl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Untyped pointer to implementation. </p>

<p class="definition">Definition at line <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html#l00293">293</a> of file <a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>device/include/<a class="el" href="device_2include_2_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_chimera_t_k.html">ChimeraTK</a></li><li class="navelem"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html">TransferElementAbstractor</a></li>
    <li class="footer">Generated on Sat Jan 25 2020 04:53:09 for ChimeraTK-DeviceAccess by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
