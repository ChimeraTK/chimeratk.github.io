<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ChimeraTK-DeviceAccess: Design: AsyncNDRegisterAccessor</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ChimeraTK_Logo_whitebg.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ChimeraTK-DeviceAccess
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('design__async_n_d_register_accessor__numeric_addressed.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Design: <a class="el" href="class_chimera_t_k_1_1_async_n_d_register_accessor.html" title="The AsyncNDRegisterAccessor implements a data transport queue with typed data as continuation of the ...">AsyncNDRegisterAccessor</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="conceptOverview"></a>
Concept overview</h1>
<dl class="section warning"><dt>Warning</dt><dd>This concept is outdated. It describes the current state but will change with the introduction of nested interrupts and interrupt controller handlers!</dd></dl>
<div class="image">
<img src="NABackendAsyncConcept.png" alt="" width="1000"/>
<div class="caption">
object diagram for AyncNDRegisterAccessor</div></div>
<ul>
<li>For each AsyncAccessor that user requests: an <a class="el" href="struct_chimera_t_k_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a> is created interally, with 1:1 correspondence AsyncAccessor â†” AsyncVar</li>
<li>AsyncAccessor reads from AsyncVar and is handed out to user; <a class="el" href="struct_chimera_t_k_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a> holds the send buffer which is used to fill userBuffer of AsyncAccessor later</li>
<li>NumericAddressedAsyncVarImpl implements filling the send buffer from a syncAccessor to the requested register</li>
<li><a class="el" href="class_chimera_t_k_1_1_numeric_addressed_interrupt_dispatcher.html" title="The NumericAddressedInterruptDispatcher has two main functionalities:">NumericAddressedInterruptDispatcher</a> is responsible for one interrupt number and collects related SyncAccessors in a transferGroup for efficiency. It implements the actual trigger action (on interrupt), relying on NumericAddressedAsyncVarImpl::filledSendBuffer().</li>
<li>AsyncVarImpl holds only a weak pointer to the AsyncAccessor, since we want to be sensitive to the user discarding the latter</li>
<li><a class="el" href="class_chimera_t_k_1_1_numeric_addressed_interrupt_dispatcher.html" title="The NumericAddressedInterruptDispatcher has two main functionalities:">NumericAddressedInterruptDispatcher</a>, as a <a class="el" href="class_chimera_t_k_1_1_async_accessor_manager.html" title="The AsyncAccessorManager has three main functionalities:">AsyncAccessorManager</a>, owns and manages the AsyncVariables (in a map).</li>
<li>Actual copy operations are eliminated by usage of swap, i.e. only pointers are handed over between the buffer containers.</li>
<li>Exception handling: If any exception occurs during read/write, <a class="el" href="class_chimera_t_k_1_1_async_accessor_manager.html" title="The AsyncAccessorManager has three main functionalities:">AsyncAccessorManager</a> deactivates the AsyncVariables and provides each of them the exception. When activated again, it makes sure new or initial values from the SyncAccessors are provided.</li>
<li>Deletion: once user releases shared pointer to AsyncNDRegAcc, its destructor calls <a class="el" href="class_chimera_t_k_1_1_async_accessor_manager.html#ac1896007e5233e8b957b112f30aea303" title="This function must only be called from the destructor of the AsyncNDRegisterAccessor which is created...">AsyncAccessorManager::unsubscribe()</a>. Since the syncAccessors in the <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group.">TransferGroup</a> keep a shared pointer to the NumericAddressBackend, unsubscribe() must also take care to clean up <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group.">TransferGroup</a>.</li>
</ul>
<h1><a class="anchor" id="design_AsyncNDRegisterAccessor"></a>
The AsyncNDRegisterAccessor and the AsyncAccessorManager</h1>
<p>The <a class="el" href="class_chimera_t_k_1_1_async_n_d_register_accessor.html" title="The AsyncNDRegisterAccessor implements a data transport queue with typed data as continuation of the ...">AsyncNDRegisterAccessor</a> is a generic <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html" title="N-dimensional register accessor.">NDRegisterAccessor</a> implementation for push-type data. It is used if accessors with <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read.">AccessMode::wait_for_new_data</a> are requested. See <a class="el" href="spec__transfer_element.html#transferElement_B_8">Technical specification: TransferElement B.8</a> for the requirements it is based on.</p>
<p>The <a class="el" href="class_chimera_t_k_1_1_async_n_d_register_accessor.html" title="The AsyncNDRegisterAccessor implements a data transport queue with typed data as continuation of the ...">AsyncNDRegisterAccessor</a> is a generic implementation which can be used for all backends and contains the following components</p>
<ul>
<li>a lock free queue to transport data of type NDRegisterAccessor&lt;UserType&gt;::Buffer, which contains the data value (2D vector of UserType), a <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation.">VersionNumber</a> and a DataValidity flag.</li>
<li>functions to activate/deactivate the accessor, and to push data and exceptions into the queue</li>
<li>a (synchronous) accessor which is used for write operations (optional)</li>
</ul>
<p>A <em>trigger domain</em> is a set of registers for which the data is always send together. Examples:</p>
<ul>
<li>For the pcie backend, a set of registers described in the map file is read from the device and the data is pushed into the according AsyncNDRegisterAccessessors when the according interrupt occurs.</li>
<li>For push-type data with a composed data type, DeviceAccess provides individual registers for the components which make up a trigger domain (e.g. for a DOOCS IFFF there is one int and three floats in the trigger domain).</li>
<li>A trigger domain can consist of a single register.</li>
</ul>
<p>One <a class="el" href="class_chimera_t_k_1_1_async_accessor_manager.html" title="The AsyncAccessorManager has three main functionalities:">AsyncAccessorManager</a> is used per trigger domain. The <a class="el" href="class_chimera_t_k_1_1_async_accessor_manager.html" title="The AsyncAccessorManager has three main functionalities:">AsyncAccessorManager</a> has three main functions:</p>
<ul>
<li>It serves as a factory for AsyncNDRegisterAccessors</li>
<li>It contains a list of created asynchronous accessors and a subscribe/unsubscribe mechanism</li>
<li>It provides functions to act on all asynchronous accessors</li>
</ul>
<h2><a class="anchor" id="AsyncNDRegisterAccessor_details"></a>
Design decisions and implementation details</h2>
<ul>
<li>The data transport queue contains data that is already converted to the UserType, so the potentially expensive and slow operations (data readout, de-multiplexing, data conversion) are happening only once, before the data is distributed to multiple subscribers.</li>
<li>To unsubscribe, the <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html" title="N-dimensional register accessor.">NDRegisterAccessor</a> is calling <a class="el" href="class_chimera_t_k_1_1_async_accessor_manager.html#ac1896007e5233e8b957b112f30aea303" title="This function must only be called from the destructor of the AsyncNDRegisterAccessor which is created...">AsyncAccessorManager::unsubscribe()</a> with its <a class="el" href="class_chimera_t_k_1_1_transfer_element_i_d.html" title="Simple class holding a unique ID for a TransferElement.">TransferElementID</a> from the destructor.</li>
<li>The class <a class="el" href="struct_chimera_t_k_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a> represents the sender side of the asynchronous accessor.<a class="el" href="design__async_n_d_register_accessor__numeric_addressed.html#asyncAccessor_comment_AsyncVariable">(*)</a> It provides functions to send data and exceptions, to activate and to deactivate the accessors, and it implements all the handling of the contained <a class="el" href="class_chimera_t_k_1_1_async_n_d_register_accessor.html" title="The AsyncNDRegisterAccessor implements a data transport queue with typed data as continuation of the ...">AsyncNDRegisterAccessor</a> instance. In addition it provides shape information for creating AsyncNDRegisterAccessors to the <a class="el" href="class_chimera_t_k_1_1_async_accessor_manager.html" title="The AsyncAccessorManager has three main functionalities:">AsyncAccessorManager</a>.</li>
<li>A send buffer is contained in the <a class="el" href="struct_chimera_t_k_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a> to avoid dynamic memory allocation.</li>
<li>The void notification queue in the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> base class is set up as a continuation of the data transport queue, such that the read operations of the notification queue trigger the filling of the user buffer.</li>
</ul>
<p><a class="anchor" id="asyncAccessor_comment_AsyncVariable"></a>(*) C++ implementation detail: There is <a class="el" href="struct_chimera_t_k_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a> as an untyped base class and <a class="el" href="struct_chimera_t_k_1_1_async_variable_impl.html" title="AsyncVariableImpl contains a weak pointer to an AsyncNDRegisterAccessor&lt;UserType&gt; and a send buffer N...">AsyncVariableImpl</a>, which is templated to a user type. Like this pointers to variables with different user types can be stored in one list.</p>
<h2><a class="anchor" id="AsyncNDRegisterAccessor_usage"></a>
Interface for implementing backends</h2>
<p>While the <a class="el" href="class_chimera_t_k_1_1_async_n_d_register_accessor.html" title="The AsyncNDRegisterAccessor implements a data transport queue with typed data as continuation of the ...">AsyncNDRegisterAccessor</a> itself is complete and universal, the <a class="el" href="class_chimera_t_k_1_1_async_accessor_manager.html" title="The AsyncAccessorManager has three main functionalities:">AsyncAccessorManager</a> and <a class="el" href="struct_chimera_t_k_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a> have pure virtual functions which must be provided by the individual backend implementations:</p><ul>
<li><a class="el" href="struct_chimera_t_k_1_1_async_variable.html#a1e96b483164569b2d6c30b316a4908cf" title="Helper functions for the creation of an AsyncNDRegisterAccessor.">AsyncVariable::getNumberOfChannels()</a>, <a class="el" href="struct_chimera_t_k_1_1_async_variable.html#a698fdfc524b4a2e316dbf1da1769a3bb">AsyncVariable::getNumberOfSamples()</a>, <a class="el" href="struct_chimera_t_k_1_1_async_variable.html#a40548824a2858265e87346f62d0ae16f">AsyncVariable::getUnit()</a>, <a class="el" href="struct_chimera_t_k_1_1_async_variable.html#a2d24d1b47120921d20c09d69d566f06b">AsyncVariable::getDescription()</a> and <a class="el" href="struct_chimera_t_k_1_1_async_variable.html#a59cd9a2927facae974f48fb6390d02c5">AsyncVariable::isWriteable()</a> must be provided by deriving from <a class="el" href="struct_chimera_t_k_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a> or <a class="el" href="struct_chimera_t_k_1_1_async_variable_impl.html" title="AsyncVariableImpl contains a weak pointer to an AsyncNDRegisterAccessor&lt;UserType&gt; and a send buffer N...">AsyncVariableImpl</a>. The information must directly be provided by the backend. The generating code cannot rely on the catalogue here (which might not even be filled yet when the accessor is being created).<a class="el" href="design__async_n_d_register_accessor__numeric_addressed.html#asyncAccessor_comment_AsyncVariable2">(*2)</a></li>
<li>The 'virtual function template' AsyncAccessorManager::createAsyncVariable() must return an <a class="el" href="struct_chimera_t_k_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a> implementation with the implemented accessor-describing functions from the previous bullet point. When the <a class="el" href="struct_chimera_t_k_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a> object is returned by createAsyncVariable(), its weak pointer to the <a class="el" href="class_chimera_t_k_1_1_async_n_d_register_accessor.html" title="The AsyncNDRegisterAccessor implements a data transport queue with typed data as continuation of the ...">AsyncNDRegisterAccessor</a> is not set yet. createAsyncVariable() is used internally by the <a class="el" href="class_chimera_t_k_1_1_async_accessor_manager.html" title="The AsyncAccessorManager has three main functionalities:">AsyncAccessorManager</a> in the subscription process, which creates the <a class="el" href="class_chimera_t_k_1_1_async_n_d_register_accessor.html" title="The AsyncNDRegisterAccessor implements a data transport queue with typed data as continuation of the ...">AsyncNDRegisterAccessor</a> by using the shape information from the <a class="el" href="struct_chimera_t_k_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a>, and then adds it to the <a class="el" href="struct_chimera_t_k_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a>.</li>
<li><a class="el" href="class_chimera_t_k_1_1_async_accessor_manager.html#a82fdaaf8173f79c73dff28fd65e50ab7" title="Activate all accessors and send the initial value.">AsyncAccessorManager::activate()</a> needs to be implemented in the following way<a class="el" href="design__async_n_d_register_accessor__numeric_addressed.html#asyncAccessor_comment_activate">(*3)</a>:<ol type="1">
<li>Lock the _variablesMutex which protects the container of AsyncVariables, so no entries can be added or removed <a class="el" href="design__async_n_d_register_accessor__numeric_addressed.html#asyncAccessor_comment_mutex">(*4)</a></li>
<li>Generate a new version number while holding the lock</li>
<li>Write the initial value, the according data validity flag and the version number to the _sendBuffer of each <a class="el" href="struct_chimera_t_k_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a></li>
<li>Call activate() on all AsyncVariables</li>
</ol>
<ul>
<li>3. and 4. can also be implemented together by looping all variables once, i.e. preparing the _sendBuffer and activating one variable before continuing with the next one.</li>
</ul>
</li>
</ul>
<p>The backend uses the <a class="el" href="class_chimera_t_k_1_1_async_n_d_register_accessor.html" title="The AsyncNDRegisterAccessor implements a data transport queue with typed data as continuation of the ...">AsyncNDRegisterAccessor</a> by</p><ul>
<li>creating one <a class="el" href="class_chimera_t_k_1_1_async_accessor_manager.html" title="The AsyncAccessorManager has three main functionalities:">AsyncAccessorManager</a> for each trigger domain</li>
<li>calling <a class="el" href="class_chimera_t_k_1_1_async_accessor_manager.html#a1678c28514e2b294a8768e72127a44ae" title="Request a new subscription.">AsyncAccessorManager::subscribe()</a> in getRegisterAccessor(), and handing out the created <a class="el" href="class_chimera_t_k_1_1_async_n_d_register_accessor.html" title="The AsyncNDRegisterAccessor implements a data transport queue with typed data as continuation of the ...">AsyncNDRegisterAccessor</a>. If the accessor is writeable (according to the <a class="el" href="struct_chimera_t_k_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a>), the <a class="el" href="class_chimera_t_k_1_1_async_accessor_manager.html" title="The AsyncAccessorManager has three main functionalities:">AsyncAccessorManager</a> will call getRegisterAccessor() recursively without the wait_for_new_data flag for the same register, and add this accessor as write accessor to the <a class="el" href="class_chimera_t_k_1_1_async_n_d_register_accessor.html" title="The AsyncNDRegisterAccessor implements a data transport queue with typed data as continuation of the ...">AsyncNDRegisterAccessor</a>. The backend's getRegisterAccessor() implementation must be able to handle this recursive call.<a class="el" href="design__async_n_d_register_accessor__numeric_addressed.html#asyncAccessor_comment_writeable">(*5)</a></li>
<li>calling <a class="el" href="class_chimera_t_k_1_1_async_accessor_manager.html#a82fdaaf8173f79c73dff28fd65e50ab7" title="Activate all accessors and send the initial value.">AsyncAccessorManager::activate()</a> in activateAsyncRead()</li>
<li>calling <a class="el" href="class_chimera_t_k_1_1_async_accessor_manager.html#a63adeabcd93ad5ab5b8ce7cbffdae39a" title="Send an exception to all accessors.">AsyncAccessorManager::sendException()</a> in setException()</li>
<li>calling <a class="el" href="class_chimera_t_k_1_1_async_accessor_manager.html#aa79195db1c3c5d3433fa74c316f4ecc8" title="Deactivate all subscribers without throwing an exception.">AsyncAccessorManager::deactivate()</a> when the backend is closed.</li>
</ul>
<p>The code sending the data has to follow a similar sequence as <a class="el" href="class_chimera_t_k_1_1_async_accessor_manager.html#a82fdaaf8173f79c73dff28fd65e50ab7" title="Activate all accessors and send the initial value.">AsyncAccessorManager::activate()</a>:</p><ol type="1">
<li>Lock the _variablesMutex which protects the container of AsyncVariables, so no entries can be added or removed</li>
<li>Generate a new version number while holding the lock. All accessors of the same trigger domain must have the same version number for the same trigger.</li>
<li>Prepare the _sendBuffer, incl. data validity flag and version number for each <a class="el" href="struct_chimera_t_k_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a></li>
<li>Call send() on all AsyncVariables</li>
</ol>
<ul>
<li>3. and 4. can also be implemented together by looping all variables once, i.e. preparing the _sendBuffer and calling send() for one variable before continuing with the next one.</li>
</ul>
<p><a class="anchor" id="asyncAccessor_comment_AsyncVariable2"></a>(*2) The reason to put this into the <a class="el" href="struct_chimera_t_k_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a> is coming from the <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend.html" title="Base class for address-based device backends (e.g.">NumericAddressedBackend</a>. It adds a synchronous accessor to the <a class="el" href="struct_chimera_t_k_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a> which is used for reading and provides this information. The logic to generate this information is in the creation code for the synchronous accessor. Other backends might have similar advantages from having the functions the <a class="el" href="struct_chimera_t_k_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a>, or at least they don't care much where the functions are implemented.</p>
<p><a class="anchor" id="asyncAccessor_comment_activate"></a>(*3) Locking of the mutex, generating the version number and calling activate() on each variable could be factored into the manager, with additional virtual functions that are called in between, but this means the container needs to be looped several times and the design gets more complicated and involved, and hence the implementation is left to the backend.</p>
<p><a class="anchor" id="asyncAccessor_comment_mutex"></a>(*4) Holding the mutex while accessing the AsyncVariables actually serves two purposes:</p><ol type="1">
<li>It prevents the container from being modified and variables going out of scope while being accessed.</li>
<li>The AsyncVariables and the AsyncNDRegisterAcessors in them are not thread safe, and activation/deactivation, exception sending and data sending are coming from different threads.</li>
</ol>
<p><a class="anchor" id="asyncAccessor_comment_writeable"></a>(*5) Even if the implementation already has a synchronous read accessor, like the NumericAccdressedBackend, this cannot be used for writing. The write is coming from a user thread, while the read is coming from a thread receiving data though the transfer protocol.</p>
<h1><a class="anchor" id="design_async_NumericAddressedBackend"></a>
Implementation in the NumericAddressedBackend</h1>
<h2><a class="anchor" id="design_async_map_file"></a>
Asynchronous registers in the map file</h2>
<pre>
# name            nElements  address  nBytes  bar  width  bitInterpretation signed accessMode
APP.0.DATA_READY          0        0       0    0      0                  0      0 INTERRUPT1
APP.0.PUSH_DATA           4       12      16    1     32                  8      1 INTERRUPT2
</pre><p>The map file has a special access mode INTERRUPTx, in addition to the synchronous modes RW and RO. x is the numeric identifyer for a device interrupt. Registers with access mode INTERRUPT are treated as read-only. In future, this will be extended to allow nested interrupts (INTERRUPTx:y, INTERRUPTx:y:z, etc.) in combination with interrupt controller handlers.</p>
<p>For interrupts it is possible to have void-type entries. The width of these "registers" is 0 bits. For consistency all other fields also have to be 0. They don't make sense in this context and have to be 0 to avoid confusion.</p>
<h2><a class="anchor" id="implementation_async_NumericAddressed"></a>
Design and implementation details</h2>
<p>The <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend.html" title="Base class for address-based device backends (e.g.">NumericAddressedBackend</a> has a complete implementation of the <a class="el" href="class_chimera_t_k_1_1_async_accessor_manager.html" title="The AsyncAccessorManager has three main functionalities:">AsyncAccessorManager</a> and the <a class="el" href="struct_chimera_t_k_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a>, called <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_interrupt_dispatcher.html" title="The NumericAddressedInterruptDispatcher has two main functionalities:">NumericAddressedInterruptDispatcher</a> and <a class="el" href="struct_chimera_t_k_1_1_numeric_addressed_async_variable.html" title="Typeless base class.">NumericAddressedAsyncVariable</a>, respectively.</p>
<ul>
<li>Each <a class="el" href="struct_chimera_t_k_1_1_numeric_addressed_async_variable.html" title="Typeless base class.">NumericAddressedAsyncVariable</a> has a synchronous accessor for reading the data from the device when an interrupt arrives.</li>
<li>Each <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_interrupt_dispatcher.html" title="The NumericAddressedInterruptDispatcher has two main functionalities:">NumericAddressedInterruptDispatcher</a> has a transfer group with all the synchronous read accessors, so the data transfer is optimised under the hood (data is only transferred once, transfers are merged, copy decorators are used where necessary so de-multiplexing and conversion is only happening once, and the converted data is duplicated).</li>
<li>There is one <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_interrupt_dispatcher.html" title="The NumericAddressedInterruptDispatcher has two main functionalities:">NumericAddressedInterruptDispatcher</a> per interrupt that is described in the map file. They are created when the map file is being processed.</li>
<li>The accessor manager has been extended by a trigger() function, which reads the transfer groups and dispatches the read results to all subscribed asynchronous accessors.</li>
</ul>
<h2><a class="anchor" id="async_NumericAddressedBackend_interface"></a>
Interface to implementing backends</h2>
<p>The list of accessor managers is private, and all implementing backends interface with it through two functions.</p>
<ul>
<li><a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend.html#abd3e01a95b03d16f5f45e35ccf1c1c7b" title="This function is called every time an accessor which is assicated with the particular primary interru...">NumericAddressedBackend::startInterruptHandlingThread</a>(unsigned int interruptControllerNumber, unsigned int interruptNumber) is a virtual function which is called each time an accessor for that interrupt is requested. This allows the lazy start of the interrupt handling threads, which are not started if no accessors are requested. The implementation must assure that the thread is only started once. In general, the <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend.html" title="Base class for address-based device backends (e.g.">NumericAddressedBackend</a> does not take care of interrupt handling threads, except for calling this virtual function. Each backend implementation has to take care that treads are started, terminated and joined correctly. There is an empty default implementation of startInterruptHandlingThread() for backward compatibility (backends that don't support asynchronous data (yet) or that don't need a separate thread like the dummies).</li>
<li>The interrupt handling threads call <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend.html#a1eb55fcc4082f2d2407576cf1f63f89f" title="Function to be called by implementing backend when an interrupt arrives.">NumericAddressedBackend::dispatchInterrupt</a>(unsigned int interruptControllerNumber, unsigned int interruptNumber) each time the according interrupt arrives.</li>
</ul>
<p>All other functionality for subscription, activation/deactivation and exception handling is already handled in the <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend.html" title="Base class for address-based device backends (e.g.">NumericAddressedBackend</a> base class. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Sep 29 2023 03:53:22 for ChimeraTK-DeviceAccess by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
