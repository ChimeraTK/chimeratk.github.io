<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ChimeraTK-DeviceAccess: 2D Register Accessors</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ChimeraTK_Logo_whitebg.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ChimeraTK-DeviceAccess
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('accessor2d.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">2D Register Accessors </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A TwoDRegisterAccessor behaves like a two-dimensional array, consisting of several sequences (or channels) which each have a number of samples.</p>
<p>It is implemented as a buffering accessor, so you do read() and write() to access the hardware, and in between you can modify the data in the accessors buffer efficiently at will.</p>
<p>The one-dimensional sequences/channels are implemeted as std::vector, so they are convenient to use. They are accessed via the [] operator of the accessor. This also allows the "matrix" syntax <code>accessor</code>[][]. </p><dl class="section note"><dt>Note</dt><dd>As with all std::vectors, iterators are slightly more efficient because the repeated calculation of the address and indirections are not necessary for each element.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ChimeraTK/Device.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;ChimeraTK/Utilities.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="accessor1_d_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div><div class="line">  <a class="code" href="namespace_chimera_t_k.html#ac081e51ebc9ef4fe64b469290d39b7a2">ChimeraTK::setDMapFilePath</a>(<span class="stringliteral">&quot;example.dmap&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="class_chimera_t_k_1_1_device.html">ChimeraTK::Device</a> myDevice(<span class="stringliteral">&quot;MY_DEVICE&quot;</span>);</div><div class="line">  myDevice.open();</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">   * In this example there is a data region called &quot;DATA&quot; in</span></div><div class="line"><span class="comment">   * a module called &quot;ADC&quot;.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <a class="code" href="class_chimera_t_k_1_1_two_d_register_accessor.html">ChimeraTK::TwoDRegisterAccessor&lt;double&gt;</a> twoDAccessor = myDevice.getTwoDRegisterAccessor&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;ADC/DATA&quot;</span>);</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">   * Read data for all channels from the hardware</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  twoDAccessor.<a class="code" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a66980fe7b7c0dc937361e71b1750767f">read</a>();</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">   * You can access each sequence/channel individually. They are std::vectors.</span></div><div class="line"><span class="comment">   * You get a reference to the vector inside the accessor. No data copying.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; twoDAccessor.<a class="code" href="class_chimera_t_k_1_1_two_d_register_accessor.html#a5e8f42c9edf686b506dd8dcbd145de2b">getNChannels</a>(); ++i) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Channel &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;:&quot;</span>;</div><div class="line">    std::vector&lt;double&gt;&amp; channel = twoDAccessor[i];</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">double</span> sample : channel) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; sample;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">   * You can modify the stuff at will in the accessors internal buffer.</span></div><div class="line"><span class="comment">   * In this example we use two [] operators like a 2D array.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; twoDAccessor.<a class="code" href="class_chimera_t_k_1_1_two_d_register_accessor.html#a5e8f42c9edf686b506dd8dcbd145de2b">getNChannels</a>(); ++i) {</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> j = 0; j &lt; twoDAccessor.<a class="code" href="class_chimera_t_k_1_1_two_d_register_accessor.html#a260355da3297d6de2aa27ae70d3d2f97">getNElementsPerChannel</a>(); ++j) {</div><div class="line">      twoDAccessor[i][j] = i * 100 + j;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">   * Finally write to the hardware.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  twoDAccessor.<a class="code" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a281b905219e719a1a0cdbd9d8d42d1dd">write</a>();</div><div class="line"></div><div class="line">  myDevice.close();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>A special case: The 2D register might have multiplexed data on the backend side (backend specific implementation of the TwoDRegisterAccessor). This is commonly the case e.g. for PCIe backend devices. In the map file of a PCIe backend (or any other backend type based on the NumbericAddressedBackend) a special notation is used to define multiplexed 2D registers:</p>
<pre class="fragment"># name                              number_of_elements  address   size  bar  width  fracbits  signed
ADC.AREA_MULTIPLEXED_SEQUENCE_DATA                  13        0    132    2     32         0       0
ADC.SEQUENCE_DATA_0                                  1        0      2    2     16         0       1
ADC.SEQUENCE_DATA_1                                  1        2      2    2     16         0       1
ADC.SEQUENCE_DATA_2                                  1        4      4    2     20         0       1
ADC.SEQUENCE_DATA_3                                  1        8      2    2     16         0       1
</pre><p>These five lines in the map file will result in a single register named "ADC.DATA". It will have 4 sequences (or channels) with each 13 elements. The number of elements per channel is determined by the total size of the register (132 in this example) divided by the number of bytes per element summed for all channels (10 in this example), rounded down. The number of elements specified by the first line (13 in this case) is ignored, but it is convenient to write the correct number of elements per channel there. Please note that the total size of the register must be divisible by the size of the raw data type (which is fixed at 4 corrently), this is a general requirement by the NumbericAddressedBackend. The addresses of the SEQUENCE entries must be absolute addresses of each first element of the sequence in the BAR.</p>
<p>The following code demonstrates how the (de)multiplexing internally works: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ChimeraTK/Device.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;ChimeraTK/Utilities.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="accessor1_d_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div><div class="line">  <a class="code" href="namespace_chimera_t_k.html#ac081e51ebc9ef4fe64b469290d39b7a2">ChimeraTK::setDMapFilePath</a>(<span class="stringliteral">&quot;example.dmap&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="class_chimera_t_k_1_1_device.html">ChimeraTK::Device</a> myDevice(<span class="stringliteral">&quot;MY_DEVICE&quot;</span>);</div><div class="line">  myDevice.open();</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">   * We populate the memory region with multiple multiplexed sequences</span></div><div class="line"><span class="comment">   * so that we can use this for demonstrating the demultiplexing of the</span></div><div class="line"><span class="comment">   * TwoDRegisterAccessor (for some implementations depeding on the backend).</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * In this example we only have 4 sequences with 4 samples each.</span></div><div class="line"><span class="comment">   * We write numbers 0 to 15 as multiplexed data and expect the following</span></div><div class="line"><span class="comment">   * result: sequence 0:  0   4   8   12 sequence 1:  1   5   9   13 sequence 2:</span></div><div class="line"><span class="comment">   * 2   6   10  14 sequence 3:  3   7   11  15</span></div><div class="line"><span class="comment">   *</span></div><div class="line"><span class="comment">   * We use a register named AREA_DATA_RAW which provides plain access to the</span></div><div class="line"><span class="comment">   * data region.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">auto</span> dataRegion = myDevice.getOneDRegisterAccessor&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;ADC/AREA_DATA_RAW&quot;</span>);</div><div class="line">  <span class="keywordtype">int</span> counter = 0;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; dataWord : dataRegion) {</div><div class="line">    dataWord = counter++;</div><div class="line">  }</div><div class="line">  dataRegion.write();</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line"><span class="comment">   * Now check how it looks using the TwoDRegisterAccessor. We just copy it from</span></div><div class="line"><span class="comment">   * the accessor2D.cpp example.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <a class="code" href="class_chimera_t_k_1_1_two_d_register_accessor.html">ChimeraTK::TwoDRegisterAccessor&lt;double&gt;</a> twoDAccessor = myDevice.getTwoDRegisterAccessor&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;ADC/DATA&quot;</span>);</div><div class="line">  twoDAccessor.<a class="code" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a66980fe7b7c0dc937361e71b1750767f">read</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; twoDAccessor.<a class="code" href="class_chimera_t_k_1_1_two_d_register_accessor.html#a5e8f42c9edf686b506dd8dcbd145de2b">getNChannels</a>(); ++i) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Channel &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;:&quot;</span>;</div><div class="line">    std::vector&lt;double&gt;&amp; channel = twoDAccessor[i];</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">double</span> sample : channel) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; sample;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  myDevice.close();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Jul 9 2020 03:53:11 for ChimeraTK-DeviceAccess by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
