<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ChimeraTK-cppext: cppext::future_queue&lt; T, FEATURES &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ChimeraTK_Logo_whitebg.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ChimeraTK-cppext
   &#160;<span id="projectnumber">01.05.02</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classcppext_1_1future__queue.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcppext_1_1future__queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cppext::future_queue&lt; T, FEATURES &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A lockfree multi-producer single-consumer queue of a fixed length which the receiver can wait on in case the queue is empty.  
 <a href="classcppext_1_1future__queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for cppext::future_queue&lt; T, FEATURES &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classcppext_1_1future__queue__inherit__graph.svg" width="516" height="183"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3156a4f9a08e6cbe3f4761a014f9b7fc"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a3156a4f9a08e6cbe3f4761a014f9b7fc">value_type</a></td></tr>
<tr class="separator:a3156a4f9a08e6cbe3f4761a014f9b7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3dfd4b44c2c7e0f26807ce06a5deb60b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a3dfd4b44c2c7e0f26807ce06a5deb60b">future_queue</a> (size_t length)</td></tr>
<tr class="memdesc:a3dfd4b44c2c7e0f26807ce06a5deb60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The length specifies how many objects the queue can contain at a time.  <a href="classcppext_1_1future__queue.html#a3dfd4b44c2c7e0f26807ce06a5deb60b">More...</a><br /></td></tr>
<tr class="separator:a3dfd4b44c2c7e0f26807ce06a5deb60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6768cf9c3747e5c66321da41749389c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#ae6768cf9c3747e5c66321da41749389c">future_queue</a> ()</td></tr>
<tr class="memdesc:ae6768cf9c3747e5c66321da41749389c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor creates only a place holder which can later be assigned with a properly constructed queue.  <a href="classcppext_1_1future__queue.html#ae6768cf9c3747e5c66321da41749389c">More...</a><br /></td></tr>
<tr class="separator:ae6768cf9c3747e5c66321da41749389c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1959210ec118f06d9a102bf2ba3e81a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a1959210ec118f06d9a102bf2ba3e81a6">future_queue</a> (const <a class="el" href="classcppext_1_1future__queue.html">future_queue</a> &amp;other)=default</td></tr>
<tr class="memdesc:a1959210ec118f06d9a102bf2ba3e81a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: After copying the object both *this and the other object will refer to the same queue.  <a href="classcppext_1_1future__queue.html#a1959210ec118f06d9a102bf2ba3e81a6">More...</a><br /></td></tr>
<tr class="separator:a1959210ec118f06d9a102bf2ba3e81a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c3a1d189e7694b8c2e8e97644ae4fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1future__queue.html">future_queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a09c3a1d189e7694b8c2e8e97644ae4fa">operator=</a> (const <a class="el" href="classcppext_1_1future__queue.html">future_queue</a> &amp;other)=default</td></tr>
<tr class="memdesc:a09c3a1d189e7694b8c2e8e97644ae4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator: After the assignment both *this and the other object will refer to the same queue.  <a href="classcppext_1_1future__queue.html#a09c3a1d189e7694b8c2e8e97644ae4fa">More...</a><br /></td></tr>
<tr class="separator:a09c3a1d189e7694b8c2e8e97644ae4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7e69daf329e7fe0b1ebdd7e02ca1b3"><td class="memTemplParams" colspan="2">template&lt;typename U  = T, typename std::enable_if&lt; std::is_same&lt; T, U &gt;::value &amp;&amp;!std::is_same&lt; U, void &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a2a7e69daf329e7fe0b1ebdd7e02ca1b3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a2a7e69daf329e7fe0b1ebdd7e02ca1b3">push</a> (U &amp;&amp;t)</td></tr>
<tr class="memdesc:a2a7e69daf329e7fe0b1ebdd7e02ca1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push object t to the queue.  <a href="classcppext_1_1future__queue.html#a2a7e69daf329e7fe0b1ebdd7e02ca1b3">More...</a><br /></td></tr>
<tr class="separator:a2a7e69daf329e7fe0b1ebdd7e02ca1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636379724afbf3ac5a41c90dd19ce551"><td class="memTemplParams" colspan="2">template&lt;typename U  = T, typename std::enable_if&lt;!std::is_same&lt; U, void &gt;::value &amp;&amp;std::is_copy_constructible&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a636379724afbf3ac5a41c90dd19ce551"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a636379724afbf3ac5a41c90dd19ce551">push</a> (const U &amp;t)</td></tr>
<tr class="memdesc:a636379724afbf3ac5a41c90dd19ce551"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classcppext_1_1future__queue.html#aeebd866575e603a2ac465c7f4f9733a7" title="This version of push() is valid only for T=void.">push()</a> is for non-void data types passed by Lvalue reference.  <a href="classcppext_1_1future__queue.html#a636379724afbf3ac5a41c90dd19ce551">More...</a><br /></td></tr>
<tr class="separator:a636379724afbf3ac5a41c90dd19ce551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebd866575e603a2ac465c7f4f9733a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#aeebd866575e603a2ac465c7f4f9733a7">push</a> (void)</td></tr>
<tr class="memdesc:aeebd866575e603a2ac465c7f4f9733a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <a class="el" href="classcppext_1_1future__queue.html#aeebd866575e603a2ac465c7f4f9733a7" title="This version of push() is valid only for T=void.">push()</a> is valid only for T=void.  <a href="classcppext_1_1future__queue.html#aeebd866575e603a2ac465c7f4f9733a7">More...</a><br /></td></tr>
<tr class="separator:aeebd866575e603a2ac465c7f4f9733a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7cd302b6098a040894735f75ae9005"><td class="memTemplParams" colspan="2">template&lt;typename U  = T, typename std::enable_if&lt; std::is_same&lt; T, U &gt;::value &amp;&amp;!std::is_same&lt; U, void &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a0f7cd302b6098a040894735f75ae9005"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a0f7cd302b6098a040894735f75ae9005">push_overwrite</a> (U &amp;&amp;t)</td></tr>
<tr class="memdesc:a0f7cd302b6098a040894735f75ae9005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push object t to the queue.  <a href="classcppext_1_1future__queue.html#a0f7cd302b6098a040894735f75ae9005">More...</a><br /></td></tr>
<tr class="separator:a0f7cd302b6098a040894735f75ae9005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3997fe6a676c35c101a6c33f5f18ec"><td class="memTemplParams" colspan="2">template&lt;typename U  = T, typename std::enable_if&lt;!std::is_same&lt; U, void &gt;::value &amp;&amp;std::is_copy_constructible&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:afc3997fe6a676c35c101a6c33f5f18ec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#afc3997fe6a676c35c101a6c33f5f18ec">push_overwrite</a> (const U &amp;t)</td></tr>
<tr class="memdesc:afc3997fe6a676c35c101a6c33f5f18ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classcppext_1_1future__queue.html#a628061e94d90758bb78c6343229640d0" title="This version of push_overwrite() is valid only for T=void.">push_overwrite()</a> is for non-void data types passed by Lvalue reference.  <a href="classcppext_1_1future__queue.html#afc3997fe6a676c35c101a6c33f5f18ec">More...</a><br /></td></tr>
<tr class="separator:afc3997fe6a676c35c101a6c33f5f18ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628061e94d90758bb78c6343229640d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a628061e94d90758bb78c6343229640d0">push_overwrite</a> ()</td></tr>
<tr class="memdesc:a628061e94d90758bb78c6343229640d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <a class="el" href="classcppext_1_1future__queue.html#a628061e94d90758bb78c6343229640d0" title="This version of push_overwrite() is valid only for T=void.">push_overwrite()</a> is valid only for T=void.  <a href="classcppext_1_1future__queue.html#a628061e94d90758bb78c6343229640d0">More...</a><br /></td></tr>
<tr class="separator:a628061e94d90758bb78c6343229640d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a0a7f4fbffbe0911990de5fd76dc75"><td class="memTemplParams" colspan="2">template&lt;typename U  = T, typename std::enable_if&lt; std::is_same&lt; T, U &gt;::value &amp;&amp;!std::is_same&lt; U, void &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a42a0a7f4fbffbe0911990de5fd76dc75"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a42a0a7f4fbffbe0911990de5fd76dc75">pop</a> (U &amp;t)</td></tr>
<tr class="memdesc:a42a0a7f4fbffbe0911990de5fd76dc75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop object off the queue and store it in t.  <a href="classcppext_1_1future__queue.html#a42a0a7f4fbffbe0911990de5fd76dc75">More...</a><br /></td></tr>
<tr class="separator:a42a0a7f4fbffbe0911990de5fd76dc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf26b7974d1b28a4f070bf35cd70031"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a3cf26b7974d1b28a4f070bf35cd70031">pop</a> ()</td></tr>
<tr class="memdesc:a3cf26b7974d1b28a4f070bf35cd70031"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classcppext_1_1future__queue.html#a3cf26b7974d1b28a4f070bf35cd70031" title="This pop() is for all data types (for non-void data types the value will be discarded)">pop()</a> is for all data types (for non-void data types the value will be discarded)  <a href="classcppext_1_1future__queue.html#a3cf26b7974d1b28a4f070bf35cd70031">More...</a><br /></td></tr>
<tr class="separator:a3cf26b7974d1b28a4f070bf35cd70031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773272befcc5a9b8deb29e5e966e1d68"><td class="memTemplParams" colspan="2">template&lt;typename U  = T, typename std::enable_if&lt; std::is_same&lt; T, U &gt;::value &amp;&amp;!std::is_same&lt; U, void &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a773272befcc5a9b8deb29e5e966e1d68"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a773272befcc5a9b8deb29e5e966e1d68">pop_wait</a> (U &amp;t)</td></tr>
<tr class="memdesc:a773272befcc5a9b8deb29e5e966e1d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop object off the queue and store it in t.  <a href="classcppext_1_1future__queue.html#a773272befcc5a9b8deb29e5e966e1d68">More...</a><br /></td></tr>
<tr class="separator:a773272befcc5a9b8deb29e5e966e1d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ba4fd52b05b1acb462ec5e6bb6b0c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a08ba4fd52b05b1acb462ec5e6bb6b0c7">pop_wait</a> ()</td></tr>
<tr class="memdesc:a08ba4fd52b05b1acb462ec5e6bb6b0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classcppext_1_1future__queue.html#a08ba4fd52b05b1acb462ec5e6bb6b0c7" title="This pop_wait() is for all data types (for non-void data types the value will be discarded)">pop_wait()</a> is for all data types (for non-void data types the value will be discarded)  <a href="classcppext_1_1future__queue.html#a08ba4fd52b05b1acb462ec5e6bb6b0c7">More...</a><br /></td></tr>
<tr class="separator:a08ba4fd52b05b1acb462ec5e6bb6b0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e89fcfd55f9a61fa32fec5bfb8173a"><td class="memTemplParams" colspan="2">template&lt;typename U  = T, typename std::enable_if&lt; std::is_same&lt; T, U &gt;::value &amp;&amp;!std::is_same&lt; U, void &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ac0e89fcfd55f9a61fa32fec5bfb8173a"><td class="memTemplItemLeft" align="right" valign="top">U &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#ac0e89fcfd55f9a61fa32fec5bfb8173a">front</a> ()</td></tr>
<tr class="memdesc:ac0e89fcfd55f9a61fa32fec5bfb8173a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the front element of the queue without removing it.  <a href="classcppext_1_1future__queue.html#ac0e89fcfd55f9a61fa32fec5bfb8173a">More...</a><br /></td></tr>
<tr class="separator:ac0e89fcfd55f9a61fa32fec5bfb8173a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cc3d83b0f2d1bc720053258b300ff4"><td class="memTemplParams" colspan="2">template&lt;typename U  = T, typename std::enable_if&lt; std::is_same&lt; T, U &gt;::value &amp;&amp;std::is_same&lt; U, void &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a04cc3d83b0f2d1bc720053258b300ff4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a04cc3d83b0f2d1bc720053258b300ff4">front</a> () const</td></tr>
<tr class="memdesc:a04cc3d83b0f2d1bc720053258b300ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classcppext_1_1future__queue.html#ac0e89fcfd55f9a61fa32fec5bfb8173a" title="Obtain the front element of the queue without removing it.">front()</a> is for void data types.  <a href="classcppext_1_1future__queue.html#a04cc3d83b0f2d1bc720053258b300ff4">More...</a><br /></td></tr>
<tr class="separator:a04cc3d83b0f2d1bc720053258b300ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403a9c26a8e8d422d6e6ff84cf424af1"><td class="memTemplParams" colspan="2">template&lt;typename T2 , typename FEATURES2  = MOVE_DATA, typename CALLABLE &gt; </td></tr>
<tr class="memitem:a403a9c26a8e8d422d6e6ff84cf424af1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1future__queue.html">future_queue</a>&lt; T2, FEATURES2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a403a9c26a8e8d422d6e6ff84cf424af1">then</a> (CALLABLE callable, std::launch policy=std::launch::async)</td></tr>
<tr class="memdesc:a403a9c26a8e8d422d6e6ff84cf424af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add continuation: Whenever there is a new element in the queue, process it with the callable and put the result into a new queue.  <a href="classcppext_1_1future__queue.html#a403a9c26a8e8d422d6e6ff84cf424af1">More...</a><br /></td></tr>
<tr class="separator:a403a9c26a8e8d422d6e6ff84cf424af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename FEATURES = MOVE_DATA&gt;<br />
class cppext::future_queue&lt; T, FEATURES &gt;</h3>

<p>A lockfree multi-producer single-consumer queue of a fixed length which the receiver can wait on in case the queue is empty. </p>
<p>This is similiar like using a lockfree queue of futures but has better performance. In addition the queue allows the sender to overwrite the last written element in case the queue is full. The receiver can also use the function <a class="el" href="namespacecppext.html#abdcebaea5eb63ebef6a57a35c83967c5" title="Implementations of non-member functions.">when_any()</a> to get notified when any of the given future_queues is not empty.</p>
<p>The template parameter T specifies the type of the user data stored in the queue. The optional second template parameter takes one of the feature tags. Currently two options are supported:</p>
<ul>
<li><a class="el" href="classcppext_1_1_m_o_v_e___d_a_t_a.html" title="Feature tag for future_queue: use std::move to store and retreive data to/from the queue.">MOVE_DATA</a> (default): Type T must have a move constructor. To place objects on the queue and to retrieve them from the queue, a move operation is performed.</li>
<li><a class="el" href="classcppext_1_1_s_w_a_p___d_a_t_a.html" title="Feature tag for future_queue: use std::swap to store and retreive data to/from the queue.">SWAP_DATA</a>: The function std::swap() must be overloaded for the type T. When placing objects on the queue, std::swap() is called to exchange the new object with the object currently on the internal queue buffer. This allows avoiding unnecessary memory allocations e.g. when storing std::vector on the queue, especially if all vectors have the same size.</li>
</ul>
<p>In both cases, T must be default constructible. Upon creation of the queue all internal buffers will be filled with default constructed elements. </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l00101">101</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3156a4f9a08e6cbe3f4761a014f9b7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3156a4f9a08e6cbe3f4761a014f9b7fc">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FEATURES  = MOVE_DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, FEATURES &gt;::<a class="el" href="classcppext_1_1future__queue.html#a3156a4f9a08e6cbe3f4761a014f9b7fc">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l00331">331</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3dfd4b44c2c7e0f26807ce06a5deb60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dfd4b44c2c7e0f26807ce06a5deb60b">&#9670;&nbsp;</a></span>future_queue() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FEATURES &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, FEATURES &gt;::<a class="el" href="classcppext_1_1future__queue.html">future_queue</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The length specifies how many objects the queue can contain at a time. </p>
<p>Implementation of <a class="el" href="classcppext_1_1future__queue.html" title="A lockfree multi-producer single-consumer queue of a fixed length which the receiver can wait on in c...">future_queue</a>.</p>
<p>Internally additional buffers will be allocated-&gt; All buffers are allocated upon construction, so no dynamic memory allocation is required later. </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l00955">955</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>

</div>
</div>
<a id="ae6768cf9c3747e5c66321da41749389c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6768cf9c3747e5c66321da41749389c">&#9670;&nbsp;</a></span>future_queue() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FEATURES &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, FEATURES &gt;::<a class="el" href="classcppext_1_1future__queue.html">future_queue</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default constructor creates only a place holder which can later be assigned with a properly constructed queue. </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l00958">958</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>

</div>
</div>
<a id="a1959210ec118f06d9a102bf2ba3e81a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1959210ec118f06d9a102bf2ba3e81a6">&#9670;&nbsp;</a></span>future_queue() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FEATURES  = MOVE_DATA&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, FEATURES &gt;::<a class="el" href="classcppext_1_1future__queue.html">future_queue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcppext_1_1future__queue.html">future_queue</a>&lt; T, FEATURES &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor: After copying the object both *this and the other object will refer to the same queue. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac0e89fcfd55f9a61fa32fec5bfb8173a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e89fcfd55f9a61fa32fec5bfb8173a">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FEATURES &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename std::enable_if&lt; std::is_same&lt; T, U &gt;::value &amp;&amp;!std::is_same&lt; U, void &gt;::value, int &gt;::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">U &amp; <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, FEATURES &gt;::front</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the front element of the queue without removing it. </p>
<p>Various implementations of <a class="el" href="classcppext_1_1future__queue.html#ac0e89fcfd55f9a61fa32fec5bfb8173a" title="Obtain the front element of the queue without removing it.">front()</a>.</p>
<p>It is mandatory to make sure that data is available in the queue by calling empty() before calling this function.</p>
<p>Note: No const variant exists, since empty() already changes the state of the queue internally (to acquire ownership on the front element, so <a class="el" href="classcppext_1_1future__queue.html#a628061e94d90758bb78c6343229640d0" title="This version of push_overwrite() is valid only for T=void.">push_overwrite()</a> can no longer overwrite it). Without a const variant of empty(), a const variant of <a class="el" href="classcppext_1_1future__queue.html#ac0e89fcfd55f9a61fa32fec5bfb8173a" title="Obtain the front element of the queue without removing it.">front()</a> would be unusable.</p>
<p>This <a class="el" href="classcppext_1_1future__queue.html#ac0e89fcfd55f9a61fa32fec5bfb8173a" title="Obtain the front element of the queue without removing it.">front()</a> is for non-void data types and a non-const *this </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l01191">1191</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classcppext_1_1future__queue_ac0e89fcfd55f9a61fa32fec5bfb8173a_icgraph.svg" width="410" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a04cc3d83b0f2d1bc720053258b300ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04cc3d83b0f2d1bc720053258b300ff4">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FEATURES &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename std::enable_if&lt; std::is_same&lt; T, U &gt;::value &amp;&amp;std::is_same&lt; U, void &gt;::value, int &gt;::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, FEATURES &gt;::front</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This <a class="el" href="classcppext_1_1future__queue.html#ac0e89fcfd55f9a61fa32fec5bfb8173a" title="Obtain the front element of the queue without removing it.">front()</a> is for void data types. </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l01200">1200</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>

</div>
</div>
<a id="a09c3a1d189e7694b8c2e8e97644ae4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c3a1d189e7694b8c2e8e97644ae4fa">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FEATURES  = MOVE_DATA&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppext_1_1future__queue.html">future_queue</a>&amp; <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, FEATURES &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcppext_1_1future__queue.html">future_queue</a>&lt; T, FEATURES &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator: After the assignment both *this and the other object will refer to the same queue. </p>

</div>
</div>
<a id="a3cf26b7974d1b28a4f070bf35cd70031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf26b7974d1b28a4f070bf35cd70031">&#9670;&nbsp;</a></span>pop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FEATURES &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, FEATURES &gt;::pop</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This <a class="el" href="classcppext_1_1future__queue.html#a3cf26b7974d1b28a4f070bf35cd70031" title="This pop() is for all data types (for non-void data types the value will be discarded)">pop()</a> is for all data types (for non-void data types the value will be discarded) </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l01118">1118</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>

</div>
</div>
<a id="a42a0a7f4fbffbe0911990de5fd76dc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a0a7f4fbffbe0911990de5fd76dc75">&#9670;&nbsp;</a></span>pop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FEATURES &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename std::enable_if&lt; std::is_same&lt; T, U &gt;::value &amp;&amp;!std::is_same&lt; U, void &gt;::value, int &gt;::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, FEATURES &gt;::pop </td>
          <td>(</td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop object off the queue and store it in t. </p>
<p>Various implementations of <a class="el" href="classcppext_1_1future__queue.html#a3cf26b7974d1b28a4f070bf35cd70031" title="This pop() is for all data types (for non-void data types the value will be discarded)">pop()</a>.</p>
<p>If no data is available, false is returned</p>
<p>This <a class="el" href="classcppext_1_1future__queue.html#a3cf26b7974d1b28a4f070bf35cd70031" title="This pop() is for all data types (for non-void data types the value will be discarded)">pop()</a> is for non-void data types </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l01090">1090</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>
<div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classcppext_1_1future__queue_a42a0a7f4fbffbe0911990de5fd76dc75_icgraph.svg" width="442" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a08ba4fd52b05b1acb462ec5e6bb6b0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ba4fd52b05b1acb462ec5e6bb6b0c7">&#9670;&nbsp;</a></span>pop_wait() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FEATURES &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, FEATURES &gt;::pop_wait</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This <a class="el" href="classcppext_1_1future__queue.html#a08ba4fd52b05b1acb462ec5e6bb6b0c7" title="This pop_wait() is for all data types (for non-void data types the value will be discarded)">pop_wait()</a> is for all data types (for non-void data types the value will be discarded) </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l01167">1167</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>

</div>
</div>
<a id="a773272befcc5a9b8deb29e5e966e1d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773272befcc5a9b8deb29e5e966e1d68">&#9670;&nbsp;</a></span>pop_wait() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FEATURES &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename std::enable_if&lt; std::is_same&lt; T, U &gt;::value &amp;&amp;!std::is_same&lt; U, void &gt;::value, int &gt;::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, FEATURES &gt;::pop_wait </td>
          <td>(</td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop object off the queue and store it in t. </p>
<p>This pop_void() is for non-void data types.</p>
<p>This function will block until data is available. </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l01142">1142</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>
<div id="dynsection-3" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-3-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-3-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-3-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classcppext_1_1future__queue_a773272befcc5a9b8deb29e5e966e1d68_icgraph.svg" width="410" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a636379724afbf3ac5a41c90dd19ce551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636379724afbf3ac5a41c90dd19ce551">&#9670;&nbsp;</a></span>push() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FEATURES &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename std::enable_if&lt;!std::is_same&lt; U, void &gt;::value &amp;&amp;std::is_copy_constructible&lt; T &gt;::value, int &gt;::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, FEATURES &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This <a class="el" href="classcppext_1_1future__queue.html#aeebd866575e603a2ac465c7f4f9733a7" title="This version of push() is valid only for T=void.">push()</a> is for non-void data types passed by Lvalue reference. </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l00992">992</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>

</div>
</div>
<a id="a2a7e69daf329e7fe0b1ebdd7e02ca1b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7e69daf329e7fe0b1ebdd7e02ca1b3">&#9670;&nbsp;</a></span>push() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FEATURES &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename std::enable_if&lt; std::is_same&lt; T, U &gt;::value &amp;&amp;!std::is_same&lt; U, void &gt;::value, int &gt;::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, FEATURES &gt;::push </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push object t to the queue. </p>
<p>Various implementations of <a class="el" href="classcppext_1_1future__queue.html#aeebd866575e603a2ac465c7f4f9733a7" title="This version of push() is valid only for T=void.">push()</a>.</p>
<p>Returns true if successful and false if queue is full.</p>
<p>This <a class="el" href="classcppext_1_1future__queue.html#aeebd866575e603a2ac465c7f4f9733a7" title="This version of push() is valid only for T=void.">push()</a> is for non-void data types passed by Rvalue reference </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l00966">966</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>
<div id="dynsection-4" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-4-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-4-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-4-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classcppext_1_1future__queue_a2a7e69daf329e7fe0b1ebdd7e02ca1b3_icgraph.svg" width="100%" height="476"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="aeebd866575e603a2ac465c7f4f9733a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebd866575e603a2ac465c7f4f9733a7">&#9670;&nbsp;</a></span>push() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FEATURES &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, FEATURES &gt;::push </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This version of <a class="el" href="classcppext_1_1future__queue.html#aeebd866575e603a2ac465c7f4f9733a7" title="This version of push() is valid only for T=void.">push()</a> is valid only for T=void. </p>
<p>This <a class="el" href="classcppext_1_1future__queue.html#aeebd866575e603a2ac465c7f4f9733a7" title="This version of push() is valid only for T=void.">push()</a> is for void data type. </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l01000">1000</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>

</div>
</div>
<a id="a628061e94d90758bb78c6343229640d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628061e94d90758bb78c6343229640d0">&#9670;&nbsp;</a></span>push_overwrite() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FEATURES  = MOVE_DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, FEATURES &gt;::push_overwrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This version of <a class="el" href="classcppext_1_1future__queue.html#a628061e94d90758bb78c6343229640d0" title="This version of push_overwrite() is valid only for T=void.">push_overwrite()</a> is valid only for T=void. </p>

</div>
</div>
<a id="afc3997fe6a676c35c101a6c33f5f18ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3997fe6a676c35c101a6c33f5f18ec">&#9670;&nbsp;</a></span>push_overwrite() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FEATURES &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename std::enable_if&lt;!std::is_same&lt; U, void &gt;::value &amp;&amp;std::is_copy_constructible&lt; T &gt;::value, int &gt;::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, FEATURES &gt;::push_overwrite </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This <a class="el" href="classcppext_1_1future__queue.html#a628061e94d90758bb78c6343229640d0" title="This version of push_overwrite() is valid only for T=void.">push_overwrite()</a> is for non-void data types passed by Lvalue reference. </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l01078">1078</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>

</div>
</div>
<a id="a0f7cd302b6098a040894735f75ae9005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7cd302b6098a040894735f75ae9005">&#9670;&nbsp;</a></span>push_overwrite() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FEATURES &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename std::enable_if&lt; std::is_same&lt; T, U &gt;::value &amp;&amp;!std::is_same&lt; U, void &gt;::value, int &gt;::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, FEATURES &gt;::push_overwrite </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push object t to the queue. </p>
<p>This <a class="el" href="classcppext_1_1future__queue.html#a628061e94d90758bb78c6343229640d0" title="This version of push_overwrite() is valid only for T=void.">push_overwrite()</a> is for non-void data types passed by Rvalue reference.</p>
<p>If the queue is full, the last element will be overwritten and false will be returned. If no data had to be overwritten, true is returned.</p>
<p>When using this function, the queue must have a length of at least 2.</p>
<p>Note: when used in a multi-producer context and false is returned, it is not defined whether other data or data written in this call to <a class="el" href="classcppext_1_1future__queue.html#a628061e94d90758bb78c6343229640d0" title="This version of push_overwrite() is valid only for T=void.">push_overwrite()</a> has been discarded. </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l01027">1027</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>
<div id="dynsection-5" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-5-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-5-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-5-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classcppext_1_1future__queue_a0f7cd302b6098a040894735f75ae9005_icgraph.svg" width="410" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a403a9c26a8e8d422d6e6ff84cf424af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403a9c26a8e8d422d6e6ff84cf424af1">&#9670;&nbsp;</a></span>then()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename FEATURES &gt; </div>
<div class="memtemplate">
template&lt;typename T2 , typename FEATURES2 , typename CALLABLE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppext_1_1future__queue.html">future_queue</a>&lt; T2, FEATURES2 &gt; <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, FEATURES &gt;::then </td>
          <td>(</td>
          <td class="paramtype">CALLABLE&#160;</td>
          <td class="paramname"><em>callable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::launch&#160;</td>
          <td class="paramname"><em>policy</em> = <code>std::launch::async</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add continuation: Whenever there is a new element in the queue, process it with the callable and put the result into a new queue. </p>
<p>The new queue will be returned by this function.</p>
<p>The signature of the callable must be "T2(T)", i.e. it has a single argument of the value type T of the queue <a class="el" href="classcppext_1_1future__queue.html#a403a9c26a8e8d422d6e6ff84cf424af1" title="Add continuation: Whenever there is a new element in the queue, process it with the callable and put ...">then()</a> is called on, and the return type matches the value type of the returned queue.</p>
<p>Two different launch policies can be selected:</p><ul>
<li>std::launch::async will launch a new thread and trigger data processing asynchronously in the background. Each value will be processed in the order they are pushed to the queue and in the same thread.</li>
<li>std::launch::deferred will defer data processing until the data is accessed on the resulting queue. Checking the presence through empty() is already counted an access. If the same data is accessed multiple times (e.g. by calling <a class="el" href="classcppext_1_1future__queue.html#ac0e89fcfd55f9a61fa32fec5bfb8173a" title="Obtain the front element of the queue without removing it.">front()</a> several times), the callable is only executed once. If neither std::launch::async (which is the default) nor std::launch::deferred is specified, the behaviour is undefined. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l01577">1577</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>
<div id="dynsection-6" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-6-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-6-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-6-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classcppext_1_1future__queue_a403a9c26a8e8d422d6e6ff84cf424af1_icgraph.svg" width="410" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/scratch/dragon/sources/ChimeraTK-cppext/include/<a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecppext.html">cppext</a></li><li class="navelem"><a class="el" href="classcppext_1_1future__queue.html">future_queue</a></li>
    <li class="footer">Generated on Mon Aug 26 2024 18:05:45 for ChimeraTK-cppext by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
