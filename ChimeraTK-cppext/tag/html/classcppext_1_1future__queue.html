<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ChimeraTK-cppext: cppext::future_queue&lt; T, FEATURES &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ChimeraTK_Logo_whitebg.png"/></td>
  <td id="projectalign">
   <div id="projectname">ChimeraTK-cppext<span id="projectnumber">&#160;01.05.02</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classcppext_1_1future__queue.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcppext_1_1future__queue-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">cppext::future_queue&lt; T, FEATURES &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A lockfree multi-producer single-consumer queue of a fixed length which the receiver can wait on in case the queue is empty.  
 <a href="classcppext_1_1future__queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for cppext::future_queue&lt; T, FEATURES &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classcppext_1_1future__queue__inherit__graph.svg" width="100%" height="482"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for cppext::future_queue&lt; T, FEATURES &gt;:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classcppext_1_1future__queue__coll__graph.svg" width="210" height="228"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3156a4f9a08e6cbe3f4761a014f9b7fc" id="r_a3156a4f9a08e6cbe3f4761a014f9b7fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">typedef</a> T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a3156a4f9a08e6cbe3f4761a014f9b7fc">value_type</a></td></tr>
<tr class="separator:a3156a4f9a08e6cbe3f4761a014f9b7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3dfd4b44c2c7e0f26807ce06a5deb60b" id="r_a3dfd4b44c2c7e0f26807ce06a5deb60b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a3dfd4b44c2c7e0f26807ce06a5deb60b">future_queue</a> (<a class="el" href="classcppext_1_1final__act.html">size_t</a> <a class="el" href="classcppext_1_1final__act.html">length</a>)</td></tr>
<tr class="memdesc:a3dfd4b44c2c7e0f26807ce06a5deb60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The length specifies how many objects the queue can contain at a time.  <br /></td></tr>
<tr class="separator:a3dfd4b44c2c7e0f26807ce06a5deb60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6768cf9c3747e5c66321da41749389c" id="r_ae6768cf9c3747e5c66321da41749389c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#ae6768cf9c3747e5c66321da41749389c">future_queue</a> ()</td></tr>
<tr class="memdesc:ae6768cf9c3747e5c66321da41749389c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor creates only a place holder which can later be assigned with a properly constructed queue.  <br /></td></tr>
<tr class="separator:ae6768cf9c3747e5c66321da41749389c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1959210ec118f06d9a102bf2ba3e81a6" id="r_a1959210ec118f06d9a102bf2ba3e81a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a1959210ec118f06d9a102bf2ba3e81a6">future_queue</a> (<a class="el" href="classcppext_1_1final__act.html">const</a> <a class="el" href="classcppext_1_1future__queue.html">future_queue</a> &amp;<a class="el" href="classcppext_1_1final__act.html">other</a>)=<a class="el" href="classcppext_1_1final__act.html">default</a></td></tr>
<tr class="memdesc:a1959210ec118f06d9a102bf2ba3e81a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: After copying the object both *this and the other object will refer to the same queue.  <br /></td></tr>
<tr class="separator:a1959210ec118f06d9a102bf2ba3e81a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f136c8313e912530b91a6fbe5b1c17f" id="r_a5f136c8313e912530b91a6fbe5b1c17f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1future__queue.html">future_queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a5f136c8313e912530b91a6fbe5b1c17f">operator=</a> (<a class="el" href="classcppext_1_1final__act.html">const</a> <a class="el" href="classcppext_1_1future__queue.html">future_queue</a> &amp;<a class="el" href="classcppext_1_1final__act.html">other</a>)=<a class="el" href="classcppext_1_1final__act.html">default</a></td></tr>
<tr class="memdesc:a5f136c8313e912530b91a6fbe5b1c17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator: After the assignment both *this and the other object will refer to the same queue.  <br /></td></tr>
<tr class="separator:a5f136c8313e912530b91a6fbe5b1c17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7e69daf329e7fe0b1ebdd7e02ca1b3" id="r_a2a7e69daf329e7fe0b1ebdd7e02ca1b3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">U</a>  = T, <a class="el" href="classcppext_1_1final__act.html">typename</a> std::enable_if&lt; std::is_same&lt; T, <a class="el" href="classcppext_1_1final__act.html">U</a> &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="classcppext_1_1final__act.html">U</a>, <a class="el" href="classcppext_1_1final__act.html">void</a> &gt;::value, <a class="el" href="classcppext_1_1final__act.html">int</a> &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a2a7e69daf329e7fe0b1ebdd7e02ca1b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a2a7e69daf329e7fe0b1ebdd7e02ca1b3">push</a> (<a class="el" href="classcppext_1_1final__act.html">U</a> &amp;&amp;<a class="el" href="classcppext_1_1final__act.html">t</a>)</td></tr>
<tr class="memdesc:a2a7e69daf329e7fe0b1ebdd7e02ca1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push object t to the queue.  <br /></td></tr>
<tr class="separator:a2a7e69daf329e7fe0b1ebdd7e02ca1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636379724afbf3ac5a41c90dd19ce551" id="r_a636379724afbf3ac5a41c90dd19ce551"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">U</a>  = T, <a class="el" href="classcppext_1_1final__act.html">typename</a> std::enable_if&lt;!std::is_same&lt; <a class="el" href="classcppext_1_1final__act.html">U</a>, <a class="el" href="classcppext_1_1final__act.html">void</a> &gt;::value &amp;&amp;std::is_copy_constructible&lt; T &gt;::value, <a class="el" href="classcppext_1_1final__act.html">int</a> &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a636379724afbf3ac5a41c90dd19ce551"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a636379724afbf3ac5a41c90dd19ce551">push</a> (<a class="el" href="classcppext_1_1final__act.html">const</a> <a class="el" href="classcppext_1_1final__act.html">U</a> &amp;<a class="el" href="classcppext_1_1final__act.html">t</a>)</td></tr>
<tr class="memdesc:a636379724afbf3ac5a41c90dd19ce551"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classcppext_1_1future__queue.html#aeebd866575e603a2ac465c7f4f9733a7" title="This version of push() is valid only for T=void.">push()</a> is for non-void data types passed by Lvalue reference.  <br /></td></tr>
<tr class="separator:a636379724afbf3ac5a41c90dd19ce551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebd866575e603a2ac465c7f4f9733a7" id="r_aeebd866575e603a2ac465c7f4f9733a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#aeebd866575e603a2ac465c7f4f9733a7">push</a> (<a class="el" href="classcppext_1_1final__act.html">void</a>)</td></tr>
<tr class="memdesc:aeebd866575e603a2ac465c7f4f9733a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <a class="el" href="classcppext_1_1future__queue.html#aeebd866575e603a2ac465c7f4f9733a7" title="This version of push() is valid only for T=void.">push()</a> is valid only for T=void.  <br /></td></tr>
<tr class="separator:aeebd866575e603a2ac465c7f4f9733a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7cd302b6098a040894735f75ae9005" id="r_a0f7cd302b6098a040894735f75ae9005"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">U</a>  = T, <a class="el" href="classcppext_1_1final__act.html">typename</a> std::enable_if&lt; std::is_same&lt; T, <a class="el" href="classcppext_1_1final__act.html">U</a> &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="classcppext_1_1final__act.html">U</a>, <a class="el" href="classcppext_1_1final__act.html">void</a> &gt;::value, <a class="el" href="classcppext_1_1final__act.html">int</a> &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a0f7cd302b6098a040894735f75ae9005"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a0f7cd302b6098a040894735f75ae9005">push_overwrite</a> (<a class="el" href="classcppext_1_1final__act.html">U</a> &amp;&amp;<a class="el" href="classcppext_1_1final__act.html">t</a>)</td></tr>
<tr class="memdesc:a0f7cd302b6098a040894735f75ae9005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push object t to the queue.  <br /></td></tr>
<tr class="separator:a0f7cd302b6098a040894735f75ae9005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3997fe6a676c35c101a6c33f5f18ec" id="r_afc3997fe6a676c35c101a6c33f5f18ec"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">U</a>  = T, <a class="el" href="classcppext_1_1final__act.html">typename</a> std::enable_if&lt;!std::is_same&lt; <a class="el" href="classcppext_1_1final__act.html">U</a>, <a class="el" href="classcppext_1_1final__act.html">void</a> &gt;::value &amp;&amp;std::is_copy_constructible&lt; T &gt;::value, <a class="el" href="classcppext_1_1final__act.html">int</a> &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:afc3997fe6a676c35c101a6c33f5f18ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#afc3997fe6a676c35c101a6c33f5f18ec">push_overwrite</a> (<a class="el" href="classcppext_1_1final__act.html">const</a> <a class="el" href="classcppext_1_1final__act.html">U</a> &amp;<a class="el" href="classcppext_1_1final__act.html">t</a>)</td></tr>
<tr class="memdesc:afc3997fe6a676c35c101a6c33f5f18ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classcppext_1_1future__queue.html#a628061e94d90758bb78c6343229640d0" title="This version of push_overwrite() is valid only for T=void.">push_overwrite()</a> is for non-void data types passed by Lvalue reference.  <br /></td></tr>
<tr class="separator:afc3997fe6a676c35c101a6c33f5f18ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628061e94d90758bb78c6343229640d0" id="r_a628061e94d90758bb78c6343229640d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a628061e94d90758bb78c6343229640d0">push_overwrite</a> ()</td></tr>
<tr class="memdesc:a628061e94d90758bb78c6343229640d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <a class="el" href="classcppext_1_1future__queue.html#a628061e94d90758bb78c6343229640d0" title="This version of push_overwrite() is valid only for T=void.">push_overwrite()</a> is valid only for T=void.  <br /></td></tr>
<tr class="separator:a628061e94d90758bb78c6343229640d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a0a7f4fbffbe0911990de5fd76dc75" id="r_a42a0a7f4fbffbe0911990de5fd76dc75"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">U</a>  = T, <a class="el" href="classcppext_1_1final__act.html">typename</a> std::enable_if&lt; std::is_same&lt; T, <a class="el" href="classcppext_1_1final__act.html">U</a> &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="classcppext_1_1final__act.html">U</a>, <a class="el" href="classcppext_1_1final__act.html">void</a> &gt;::value, <a class="el" href="classcppext_1_1final__act.html">int</a> &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a42a0a7f4fbffbe0911990de5fd76dc75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a42a0a7f4fbffbe0911990de5fd76dc75">pop</a> (<a class="el" href="classcppext_1_1final__act.html">U</a> &amp;<a class="el" href="classcppext_1_1final__act.html">t</a>)</td></tr>
<tr class="memdesc:a42a0a7f4fbffbe0911990de5fd76dc75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop object off the queue and store it in t.  <br /></td></tr>
<tr class="separator:a42a0a7f4fbffbe0911990de5fd76dc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf26b7974d1b28a4f070bf35cd70031" id="r_a3cf26b7974d1b28a4f070bf35cd70031"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a3cf26b7974d1b28a4f070bf35cd70031">pop</a> ()</td></tr>
<tr class="memdesc:a3cf26b7974d1b28a4f070bf35cd70031"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classcppext_1_1future__queue.html#a3cf26b7974d1b28a4f070bf35cd70031" title="This pop() is for all data types (for non-void data types the value will be discarded)">pop()</a> is for all data types (for non-void data types the value will be discarded)  <br /></td></tr>
<tr class="separator:a3cf26b7974d1b28a4f070bf35cd70031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773272befcc5a9b8deb29e5e966e1d68" id="r_a773272befcc5a9b8deb29e5e966e1d68"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">U</a>  = T, <a class="el" href="classcppext_1_1final__act.html">typename</a> std::enable_if&lt; std::is_same&lt; T, <a class="el" href="classcppext_1_1final__act.html">U</a> &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="classcppext_1_1final__act.html">U</a>, <a class="el" href="classcppext_1_1final__act.html">void</a> &gt;::value, <a class="el" href="classcppext_1_1final__act.html">int</a> &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a773272befcc5a9b8deb29e5e966e1d68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a773272befcc5a9b8deb29e5e966e1d68">pop_wait</a> (<a class="el" href="classcppext_1_1final__act.html">U</a> &amp;<a class="el" href="classcppext_1_1final__act.html">t</a>)</td></tr>
<tr class="memdesc:a773272befcc5a9b8deb29e5e966e1d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop object off the queue and store it in t.  <br /></td></tr>
<tr class="separator:a773272befcc5a9b8deb29e5e966e1d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ba4fd52b05b1acb462ec5e6bb6b0c7" id="r_a08ba4fd52b05b1acb462ec5e6bb6b0c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a08ba4fd52b05b1acb462ec5e6bb6b0c7">pop_wait</a> ()</td></tr>
<tr class="memdesc:a08ba4fd52b05b1acb462ec5e6bb6b0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classcppext_1_1future__queue.html#a08ba4fd52b05b1acb462ec5e6bb6b0c7" title="This pop_wait() is for all data types (for non-void data types the value will be discarded)">pop_wait()</a> is for all data types (for non-void data types the value will be discarded)  <br /></td></tr>
<tr class="separator:a08ba4fd52b05b1acb462ec5e6bb6b0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e89fcfd55f9a61fa32fec5bfb8173a" id="r_ac0e89fcfd55f9a61fa32fec5bfb8173a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">U</a>  = T, <a class="el" href="classcppext_1_1final__act.html">typename</a> std::enable_if&lt; std::is_same&lt; T, <a class="el" href="classcppext_1_1final__act.html">U</a> &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="classcppext_1_1final__act.html">U</a>, <a class="el" href="classcppext_1_1final__act.html">void</a> &gt;::value, <a class="el" href="classcppext_1_1final__act.html">int</a> &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ac0e89fcfd55f9a61fa32fec5bfb8173a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">U</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#ac0e89fcfd55f9a61fa32fec5bfb8173a">front</a> ()</td></tr>
<tr class="memdesc:ac0e89fcfd55f9a61fa32fec5bfb8173a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the front element of the queue without removing it.  <br /></td></tr>
<tr class="separator:ac0e89fcfd55f9a61fa32fec5bfb8173a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cc3d83b0f2d1bc720053258b300ff4" id="r_a04cc3d83b0f2d1bc720053258b300ff4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">U</a>  = T, <a class="el" href="classcppext_1_1final__act.html">typename</a> std::enable_if&lt; std::is_same&lt; T, <a class="el" href="classcppext_1_1final__act.html">U</a> &gt;::value &amp;&amp;std::is_same&lt; <a class="el" href="classcppext_1_1final__act.html">U</a>, <a class="el" href="classcppext_1_1final__act.html">void</a> &gt;::value, <a class="el" href="classcppext_1_1final__act.html">int</a> &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a04cc3d83b0f2d1bc720053258b300ff4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a04cc3d83b0f2d1bc720053258b300ff4">front</a> () <a class="el" href="classcppext_1_1final__act.html">const</a></td></tr>
<tr class="memdesc:a04cc3d83b0f2d1bc720053258b300ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classcppext_1_1future__queue.html#ac0e89fcfd55f9a61fa32fec5bfb8173a" title="Obtain the front element of the queue without removing it.">front()</a> is for void data types.  <br /></td></tr>
<tr class="separator:a04cc3d83b0f2d1bc720053258b300ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403a9c26a8e8d422d6e6ff84cf424af1" id="r_a403a9c26a8e8d422d6e6ff84cf424af1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">T2</a> , <a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">FEATURES2</a>  = MOVE_DATA, <a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">CALLABLE</a> &gt; </td></tr>
<tr class="memitem:a403a9c26a8e8d422d6e6ff84cf424af1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1future__queue.html">future_queue</a>&lt; <a class="el" href="classcppext_1_1final__act.html">T2</a>, <a class="el" href="classcppext_1_1final__act.html">FEATURES2</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue.html#a403a9c26a8e8d422d6e6ff84cf424af1">then</a> (<a class="el" href="classcppext_1_1final__act.html">CALLABLE</a> callable, std::launch <a class="el" href="classcppext_1_1final__act.html">policy</a>=std::launch::async)</td></tr>
<tr class="memdesc:a403a9c26a8e8d422d6e6ff84cf424af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add continuation: Whenever there is a new element in the queue, process it with the callable and put the result into a new queue.  <br /></td></tr>
<tr class="separator:a403a9c26a8e8d422d6e6ff84cf424af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcppext_1_1future__queue__base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcppext_1_1future__queue__base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcppext_1_1future__queue__base.html">cppext::future_queue_base</a></td></tr>
<tr class="memitem:aaf9c6f4304d480aa561e3ef1213aa868 inherit pub_methods_classcppext_1_1future__queue__base" id="r_aaf9c6f4304d480aa561e3ef1213aa868"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue__base.html#aaf9c6f4304d480aa561e3ef1213aa868">write_available</a> () <a class="el" href="classcppext_1_1final__act.html">const</a></td></tr>
<tr class="memdesc:aaf9c6f4304d480aa561e3ef1213aa868 inherit pub_methods_classcppext_1_1future__queue__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of push operations which can be performed before the queue is full.  <br /></td></tr>
<tr class="separator:aaf9c6f4304d480aa561e3ef1213aa868 inherit pub_methods_classcppext_1_1future__queue__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06d6186b625d12bcb13b35b762c522b inherit pub_methods_classcppext_1_1future__queue__base" id="r_ae06d6186b625d12bcb13b35b762c522b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue__base.html#ae06d6186b625d12bcb13b35b762c522b">read_available</a> () <a class="el" href="classcppext_1_1final__act.html">const</a></td></tr>
<tr class="memdesc:ae06d6186b625d12bcb13b35b762c522b inherit pub_methods_classcppext_1_1future__queue__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of pop operations which can be performed before the queue is empty.  <br /></td></tr>
<tr class="separator:ae06d6186b625d12bcb13b35b762c522b inherit pub_methods_classcppext_1_1future__queue__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7665c6142d0f73abd148781a5af8c598 inherit pub_methods_classcppext_1_1future__queue__base" id="r_a7665c6142d0f73abd148781a5af8c598"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue__base.html#a7665c6142d0f73abd148781a5af8c598">push_exception</a> (std::exception_ptr exception)</td></tr>
<tr class="memdesc:a7665c6142d0f73abd148781a5af8c598 inherit pub_methods_classcppext_1_1future__queue__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an exception pointer (inplace of a value) into the queue.  <br /></td></tr>
<tr class="separator:a7665c6142d0f73abd148781a5af8c598 inherit pub_methods_classcppext_1_1future__queue__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f61c2a8529b1c9f7961189aaf9d611 inherit pub_methods_classcppext_1_1future__queue__base" id="r_ae8f61c2a8529b1c9f7961189aaf9d611"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue__base.html#ae8f61c2a8529b1c9f7961189aaf9d611">push_overwrite_exception</a> (std::exception_ptr exception)</td></tr>
<tr class="memdesc:ae8f61c2a8529b1c9f7961189aaf9d611 inherit pub_methods_classcppext_1_1future__queue__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classcppext_1_1future__queue__base.html#a7665c6142d0f73abd148781a5af8c598" title="Push an exception pointer (inplace of a value) into the queue.">push_exception()</a> but overwrite the last pushed value in case the queue is full.  <br /></td></tr>
<tr class="separator:ae8f61c2a8529b1c9f7961189aaf9d611 inherit pub_methods_classcppext_1_1future__queue__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41a07d65910c604d5b2e248fedfde05 inherit pub_methods_classcppext_1_1future__queue__base" id="r_ab41a07d65910c604d5b2e248fedfde05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue__base.html#ab41a07d65910c604d5b2e248fedfde05">empty</a> ()</td></tr>
<tr class="memdesc:ab41a07d65910c604d5b2e248fedfde05 inherit pub_methods_classcppext_1_1future__queue__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there is currently no data on the queue.  <br /></td></tr>
<tr class="separator:ab41a07d65910c604d5b2e248fedfde05 inherit pub_methods_classcppext_1_1future__queue__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3214b9a16f4c2c5006393234afaaf7 inherit pub_methods_classcppext_1_1future__queue__base" id="r_a6f3214b9a16f4c2c5006393234afaaf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue__base.html#a6f3214b9a16f4c2c5006393234afaaf7">wait</a> ()</td></tr>
<tr class="memdesc:a6f3214b9a16f4c2c5006393234afaaf7 inherit pub_methods_classcppext_1_1future__queue__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the queue is not empty.  <br /></td></tr>
<tr class="separator:a6f3214b9a16f4c2c5006393234afaaf7 inherit pub_methods_classcppext_1_1future__queue__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af804285e4a73ec24294bf304ab5cb186 inherit pub_methods_classcppext_1_1future__queue__base" id="r_af804285e4a73ec24294bf304ab5cb186"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue__base.html#af804285e4a73ec24294bf304ab5cb186">size</a> () <a class="el" href="classcppext_1_1final__act.html">const</a></td></tr>
<tr class="memdesc:af804285e4a73ec24294bf304ab5cb186 inherit pub_methods_classcppext_1_1future__queue__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">return length of the queue  <br /></td></tr>
<tr class="separator:af804285e4a73ec24294bf304ab5cb186 inherit pub_methods_classcppext_1_1future__queue__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ffc82bddc0f8eb15ef2839d9548285 inherit pub_methods_classcppext_1_1future__queue__base" id="r_a26ffc82bddc0f8eb15ef2839d9548285"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue__base.html#a26ffc82bddc0f8eb15ef2839d9548285">operator==</a> (<a class="el" href="classcppext_1_1final__act.html">const</a> <a class="el" href="classcppext_1_1future__queue__base.html">future_queue_base</a> &amp;<a class="el" href="classcppext_1_1final__act.html">other</a>) <a class="el" href="classcppext_1_1final__act.html">const</a></td></tr>
<tr class="memdesc:a26ffc82bddc0f8eb15ef2839d9548285 inherit pub_methods_classcppext_1_1future__queue__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether two <a class="el" href="classcppext_1_1future__queue.html" title="A lockfree multi-producer single-consumer queue of a fixed length which the receiver can wait on in c...">future_queue</a> instances use the same shared state, i.e.  <br /></td></tr>
<tr class="separator:a26ffc82bddc0f8eb15ef2839d9548285 inherit pub_methods_classcppext_1_1future__queue__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec6ab8d8762758e20d79900b6ceb9a7 inherit pub_methods_classcppext_1_1future__queue__base" id="r_a5ec6ab8d8762758e20d79900b6ceb9a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue__base.html#a5ec6ab8d8762758e20d79900b6ceb9a7">operator!=</a> (<a class="el" href="classcppext_1_1final__act.html">const</a> <a class="el" href="classcppext_1_1future__queue__base.html">future_queue_base</a> &amp;<a class="el" href="classcppext_1_1final__act.html">other</a>) <a class="el" href="classcppext_1_1final__act.html">const</a></td></tr>
<tr class="separator:a5ec6ab8d8762758e20d79900b6ceb9a7 inherit pub_methods_classcppext_1_1future__queue__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classcppext_1_1future__queue__base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcppext_1_1future__queue__base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcppext_1_1future__queue__base.html">cppext::future_queue_base</a></td></tr>
<tr class="memitem:a48663b9633da99b998ecac58d825fae3 inherit pro_methods_classcppext_1_1future__queue__base" id="r_a48663b9633da99b998ecac58d825fae3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue__base.html#a48663b9633da99b998ecac58d825fae3">future_queue_base</a> (<a class="el" href="classcppext_1_1final__act.html">const</a> <a class="el" href="structcppext_1_1detail_1_1shared__state__ptr.html">detail::shared_state_ptr</a> &amp;<a class="el" href="classcppext_1_1final__act.html">d_ptr_</a>)</td></tr>
<tr class="separator:a48663b9633da99b998ecac58d825fae3 inherit pro_methods_classcppext_1_1future__queue__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772a106598b8dac8cff740d6883e0ae1 inherit pro_methods_classcppext_1_1future__queue__base" id="r_a772a106598b8dac8cff740d6883e0ae1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue__base.html#a772a106598b8dac8cff740d6883e0ae1">future_queue_base</a> ()</td></tr>
<tr class="separator:a772a106598b8dac8cff740d6883e0ae1 inherit pro_methods_classcppext_1_1future__queue__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7be12e8ccba68aada6c3a3a236295e inherit pro_methods_classcppext_1_1future__queue__base" id="r_aea7be12e8ccba68aada6c3a3a236295e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue__base.html#aea7be12e8ccba68aada6c3a3a236295e">obtain_write_slot</a> (<a class="el" href="classcppext_1_1final__act.html">size_t</a> &amp;<a class="el" href="classcppext_1_1final__act.html">index</a>)</td></tr>
<tr class="memdesc:aea7be12e8ccba68aada6c3a3a236295e inherit pro_methods_classcppext_1_1future__queue__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">reserve next available write slot.  <br /></td></tr>
<tr class="separator:aea7be12e8ccba68aada6c3a3a236295e inherit pro_methods_classcppext_1_1future__queue__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8384de814d10e0c85eba712debe838fb inherit pro_methods_classcppext_1_1future__queue__base" id="r_a8384de814d10e0c85eba712debe838fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue__base.html#a8384de814d10e0c85eba712debe838fb">update_read_index_max</a> ()</td></tr>
<tr class="memdesc:a8384de814d10e0c85eba712debe838fb inherit pro_methods_classcppext_1_1future__queue__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">update readIndexMax after a write operation was completed  <br /></td></tr>
<tr class="separator:a8384de814d10e0c85eba712debe838fb inherit pro_methods_classcppext_1_1future__queue__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb255621822eef8ed3016f2d1c97a27 inherit pro_methods_classcppext_1_1future__queue__base" id="r_a4fb255621822eef8ed3016f2d1c97a27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue__base.html#a4fb255621822eef8ed3016f2d1c97a27">setNotificationQueue</a> (<a class="el" href="classcppext_1_1future__queue.html">future_queue</a>&lt; <a class="el" href="classcppext_1_1final__act.html">size_t</a>, <a class="el" href="classcppext_1_1_m_o_v_e___d_a_t_a.html">MOVE_DATA</a> &gt; &amp;<a class="el" href="classcppext_1_1final__act.html">notificationQueue</a>, <a class="el" href="classcppext_1_1final__act.html">size_t</a> <a class="el" href="classcppext_1_1final__act.html">indexToSend</a>)</td></tr>
<tr class="memdesc:a4fb255621822eef8ed3016f2d1c97a27 inherit pro_methods_classcppext_1_1future__queue__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the notification queue in the shared state, as done in when_any.  <br /></td></tr>
<tr class="separator:a4fb255621822eef8ed3016f2d1c97a27 inherit pro_methods_classcppext_1_1future__queue__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d76b81d37decef5db4d75d1f92c143 inherit pro_methods_classcppext_1_1future__queue__base" id="r_a99d76b81d37decef5db4d75d1f92c143"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcppext_1_1detail_1_1shared__state__base.html">cppext::detail::shared_state_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue__base.html#a99d76b81d37decef5db4d75d1f92c143">get_notification_queue</a> ()</td></tr>
<tr class="memdesc:a99d76b81d37decef5db4d75d1f92c143 inherit pro_methods_classcppext_1_1future__queue__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically return the notification queue or increment the "previous data" counter (for wait_any).  <br /></td></tr>
<tr class="separator:a99d76b81d37decef5db4d75d1f92c143 inherit pro_methods_classcppext_1_1future__queue__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec3af69b7e9b7b06ebd15d49ba0cba2 inherit pro_methods_classcppext_1_1future__queue__base" id="r_a8ec3af69b7e9b7b06ebd15d49ba0cba2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue__base.html#a8ec3af69b7e9b7b06ebd15d49ba0cba2">send_notification</a> (<a class="el" href="structcppext_1_1detail_1_1shared__state__base.html">cppext::detail::shared_state_base</a> *<a class="el" href="classcppext_1_1final__act.html">notification_queue</a>)</td></tr>
<tr class="memdesc:a8ec3af69b7e9b7b06ebd15d49ba0cba2 inherit pro_methods_classcppext_1_1future__queue__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send notification to notification queue (if not nullptr).  <br /></td></tr>
<tr class="separator:a8ec3af69b7e9b7b06ebd15d49ba0cba2 inherit pro_methods_classcppext_1_1future__queue__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af74d2f04c2cd6822ea49241fd8dd9d inherit pro_methods_classcppext_1_1future__queue__base" id="r_a5af74d2f04c2cd6822ea49241fd8dd9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppext_1_1final__act.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue__base.html#a5af74d2f04c2cd6822ea49241fd8dd9d">decrement_previous_data_counter</a> ()</td></tr>
<tr class="memdesc:a5af74d2f04c2cd6822ea49241fd8dd9d inherit pro_methods_classcppext_1_1future__queue__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the "previous data" counter used in <a class="el" href="classcppext_1_1future__queue__base.html#af4f0dc7e7ba5c93f9e8d912a6903851c" title="Implementations of non-member functions.">when_any()</a>.  <br /></td></tr>
<tr class="separator:a5af74d2f04c2cd6822ea49241fd8dd9d inherit pro_methods_classcppext_1_1future__queue__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classcppext_1_1future__queue__base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcppext_1_1future__queue__base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcppext_1_1future__queue__base.html">cppext::future_queue_base</a></td></tr>
<tr class="memitem:a1b79f4b30b728fb2d6e165b5cbec46cb inherit pro_attribs_classcppext_1_1future__queue__base" id="r_a1b79f4b30b728fb2d6e165b5cbec46cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcppext_1_1detail_1_1shared__state__ptr.html">detail::shared_state_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppext_1_1future__queue__base.html#a1b79f4b30b728fb2d6e165b5cbec46cb">d</a></td></tr>
<tr class="memdesc:a1b79f4b30b728fb2d6e165b5cbec46cb inherit pro_attribs_classcppext_1_1future__queue__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to data used to allow sharing the queue (create multiple copies which all refer to the same queue).  <br /></td></tr>
<tr class="separator:a1b79f4b30b728fb2d6e165b5cbec46cb inherit pro_attribs_classcppext_1_1future__queue__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> T, <a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> = MOVE_DATA&gt;<br />
class cppext::future_queue&lt; T, FEATURES &gt;</div><p>A lockfree multi-producer single-consumer queue of a fixed length which the receiver can wait on in case the queue is empty. </p>
<p>This is similiar like using a lockfree queue of futures but has better performance. In addition the queue allows the sender to overwrite the last written element in case the queue is full. The receiver can also use the function <a class="el" href="classcppext_1_1future__queue__base.html#af4f0dc7e7ba5c93f9e8d912a6903851c" title="Implementations of non-member functions.">when_any()</a> to get notified when any of the given future_queues is not empty.</p>
<p>The template parameter T specifies the type of the user data stored in the queue. The optional second template parameter takes one of the feature tags. Currently two options are supported:</p>
<ul>
<li><a class="el" href="classcppext_1_1_m_o_v_e___d_a_t_a.html" title="Feature tag for future_queue: use std::move to store and retreive data to/from the queue.">MOVE_DATA</a> (default): Type T must have a move constructor. To place objects on the queue and to retrieve them from the queue, a move operation is performed.</li>
<li><a class="el" href="classcppext_1_1_s_w_a_p___d_a_t_a.html" title="Feature tag for future_queue: use std::swap to store and retreive data to/from the queue.">SWAP_DATA</a>: The function std::swap() must be overloaded for the type T. When placing objects on the queue, std::swap() is called to exchange the new object with the object currently on the internal queue buffer. This allows avoiding unnecessary memory allocations e.g. when storing std::vector on the queue, especially if all vectors have the same size.</li>
</ul>
<p>In both cases, T must be default constructible. Upon creation of the queue all internal buffers will be filled with default constructed elements. </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l00228">228</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3156a4f9a08e6cbe3f4761a014f9b7fc" name="a3156a4f9a08e6cbe3f4761a014f9b7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3156a4f9a08e6cbe3f4761a014f9b7fc">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> T , <a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">FEATURES</a>  = MOVE_DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppext_1_1final__act.html">typedef</a> T <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l00331">331</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3dfd4b44c2c7e0f26807ce06a5deb60b" name="a3dfd4b44c2c7e0f26807ce06a5deb60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dfd4b44c2c7e0f26807ce06a5deb60b">&#9670;&#160;</a></span>future_queue() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> T , <a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt;::future_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppext_1_1final__act.html">size_t</a>&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The length specifies how many objects the queue can contain at a time. </p>
<p>Implementation of <a class="el" href="classcppext_1_1future__queue.html" title="A lockfree multi-producer single-consumer queue of a fixed length which the receiver can wait on in c...">future_queue</a>.</p>
<p>Internally additional buffers will be allocated-&gt; All buffers are allocated upon construction, so no dynamic memory allocation is required later. </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l00955">955</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>

</div>
</div>
<a id="ae6768cf9c3747e5c66321da41749389c" name="ae6768cf9c3747e5c66321da41749389c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6768cf9c3747e5c66321da41749389c">&#9670;&#160;</a></span>future_queue() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> T , <a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt;::future_queue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default constructor creates only a place holder which can later be assigned with a properly constructed queue. </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l00958">958</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>

</div>
</div>
<a id="a1959210ec118f06d9a102bf2ba3e81a6" name="a1959210ec118f06d9a102bf2ba3e81a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1959210ec118f06d9a102bf2ba3e81a6">&#9670;&#160;</a></span>future_queue() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> T , <a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">FEATURES</a>  = MOVE_DATA&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt;::future_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppext_1_1final__act.html">const</a> <a class="el" href="classcppext_1_1future__queue.html">future_queue</a>&lt; T, <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor: After copying the object both *this and the other object will refer to the same queue. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac0e89fcfd55f9a61fa32fec5bfb8173a" name="ac0e89fcfd55f9a61fa32fec5bfb8173a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e89fcfd55f9a61fa32fec5bfb8173a">&#9670;&#160;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> T , <a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">U</a> , <a class="el" href="classcppext_1_1final__act.html">typename</a> std::enable_if&lt; std::is_same&lt; T, <a class="el" href="classcppext_1_1final__act.html">U</a> &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="classcppext_1_1final__act.html">U</a>, <a class="el" href="classcppext_1_1final__act.html">void</a> &gt;::value, <a class="el" href="classcppext_1_1final__act.html">int</a> &gt;::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppext_1_1final__act.html">U</a> &amp; <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the front element of the queue without removing it. </p>
<p>Various implementations of <a class="el" href="classcppext_1_1future__queue.html#ac0e89fcfd55f9a61fa32fec5bfb8173a" title="Obtain the front element of the queue without removing it.">front()</a>.</p>
<p>It is mandatory to make sure that data is available in the queue by calling <a class="el" href="classcppext_1_1future__queue__base.html#ab41a07d65910c604d5b2e248fedfde05" title="Check if there is currently no data on the queue.">empty()</a> before calling this function.</p>
<p>Note: No const variant exists, since <a class="el" href="classcppext_1_1future__queue__base.html#ab41a07d65910c604d5b2e248fedfde05" title="Check if there is currently no data on the queue.">empty()</a> already changes the state of the queue internally (to acquire ownership on the front element, so <a class="el" href="classcppext_1_1future__queue.html#a628061e94d90758bb78c6343229640d0" title="This version of push_overwrite() is valid only for T=void.">push_overwrite()</a> can no longer overwrite it). Without a const variant of <a class="el" href="classcppext_1_1future__queue__base.html#ab41a07d65910c604d5b2e248fedfde05" title="Check if there is currently no data on the queue.">empty()</a>, a const variant of <a class="el" href="classcppext_1_1future__queue.html#ac0e89fcfd55f9a61fa32fec5bfb8173a" title="Obtain the front element of the queue without removing it.">front()</a> would be unusable.</p>
<p>This <a class="el" href="classcppext_1_1future__queue.html#ac0e89fcfd55f9a61fa32fec5bfb8173a" title="Obtain the front element of the queue without removing it.">front()</a> is for non-void data types and a non-const *this </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l01191">1191</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>
<div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classcppext_1_1future__queue_ac0e89fcfd55f9a61fa32fec5bfb8173a_cgraph.svg" width="592" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div id="dynsection-3" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-3-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-3-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-3-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classcppext_1_1future__queue_ac0e89fcfd55f9a61fa32fec5bfb8173a_icgraph.svg" width="468" height="432"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a04cc3d83b0f2d1bc720053258b300ff4" name="a04cc3d83b0f2d1bc720053258b300ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04cc3d83b0f2d1bc720053258b300ff4">&#9670;&#160;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> T , <a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">U</a> , <a class="el" href="classcppext_1_1final__act.html">typename</a> std::enable_if&lt; std::is_same&lt; T, <a class="el" href="classcppext_1_1final__act.html">U</a> &gt;::value &amp;&amp;std::is_same&lt; <a class="el" href="classcppext_1_1final__act.html">U</a>, <a class="el" href="classcppext_1_1final__act.html">void</a> &gt;::value, <a class="el" href="classcppext_1_1final__act.html">int</a> &gt;::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppext_1_1final__act.html">void</a> <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This <a class="el" href="classcppext_1_1future__queue.html#ac0e89fcfd55f9a61fa32fec5bfb8173a" title="Obtain the front element of the queue without removing it.">front()</a> is for void data types. </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l01200">1200</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>

</div>
</div>
<a id="a5f136c8313e912530b91a6fbe5b1c17f" name="a5f136c8313e912530b91a6fbe5b1c17f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f136c8313e912530b91a6fbe5b1c17f">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> T , <a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">FEATURES</a>  = MOVE_DATA&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppext_1_1future__queue.html">future_queue</a> &amp; <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppext_1_1final__act.html">const</a> <a class="el" href="classcppext_1_1future__queue.html">future_queue</a>&lt; T, <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator: After the assignment both *this and the other object will refer to the same queue. </p>

</div>
</div>
<a id="a3cf26b7974d1b28a4f070bf35cd70031" name="a3cf26b7974d1b28a4f070bf35cd70031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf26b7974d1b28a4f070bf35cd70031">&#9670;&#160;</a></span>pop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> T , <a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppext_1_1final__act.html">bool</a> <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt;::pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This <a class="el" href="classcppext_1_1future__queue.html#a3cf26b7974d1b28a4f070bf35cd70031" title="This pop() is for all data types (for non-void data types the value will be discarded)">pop()</a> is for all data types (for non-void data types the value will be discarded) </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l01118">1118</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>

</div>
</div>
<a id="a42a0a7f4fbffbe0911990de5fd76dc75" name="a42a0a7f4fbffbe0911990de5fd76dc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a0a7f4fbffbe0911990de5fd76dc75">&#9670;&#160;</a></span>pop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> T , <a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">U</a> , <a class="el" href="classcppext_1_1final__act.html">typename</a> std::enable_if&lt; std::is_same&lt; T, <a class="el" href="classcppext_1_1final__act.html">U</a> &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="classcppext_1_1final__act.html">U</a>, <a class="el" href="classcppext_1_1final__act.html">void</a> &gt;::value, <a class="el" href="classcppext_1_1final__act.html">int</a> &gt;::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppext_1_1final__act.html">bool</a> <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt;::pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppext_1_1final__act.html">U</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop object off the queue and store it in t. </p>
<p>Various implementations of <a class="el" href="classcppext_1_1future__queue.html#a3cf26b7974d1b28a4f070bf35cd70031" title="This pop() is for all data types (for non-void data types the value will be discarded)">pop()</a>.</p>
<p>If no data is available, false is returned</p>
<p>This <a class="el" href="classcppext_1_1future__queue.html#a3cf26b7974d1b28a4f070bf35cd70031" title="This pop() is for all data types (for non-void data types the value will be discarded)">pop()</a> is for non-void data types </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l01090">1090</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>
<div id="dynsection-4" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-4-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-4-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-4-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classcppext_1_1future__queue_a42a0a7f4fbffbe0911990de5fd76dc75_cgraph.svg" width="399" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div id="dynsection-5" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-5-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-5-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-5-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classcppext_1_1future__queue_a42a0a7f4fbffbe0911990de5fd76dc75_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="a08ba4fd52b05b1acb462ec5e6bb6b0c7" name="a08ba4fd52b05b1acb462ec5e6bb6b0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ba4fd52b05b1acb462ec5e6bb6b0c7">&#9670;&#160;</a></span>pop_wait() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> T , <a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppext_1_1final__act.html">void</a> <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt;::pop_wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This <a class="el" href="classcppext_1_1future__queue.html#a08ba4fd52b05b1acb462ec5e6bb6b0c7" title="This pop_wait() is for all data types (for non-void data types the value will be discarded)">pop_wait()</a> is for all data types (for non-void data types the value will be discarded) </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l01167">1167</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>

</div>
</div>
<a id="a773272befcc5a9b8deb29e5e966e1d68" name="a773272befcc5a9b8deb29e5e966e1d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773272befcc5a9b8deb29e5e966e1d68">&#9670;&#160;</a></span>pop_wait() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> T , <a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">U</a> , <a class="el" href="classcppext_1_1final__act.html">typename</a> std::enable_if&lt; std::is_same&lt; T, <a class="el" href="classcppext_1_1final__act.html">U</a> &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="classcppext_1_1final__act.html">U</a>, <a class="el" href="classcppext_1_1final__act.html">void</a> &gt;::value, <a class="el" href="classcppext_1_1final__act.html">int</a> &gt;::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppext_1_1final__act.html">void</a> <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt;::pop_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppext_1_1final__act.html">U</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop object off the queue and store it in t. </p>
<p>This pop_void() is for non-void data types.</p>
<p>This function will block until data is available. </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l01142">1142</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>
<div id="dynsection-6" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-6-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-6-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-6-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classcppext_1_1future__queue_a773272befcc5a9b8deb29e5e966e1d68_cgraph.svg" width="367" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div id="dynsection-7" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-7-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-7-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-7-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classcppext_1_1future__queue_a773272befcc5a9b8deb29e5e966e1d68_icgraph.svg" width="466" height="332"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a636379724afbf3ac5a41c90dd19ce551" name="a636379724afbf3ac5a41c90dd19ce551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636379724afbf3ac5a41c90dd19ce551">&#9670;&#160;</a></span>push() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> T , <a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">U</a> , <a class="el" href="classcppext_1_1final__act.html">typename</a> std::enable_if&lt;!std::is_same&lt; <a class="el" href="classcppext_1_1final__act.html">U</a>, <a class="el" href="classcppext_1_1final__act.html">void</a> &gt;::value &amp;&amp;std::is_copy_constructible&lt; T &gt;::value, <a class="el" href="classcppext_1_1final__act.html">int</a> &gt;::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppext_1_1final__act.html">bool</a> <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt;::push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppext_1_1final__act.html">const</a> <a class="el" href="classcppext_1_1final__act.html">U</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This <a class="el" href="classcppext_1_1future__queue.html#aeebd866575e603a2ac465c7f4f9733a7" title="This version of push() is valid only for T=void.">push()</a> is for non-void data types passed by Lvalue reference. </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l00992">992</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>

</div>
</div>
<a id="a2a7e69daf329e7fe0b1ebdd7e02ca1b3" name="a2a7e69daf329e7fe0b1ebdd7e02ca1b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7e69daf329e7fe0b1ebdd7e02ca1b3">&#9670;&#160;</a></span>push() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> T , <a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">U</a> , <a class="el" href="classcppext_1_1final__act.html">typename</a> std::enable_if&lt; std::is_same&lt; T, <a class="el" href="classcppext_1_1final__act.html">U</a> &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="classcppext_1_1final__act.html">U</a>, <a class="el" href="classcppext_1_1final__act.html">void</a> &gt;::value, <a class="el" href="classcppext_1_1final__act.html">int</a> &gt;::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppext_1_1final__act.html">bool</a> <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt;::push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppext_1_1final__act.html">U</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push object t to the queue. </p>
<p>Various implementations of <a class="el" href="classcppext_1_1future__queue.html#aeebd866575e603a2ac465c7f4f9733a7" title="This version of push() is valid only for T=void.">push()</a>.</p>
<p>Returns true if successful and false if queue is full.</p>
<p>This <a class="el" href="classcppext_1_1future__queue.html#aeebd866575e603a2ac465c7f4f9733a7" title="This version of push() is valid only for T=void.">push()</a> is for non-void data types passed by Rvalue reference </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l00966">966</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>
<div id="dynsection-8" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-8-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-8-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-8-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classcppext_1_1future__queue_a2a7e69daf329e7fe0b1ebdd7e02ca1b3_cgraph.svg" width="367" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div id="dynsection-9" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-9-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-9-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-9-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classcppext_1_1future__queue_a2a7e69daf329e7fe0b1ebdd7e02ca1b3_icgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="aeebd866575e603a2ac465c7f4f9733a7" name="aeebd866575e603a2ac465c7f4f9733a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebd866575e603a2ac465c7f4f9733a7">&#9670;&#160;</a></span>push() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> T , <a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppext_1_1final__act.html">bool</a> <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt;::push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppext_1_1final__act.html">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This version of <a class="el" href="classcppext_1_1future__queue.html#aeebd866575e603a2ac465c7f4f9733a7" title="This version of push() is valid only for T=void.">push()</a> is valid only for T=void. </p>
<p>This <a class="el" href="classcppext_1_1future__queue.html#aeebd866575e603a2ac465c7f4f9733a7" title="This version of push() is valid only for T=void.">push()</a> is for void data type. </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l01000">1000</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>

</div>
</div>
<a id="a628061e94d90758bb78c6343229640d0" name="a628061e94d90758bb78c6343229640d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628061e94d90758bb78c6343229640d0">&#9670;&#160;</a></span>push_overwrite() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> T , <a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">FEATURES</a>  = MOVE_DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppext_1_1final__act.html">bool</a> <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt;::push_overwrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This version of <a class="el" href="classcppext_1_1future__queue.html#a628061e94d90758bb78c6343229640d0" title="This version of push_overwrite() is valid only for T=void.">push_overwrite()</a> is valid only for T=void. </p>

</div>
</div>
<a id="afc3997fe6a676c35c101a6c33f5f18ec" name="afc3997fe6a676c35c101a6c33f5f18ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3997fe6a676c35c101a6c33f5f18ec">&#9670;&#160;</a></span>push_overwrite() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> T , <a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">U</a> , <a class="el" href="classcppext_1_1final__act.html">typename</a> std::enable_if&lt;!std::is_same&lt; <a class="el" href="classcppext_1_1final__act.html">U</a>, <a class="el" href="classcppext_1_1final__act.html">void</a> &gt;::value &amp;&amp;std::is_copy_constructible&lt; T &gt;::value, <a class="el" href="classcppext_1_1final__act.html">int</a> &gt;::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppext_1_1final__act.html">bool</a> <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt;::push_overwrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppext_1_1final__act.html">const</a> <a class="el" href="classcppext_1_1final__act.html">U</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This <a class="el" href="classcppext_1_1future__queue.html#a628061e94d90758bb78c6343229640d0" title="This version of push_overwrite() is valid only for T=void.">push_overwrite()</a> is for non-void data types passed by Lvalue reference. </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l01078">1078</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>

</div>
</div>
<a id="a0f7cd302b6098a040894735f75ae9005" name="a0f7cd302b6098a040894735f75ae9005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7cd302b6098a040894735f75ae9005">&#9670;&#160;</a></span>push_overwrite() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> T , <a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">U</a> , <a class="el" href="classcppext_1_1final__act.html">typename</a> std::enable_if&lt; std::is_same&lt; T, <a class="el" href="classcppext_1_1final__act.html">U</a> &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="classcppext_1_1final__act.html">U</a>, <a class="el" href="classcppext_1_1final__act.html">void</a> &gt;::value, <a class="el" href="classcppext_1_1final__act.html">int</a> &gt;::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppext_1_1final__act.html">bool</a> <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt;::push_overwrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppext_1_1final__act.html">U</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Push object t to the queue. </p>
<p>This <a class="el" href="classcppext_1_1future__queue.html#a628061e94d90758bb78c6343229640d0" title="This version of push_overwrite() is valid only for T=void.">push_overwrite()</a> is for non-void data types passed by Rvalue reference.</p>
<p>If the queue is full, the last element will be overwritten and false will be returned. If no data had to be overwritten, true is returned.</p>
<p>When using this function, the queue must have a length of at least 2.</p>
<p>Note: when used in a multi-producer context and false is returned, it is not defined whether other data or data written in this call to <a class="el" href="classcppext_1_1future__queue.html#a628061e94d90758bb78c6343229640d0" title="This version of push_overwrite() is valid only for T=void.">push_overwrite()</a> has been discarded. </p>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l01027">1027</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>
<div id="dynsection-10" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-10-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-10-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-10-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classcppext_1_1future__queue_a0f7cd302b6098a040894735f75ae9005_cgraph.svg" width="367" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a403a9c26a8e8d422d6e6ff84cf424af1" name="a403a9c26a8e8d422d6e6ff84cf424af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403a9c26a8e8d422d6e6ff84cf424af1">&#9670;&#160;</a></span>then()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> T , <a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">T2</a> , <a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">FEATURES2</a> , <a class="el" href="classcppext_1_1final__act.html">typename</a> <a class="el" href="classcppext_1_1final__act.html">CALLABLE</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppext_1_1future__queue.html">future_queue</a>&lt; <a class="el" href="classcppext_1_1final__act.html">T2</a>, <a class="el" href="classcppext_1_1final__act.html">FEATURES2</a> &gt; <a class="el" href="classcppext_1_1future__queue.html">cppext::future_queue</a>&lt; T, <a class="el" href="classcppext_1_1final__act.html">FEATURES</a> &gt;::then </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppext_1_1final__act.html">CALLABLE</a>&#160;</td>
          <td class="paramname"><em>callable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::launch&#160;</td>
          <td class="paramname"><em>policy</em> = <code>std::launch::async</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add continuation: Whenever there is a new element in the queue, process it with the callable and put the result into a new queue. </p>
<p>The new queue will be returned by this function.</p>
<p>The signature of the callable must be "T2(T)", i.e. it has a single argument of the value type T of the queue <a class="el" href="classcppext_1_1future__queue.html#a403a9c26a8e8d422d6e6ff84cf424af1" title="Add continuation: Whenever there is a new element in the queue, process it with the callable and put ...">then()</a> is called on, and the return type matches the value type of the returned queue.</p>
<p>Two different launch policies can be selected:</p><ul>
<li>std::launch::async will launch a new thread and trigger data processing asynchronously in the background. Each value will be processed in the order they are pushed to the queue and in the same thread.</li>
<li>std::launch::deferred will defer data processing until the data is accessed on the resulting queue. Checking the presence through <a class="el" href="classcppext_1_1future__queue__base.html#ab41a07d65910c604d5b2e248fedfde05" title="Check if there is currently no data on the queue.">empty()</a> is already counted an access. If the same data is accessed multiple times (e.g. by calling <a class="el" href="classcppext_1_1future__queue.html#ac0e89fcfd55f9a61fa32fec5bfb8173a" title="Obtain the front element of the queue without removing it.">front()</a> several times), the callable is only executed once. If neither std::launch::async (which is the default) nor std::launch::deferred is specified, the behaviour is undefined. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="future__queue_8hpp_source.html#l01577">1577</a> of file <a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a>.</p>
<div id="dynsection-11" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-11-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-11-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-11-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classcppext_1_1future__queue_a403a9c26a8e8d422d6e6ff84cf424af1_cgraph.svg" width="431" height="210"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/scratch/dragon/sources/ChimeraTK-cppext/include/<a class="el" href="future__queue_8hpp_source.html">future_queue.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecppext.html">cppext</a></li><li class="navelem"><a class="el" href="classcppext_1_1future__queue.html">future_queue</a></li>
    <li class="footer">Generated on Sat May 3 2025 18:04:16 for ChimeraTK-cppext by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
