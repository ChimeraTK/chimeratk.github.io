<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ChimeraTK-ApplicationCore: Conceptual overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ChimeraTK_Logo_whitebg.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ChimeraTK-ApplicationCore
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('conceptual_overview.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Conceptual overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Introduction">Introduction</a></li>
<li class="level1"><a href="#conceptualOverview_ApplicationModule">Application module</a><ul><li class="level2"><a href="#conceptualOverview_ProcessVariable">Process variables and accessors</a></li>
<li class="level2"><a href="#conceptualOverview_ProcessVariable_accessMode">Push and poll transfer modes</a></li>
</ul>
</li>
<li class="level1"><a href="#conceptualOverview_Application">The Application</a></li>
<li class="level1"><a href="#conceptualOverview_PVConnections">Connections between ApplicationModules</a></li>
<li class="level1"><a href="#conceptualOverview_ModuleGroup">Module groups</a></li>
<li class="level1"><a href="#conceptualOverview_DeviceModule">Device modules</a></li>
<li class="level1"><a href="#conceptualOverview_PeriodicTriggers">Periodic Triggers</a></li>
<li class="level1"><a href="#conceptualOverview_ConfigReader">Configuration constants</a></li>
<li class="level1"><a href="#conceptualOverview_VariableGroup">Variable groups</a></li>
<li class="level1"><a href="#conceptualOverview_ApplicationModel">The Application model</a></li>
<li class="level1"><a href="#conceptualOverview_FanOuts">Fanouts</a></li>
<li class="level1"><a href="#conceptualOverview_InitialValues">Initial values</a></li>
<li class="level1"><a href="#conceptualOverview_ExceptionHandling">Device exception handling</a></li>
<li class="level1"><a href="#conceptualOverview_DataValidity">Data validity propagation</a></li>
<li class="level1"><a href="#conceptualOverview_ControlSystemIntegration">Control system integration</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="Introduction"></a>
Introduction</h1>
<p>ApplicationCore is a framework for writing control system applications. The framework is designed to allow a simple construction of event driven data processing chains, while keeping each element of the chain self-contained and abstracted from implementation details in other elements.</p>
<p>Applications written with ApplicationCore are hence divided into modules. A module can have any number of input and output process variables. All program logic is implemented inside modules. Each module should implement ideally one single, self-contained functionality.</p>
<p>One fundamental principle of ApplicationCore is that the inputs and outputs of modules can be connected to arbitrary targets like device registers, control system variables, other modules or even multiple different targets at the same time. The program logic inside the modules does not depend on how each variable is connected, so the author of the module does not need to keep this in mind while coding.</p>
<p>There are the following types of modules:</p>
<ul>
<li>Application module: Any application logic must go into this type of modules, so this type of modules is the main ingredience to the application.</li>
<li>Variable group: Can be used to organise variables hierarchically within application modules.</li>
<li>Module group: Can be used to organise ApplicationModules hierarchically within the application.</li>
<li>Device module: Represents a device (in the sense of <a class="el" href="namespace_chimera_t_k.html" title="InvalidityTracer application module.">ChimeraTK</a> DeviceAccess) or a part of such, and allows to connect device registers to other modules.</li>
<li>The application: All other modules must be directly or indirectly instantiated by the application, which is basically the top-most module group.</li>
</ul>
<h1><a class="anchor" id="conceptualOverview_ApplicationModule"></a>
Application module</h1>
<p>An application module represents a relatively small task of the total application, e.g. one particular computation. The task will be executed in its own thread, so it is well separated from the rest of the application. Ideally, each module should be somewhat self-contained and independent of other modules, and only ApplicationCore process variables should be used for communication with other parts of the application.</p>
<p>An application module is a class deriving from <a class="el" href="class_chimera_t_k_1_1_application_module.html">ChimeraTK::ApplicationModule</a>, e.g.: </p><div class="fragment"><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="keyword">class </span><a class="code" href="class_controller.html">Controller</a> : <span class="keyword">public</span> <a class="code" href="class_chimera_t_k_1_1_application_module.html">ctk::ApplicationModule</a> {</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;  <span class="keyword">using</span> <a class="code" href="class_chimera_t_k_1_1_application_module.html#a527d36175aa9b3126553b6a2a8933e38">ctk::ApplicationModule::ApplicationModule</a>;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160; </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  <a class="code" href="struct_chimera_t_k_1_1_scalar_poll_input.html">ctk::ScalarPollInput&lt;float&gt;</a> temperatureSetpoint{</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;      <span class="keyword">this</span>, <span class="stringliteral">&quot;temperatureSetpoint&quot;</span>, <span class="stringliteral">&quot;degC&quot;</span>, <span class="stringliteral">&quot;Setpoint for the temperature controller&quot;</span>};</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;  <a class="code" href="struct_chimera_t_k_1_1_scalar_push_input.html">ctk::ScalarPushInput&lt;float&gt;</a> temperatureReadback{</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;      <span class="keyword">this</span>, <span class="stringliteral">&quot;temperatureReadback&quot;</span>, <span class="stringliteral">&quot;degC&quot;</span>, <span class="stringliteral">&quot;Actual temperature used as controller input&quot;</span>};</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;  <a class="code" href="struct_chimera_t_k_1_1_scalar_output.html">ctk::ScalarOutput&lt;float&gt;</a> heatingCurrent{<span class="keyword">this</span>, <span class="stringliteral">&quot;heatingCurrent&quot;</span>, <span class="stringliteral">&quot;mA&quot;</span>, <span class="stringliteral">&quot;Actuator output of the controller&quot;</span>};</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160; </div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;  <span class="keywordtype">void</span> mainLoop() <span class="keyword">override</span>;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;};</div>
<div class="ttc" id="aclass_chimera_t_k_1_1_application_module_html"><div class="ttname"><a href="class_chimera_t_k_1_1_application_module.html">ChimeraTK::ApplicationModule</a></div><div class="ttdef"><b>Definition:</b> <a href="_application_module_8h_source.html#l00023">ApplicationModule.h:23</a></div></div>
<div class="ttc" id="aclass_chimera_t_k_1_1_application_module_html_a527d36175aa9b3126553b6a2a8933e38"><div class="ttname"><a href="class_chimera_t_k_1_1_application_module.html#a527d36175aa9b3126553b6a2a8933e38">ChimeraTK::ApplicationModule::ApplicationModule</a></div><div class="ttdeci">ApplicationModule()=default</div><div class="ttdoc">Default constructor: Allows late initialisation of modules (e.g.</div></div>
<div class="ttc" id="aclass_controller_html"><div class="ttname"><a href="class_controller.html">Controller</a></div><div class="ttdoc">[Snippet: Class Definition]</div><div class="ttdef"><b>Definition:</b> <a href="_controller_8h_source.html#l00019">Controller.h:19</a></div></div>
<div class="ttc" id="astruct_chimera_t_k_1_1_scalar_output_html"><div class="ttname"><a href="struct_chimera_t_k_1_1_scalar_output.html">ChimeraTK::ScalarOutput&lt; float &gt;</a></div></div>
<div class="ttc" id="astruct_chimera_t_k_1_1_scalar_poll_input_html"><div class="ttname"><a href="struct_chimera_t_k_1_1_scalar_poll_input.html">ChimeraTK::ScalarPollInput&lt; float &gt;</a></div></div>
<div class="ttc" id="astruct_chimera_t_k_1_1_scalar_push_input_html"><div class="ttname"><a href="struct_chimera_t_k_1_1_scalar_push_input.html">ChimeraTK::ScalarPushInput&lt; float &gt;</a></div></div>
</div><!-- fragment --><p>In this small example, two input and one output process variable is defined. For each variable, the name, engineering unit and a short description needs to be provided. One of the two inputs is push-type, which means it can be used to trigger the computations when the variable changes. The other input is poll-type so just the curent value can be obtained. This will be explained in more details in <a class="el" href="conceptual_overview.html#conceptualOverview_ProcessVariable">the next section</a>.</p>
<p>The code processing the data needs to go into the implementation of the ApplicationModule::mainLoop() function implementation. In our small example, we implement a simple, fixed-gain proportional controller like this: </p><div class="fragment"><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="keywordtype">void</span> Controller::mainLoop() {</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">float</span> gain = 100.0F;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;  <span class="keywordflow">while</span>(<span class="keyword">true</span>) {</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    heatingCurrent = gain * (temperatureSetpoint - temperatureReadback);</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    <a class="code" href="class_chimera_t_k_1_1_module.html#ac91e2a2ce01c0616d57050b229cde5bb">writeAll</a>(); <span class="comment">// writes any outputs</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160; </div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    <a class="code" href="class_chimera_t_k_1_1_module.html#a20b7d1b8fdd6fb84dcfea23e36a27b1a">readAll</a>(); <span class="comment">// waits until temperatureReadback updated, then reads temperatureSetpoint</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;  }</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;}</div>
<div class="ttc" id="aclass_chimera_t_k_1_1_module_html_a20b7d1b8fdd6fb84dcfea23e36a27b1a"><div class="ttname"><a href="class_chimera_t_k_1_1_module.html#a20b7d1b8fdd6fb84dcfea23e36a27b1a">ChimeraTK::Module::readAll</a></div><div class="ttdeci">void readAll(bool includeReturnChannels=false)</div><div class="ttdoc">Read all readable variables in the group.</div><div class="ttdef"><b>Definition:</b> <a href="_module_8cc_source.html#l00071">Module.cc:71</a></div></div>
<div class="ttc" id="aclass_chimera_t_k_1_1_module_html_ac91e2a2ce01c0616d57050b229cde5bb"><div class="ttname"><a href="class_chimera_t_k_1_1_module.html#ac91e2a2ce01c0616d57050b229cde5bb">ChimeraTK::Module::writeAll</a></div><div class="ttdeci">void writeAll(bool includeReturnChannels=false)</div><div class="ttdoc">Just call write() on all writable variables in the group.</div><div class="ttdef"><b>Definition:</b> <a href="_module_8cc_source.html#l00156">Module.cc:156</a></div></div>
</div><!-- fragment --><p> The ApplicationModule::mainLoop() function litteraly needs to contain a loop, which runs for the lifetime of the application. Any preparations which need to be executed once at application start should go before the start of the loop.</p>
<p>During shutdown of the application, any read/write operation on the process variables will function as an interruption point, so the programmer does not have to take care of this.</p>
<p>At the start of the mainLoop function, all inputs will already contain proper initial values (without executing a read operation). Every module is expected to pass on result based on these initial values to their outputs, hence the order inside the infinite loop is usually: compute, write, read. See Section <a class="el" href="conceptual_overview.html#conceptualOverview_InitialValues">Initial values</a> for more details.</p>
<h2><a class="anchor" id="conceptualOverview_ProcessVariable"></a>
Process variables and accessors</h2>
<p>What has been previously in this document referred to as a process variable is actually only the accessor to it. Accessors are already known from <a class="el" href="namespace_chimera_t_k.html" title="InvalidityTracer application module.">ChimeraTK</a> DeviceAccess, where they allow reading and writing from/to device registers. In ApplicationCore the concept is extended to a higher abstraction level, since accessors cannot only target device registers.</p>
<p>The process variable is a logical concept in ApplicationCore. Each process variable is exposed to the control system, can be accessed by an accessor of one ore more ApplicationModules and can be connected to a device.</p>
<p>A process variable has a data source, which is called the feeder, and one or more so-called consumers. The feeder as well as any consumer can each be either a device register, a control system variable (e.g. from an operator panel) or an output accessor of an application module. Process variables have a name, a type, a physical unit, a description and of course a value.</p>
<h2><a class="anchor" id="conceptualOverview_ProcessVariable_accessMode"></a>
Push and poll transfer modes</h2>
<p>Accessors can have either push or poll type transfer modes. In push mode, the feeder initiates the data tranfers, while in poll mode the consumer does. In both cases, a consuming application module still needs to execute a read operation before the value becomes visible in the application buffer of the accessor.</p>
<p>Push inputs of application modules are accessors with the ChimeraTK::AccessMode::wait_for_new_data flag (see DeviceAccess documentation) and hence have a blocking ChimeraTK::TransferElement::read() operation which waits until data is available for reading. They also support ChimeraTK::TransferElement::readNonBlocking() and ChimeraTK::TransferElement::readLatest(), and can be used inside a ChimeraTK::ReadAnyGroup.</p>
<p>Poll inputs do not have the AccessMode::wait_for_new_data flag, and hence all read operations do not block and do not inform about changed values.</p>
<p>Outputs of application modules are always push-type, so they can be connected to either a push-type or a poll-type input. Device registers do not neccessarily support the AccessMode::wait_for_new_data flag, in which case a direct connetion with only poll-type readers is possible. To circumvent this, a trigger can be used which determines the point in time when a new value shall be polled, see the <a class="el" href="conceptual_overview.html#conceptualOverview_DeviceModule">Section Device modules</a> for more details. Control system variables are always push-type, which means device registers often cannot be connected directly to the control system without a trigger.</p>
<h1><a class="anchor" id="conceptualOverview_Application"></a>
The Application</h1>
<p>Previously, ApplicationModules have been introduced which contain the actual application code. All ApplicationModules must be combined to form the actual application. This is done by creating an application class deriving from <a class="el" href="class_chimera_t_k_1_1_application.html">ChimeraTK::Application</a>:</p>
<div class="fragment"><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="keyword">class </span><a class="code" href="class_example_app.html">ExampleApp</a> : <span class="keyword">public</span> <a class="code" href="class_chimera_t_k_1_1_application.html">ctk::Application</a> {</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160; <span class="keyword">public</span>:</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  <span class="keyword">using</span> <a class="code" href="class_chimera_t_k_1_1_module_group.html#a23f25bcc02a0e94c2f5a4188496b04d0">ctk::Application::Application</a>;</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  <a class="code" href="class_example_app.html#a496387672eeb08223ce159afc3ef7443">~ExampleApp</a>() <span class="keyword">override</span>;</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160; </div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160; <span class="keyword">private</span>:</div>
<div class="ttc" id="aclass_chimera_t_k_1_1_application_html"><div class="ttname"><a href="class_chimera_t_k_1_1_application.html">ChimeraTK::Application</a></div><div class="ttdef"><b>Definition:</b> <a href="_application_8h_source.html#l00043">Application.h:43</a></div></div>
<div class="ttc" id="aclass_chimera_t_k_1_1_module_group_html_a23f25bcc02a0e94c2f5a4188496b04d0"><div class="ttname"><a href="class_chimera_t_k_1_1_module_group.html#a23f25bcc02a0e94c2f5a4188496b04d0">ChimeraTK::ModuleGroup::Application</a></div><div class="ttdeci">friend class Application</div><div class="ttdef"><b>Definition:</b> <a href="_module_group_8h_source.html#l00064">ModuleGroup.h:64</a></div></div>
<div class="ttc" id="aclass_example_app_html"><div class="ttname"><a href="class_example_app.html">ExampleApp</a></div><div class="ttdoc">[Snippet: Class Definition Start]</div><div class="ttdef"><b>Definition:</b> <a href="_example_app_8h_source.html#l00027">ExampleApp.h:27</a></div></div>
<div class="ttc" id="aclass_example_app_html_a496387672eeb08223ce159afc3ef7443"><div class="ttname"><a href="class_example_app.html#a496387672eeb08223ce159afc3ef7443">ExampleApp::~ExampleApp</a></div><div class="ttdeci">~ExampleApp() override</div><div class="ttdoc">[Snippet: Destructor]</div><div class="ttdef"><b>Definition:</b> <a href="_example_app_8cc_source.html#l00018">ExampleApp.cc:18</a></div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <span class="comment">// Instantiate the temperature controller module</span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    <a class="code" href="class_controller.html">Controller</a> controller{<span class="keyword">this</span>, <span class="stringliteral">&quot;Controller&quot;</span>, <span class="stringliteral">&quot;The temperature controller&quot;</span>};</div>
</div><!-- fragment --><div class="fragment"><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;};</div>
</div><!-- fragment --><p> Every Application needs to call the Application::shutdown() function in its destructor:</p>
<div class="fragment"><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<a class="code" href="class_example_app.html#a496387672eeb08223ce159afc3ef7443">ExampleApp::~ExampleApp</a>() {</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  <a class="code" href="class_chimera_t_k_1_1_application.html#acd050c59340807685052276fb053787a">shutdown</a>();</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;}</div>
<div class="ttc" id="aclass_chimera_t_k_1_1_application_html_acd050c59340807685052276fb053787a"><div class="ttname"><a href="class_chimera_t_k_1_1_application.html#acd050c59340807685052276fb053787a">ChimeraTK::Application::shutdown</a></div><div class="ttdeci">void shutdown() override</div><div class="ttdoc">This will remove the global pointer to the instance and allows creating another instance afterwards.</div><div class="ttdef"><b>Definition:</b> <a href="_application_8cc_source.html#l00189">Application.cc:189</a></div></div>
</div><!-- fragment --><p> In this first example, only the <a class="el" href="class_controller.html" title="[Snippet: Class Definition]">Controller</a> ApplicationModule from above is instantiated in the application. This alone would be quite useless, since the module would not be connected to any device.</p>
<p>All variables from the <a class="el" href="class_controller.html" title="[Snippet: Class Definition]">Controller</a> module will be published to the control system. The names of the variables are hierarchical using the slash as a hierarchy separator, similar to a Unix file system, with the modules being the equivalent of directories. This example would hence publish the following variables:</p>
<ul>
<li>/Controller/temperatureSetpoint</li>
<li>/Controller/temperatureReadback</li>
<li>/Controller/heatingCurrent</li>
</ul>
<h1><a class="anchor" id="conceptualOverview_PVConnections"></a>
Connections between ApplicationModules</h1>
<p>To add more functionality to the application, additional ApplicationModules need to be created. In this example, we add a module that averages the output of the <a class="el" href="class_controller.html" title="[Snippet: Class Definition]">Controller</a> module:</p>
<div class="fragment"><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="keyword">class </span><a class="code" href="class_average_current.html">AverageCurrent</a> : <span class="keyword">public</span> <a class="code" href="class_chimera_t_k_1_1_application_module.html">ctk::ApplicationModule</a> {</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;  <span class="keyword">using</span> <a class="code" href="class_chimera_t_k_1_1_application_module.html#a527d36175aa9b3126553b6a2a8933e38">ctk::ApplicationModule::ApplicationModule</a>;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160; </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  <span class="comment">// Take the heaterCurrent from the Controller module as an input</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment"></span>  <a class="code" href="struct_chimera_t_k_1_1_scalar_push_input.html">ctk::ScalarPushInput&lt;float&gt;</a> current{<span class="keyword">this</span>, <span class="stringliteral">&quot;../Controller/heatingCurrent&quot;</span>, <span class="stringliteral">&quot;mA&quot;</span>, <span class="stringliteral">&quot;Actuator output of the controller&quot;</span>};</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160; </div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  <a class="code" href="struct_chimera_t_k_1_1_scalar_output.html">ctk::ScalarOutput&lt;float&gt;</a> currentAveraged{<span class="keyword">this</span>, <span class="stringliteral">&quot;heatingCurrentAveraged&quot;</span>, <span class="stringliteral">&quot;mA&quot;</span>, <span class="stringliteral">&quot;Averaged heating current&quot;</span>};</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160; </div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  <span class="keywordtype">void</span> mainLoop() <span class="keyword">override</span>;</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;};</div>
<div class="ttc" id="aclass_average_current_html"><div class="ttname"><a href="class_average_current.html">AverageCurrent</a></div><div class="ttdoc">[Snippet: Class Definition]</div><div class="ttdef"><b>Definition:</b> <a href="_average_current_8h_source.html#l00019">AverageCurrent.h:19</a></div></div>
</div><!-- fragment --><p> Note that the name of the input is the relative path to the output of the controller module: "../Controller/heatingCurrent" directs the framework to look one level up starting from the <a class="el" href="class_average_current.html" title="[Snippet: Class Definition]">AverageCurrent</a> module (which is in this case the <a class="el" href="class_example_app.html" title="[Snippet: Class Definition Start]">ExampleApp</a> application instance) and then decent down into a module called "Controller" to find the variable "heatingCurrent". This will cause the framework to pass on any value written by the <a class="el" href="class_controller.html" title="[Snippet: Class Definition]">Controller</a> module to the <a class="el" href="class_average_current.html" title="[Snippet: Class Definition]">AverageCurrent</a> module (in addition of publishing the value to the control system). This way, the <a class="el" href="class_controller.html" title="[Snippet: Class Definition]">Controller</a> module implementation does not depend in any way on implementation details or even the existence of the <a class="el" href="class_average_current.html" title="[Snippet: Class Definition]">AverageCurrent</a> module, and the <a class="el" href="class_average_current.html" title="[Snippet: Class Definition]">AverageCurrent</a> module merely needs to know the name and type of this one variable.</p>
<p>The implementation computes the initial value for its output differently as for the later computations and hence has a different order of the operations in the infinite loop compared to the <a class="el" href="class_controller.html" title="[Snippet: Class Definition]">Controller</a> module:</p>
<div class="fragment"><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="keywordtype">void</span> AverageCurrent::mainLoop() {</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">float</span> coeff = 0.1;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;  currentAveraged.<a class="code" href="class_chimera_t_k_1_1_scalar_accessor.html#aa4a256db36e0927b6ac89138e921fc02">setAndWrite</a>(current); <span class="comment">// initialise currentAveraged with initial value</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160; </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  <span class="keywordflow">while</span>(<span class="keyword">true</span>) {</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    current.read();</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160; </div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    <span class="comment">// Often, it can be considered a good practise to only write values if they have actually changed. This will</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    <span class="comment">// prevent subsequent computations from running unneccessarily. On the other hand, it may prevent receivers from</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    <span class="comment">// getting a consistent &quot;snapshot&quot; for each trigger. This has to be decided case by case.</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    currentAveraged.<a class="code" href="class_chimera_t_k_1_1_scalar_accessor.html#a5eeff99021076ad757f3014219964d18">writeIfDifferent</a>((1 - coeff) * currentAveraged + coeff * current);</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  }</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;}</div>
<div class="ttc" id="aclass_chimera_t_k_1_1_scalar_accessor_html_a5eeff99021076ad757f3014219964d18"><div class="ttname"><a href="class_chimera_t_k_1_1_scalar_accessor.html#a5eeff99021076ad757f3014219964d18">ChimeraTK::ScalarAccessor::writeIfDifferent</a></div><div class="ttdeci">void writeIfDifferent(UserType newValue, VersionNumber versionNumber, DataValidity validity)=delete</div></div>
<div class="ttc" id="aclass_chimera_t_k_1_1_scalar_accessor_html_aa4a256db36e0927b6ac89138e921fc02"><div class="ttname"><a href="class_chimera_t_k_1_1_scalar_accessor.html#aa4a256db36e0927b6ac89138e921fc02">ChimeraTK::ScalarAccessor::setAndWrite</a></div><div class="ttdeci">void setAndWrite(UserType newValue, VersionNumber versionNumber)=delete</div></div>
</div><!-- fragment --> <h1><a class="anchor" id="conceptualOverview_ModuleGroup"></a>
Module groups</h1>
<p>ApplicationModules can be organised hierarchically by placing them inside a <a class="el" href="class_chimera_t_k_1_1_module_group.html">ChimeraTK::ModuleGroup</a>. A Module group can contain any number of ApplicationModules. It can also contain other ModuleGroups, to form deeper hierarchies. Note that the Application itself is also a ModuleGroup.</p>
<p>In our example, we place the <a class="el" href="class_controller.html" title="[Snippet: Class Definition]">Controller</a> module and the <a class="el" href="class_average_current.html" title="[Snippet: Class Definition]">AverageCurrent</a> module into a ModuleGroup called ControlUnit:</p>
<div class="fragment"><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  <span class="keyword">struct </span>ControlUnit : <a class="code" href="class_chimera_t_k_1_1_module_group.html">ctk::ModuleGroup</a> {</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <span class="keyword">using</span> <a class="code" href="class_chimera_t_k_1_1_module_group.html#ac6f8414b7c904b85c67cc2b4ddf87a7f">ctk::ModuleGroup::ModuleGroup</a>;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160; </div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <span class="comment">// Instantiate the temperature controller module</span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    <a class="code" href="class_controller.html">Controller</a> controller{<span class="keyword">this</span>, <span class="stringliteral">&quot;Controller&quot;</span>, <span class="stringliteral">&quot;The temperature controller&quot;</span>};</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160; </div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="comment">// Instantiate the heater current averaging module</span></div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    <a class="code" href="class_average_current.html">AverageCurrent</a> averageCurrent{<span class="keyword">this</span>, <span class="stringliteral">&quot;AverageCurrent&quot;</span>, <span class="stringliteral">&quot;Provide averaged heater current&quot;</span>};</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;  };</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  ControlUnit controlUnit{<span class="keyword">this</span>, <span class="stringliteral">&quot;ControlUnit&quot;</span>, <span class="stringliteral">&quot;Unit for controlling the oven temperature&quot;</span>};</div>
<div class="ttc" id="aclass_chimera_t_k_1_1_module_group_html"><div class="ttname"><a href="class_chimera_t_k_1_1_module_group.html">ChimeraTK::ModuleGroup</a></div><div class="ttdef"><b>Definition:</b> <a href="_module_group_8h_source.html#l00016">ModuleGroup.h:16</a></div></div>
<div class="ttc" id="aclass_chimera_t_k_1_1_module_group_html_ac6f8414b7c904b85c67cc2b4ddf87a7f"><div class="ttname"><a href="class_chimera_t_k_1_1_module_group.html#ac6f8414b7c904b85c67cc2b4ddf87a7f">ChimeraTK::ModuleGroup::ModuleGroup</a></div><div class="ttdeci">ModuleGroup()=default</div><div class="ttdoc">Default constructor to allow late initialisation of module groups.</div></div>
</div><!-- fragment --><p> Since this ModuleGroup is in this example not used anywhere else, we can declare it as a nested class inside the application class.</p>
<p>If we now take another look at the definition of the current input in the <a class="el" href="class_average_current.html" title="[Snippet: Class Definition]">AverageCurrent</a> module: </p><div class="fragment"><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;  <a class="code" href="struct_chimera_t_k_1_1_scalar_push_input.html">ctk::ScalarPushInput&lt;float&gt;</a> current{<span class="keyword">this</span>, <span class="stringliteral">&quot;../Controller/heatingCurrent&quot;</span>, <span class="stringliteral">&quot;mA&quot;</span>, <span class="stringliteral">&quot;Actuator output of the controller&quot;</span>};</div>
</div><!-- fragment --><p> we can see that the name of the variable is specified as a relative name. The two dots at the beginning refer to the parent "directory", which in this context is the ControlUnit ModuleGroup. With such relative names, it is possible to refer to the output of the <a class="el" href="class_controller.html" title="[Snippet: Class Definition]">Controller</a> module without knowing the name of the common parent ModuleGroup. This would be especially useful if we would instantiate the ControlUnit group multiple times with a different name for each instance (e.g. by placing the instances in an std::vector&lt;ControlUnit&gt;).</p>
<h1><a class="anchor" id="conceptualOverview_DeviceModule"></a>
Device modules</h1>
<p>To connect to a device, a DeviceModule needs to be instantiated in the Application, similar to instantiating an ApplicationModule:</p>
<div class="fragment"><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  <a class="code" href="class_chimera_t_k_1_1_device_module.html">ctk::DeviceModule</a> oven{<span class="keyword">this</span>, <span class="stringliteral">&quot;oven&quot;</span>, <span class="stringliteral">&quot;/Timer/tick&quot;</span>};</div>
<div class="ttc" id="aclass_chimera_t_k_1_1_device_module_html"><div class="ttname"><a href="class_chimera_t_k_1_1_device_module.html">ChimeraTK::DeviceModule</a></div><div class="ttdef"><b>Definition:</b> <a href="_device_module_8h_source.html#l00020">DeviceModule.h:20</a></div></div>
</div><!-- fragment --><p> This will publish all registers from the catalogue of the specified device "oven" to the control system and to the application modules. Since "oven" is a device alias and not a CDD, we also need to specify the DMAP file by creating an instance of SetDMapFilePath <em>before</em> the DeviceModule instance like this:</p>
<div class="fragment"><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  <a class="code" href="class_chimera_t_k_1_1_set_d_map_file_path.html">ctk::SetDMapFilePath</a> dmapPath{getName() + <span class="stringliteral">&quot;.dmap&quot;</span>};</div>
<div class="ttc" id="aclass_chimera_t_k_1_1_set_d_map_file_path_html"><div class="ttname"><a href="class_chimera_t_k_1_1_set_d_map_file_path.html">ChimeraTK::SetDMapFilePath</a></div><div class="ttdoc">Helper class to set the DMAP file path.</div><div class="ttdef"><b>Definition:</b> <a href="_device_module_8h_source.html#l00094">DeviceModule.h:94</a></div></div>
</div><!-- fragment --><p> The call to getName() returns the name of the Application, which will be provided later to the Application constructor. This allows us to influence the file name for automated tests. The DMAP file in our exmaple speficies two devies:</p>
<div class="fragment"><div class="line">device    (sharedMemoryDummy:0?map=DemoDummy.map)</div>
<div class="line">oven      (logicalNameMap?map=oven.xlmap)</div>
</div><!-- fragment --><p>It is a good practise to use a <a href="https://chimeratk.github.io/DeviceAccess/master/lmap.html">logical name mapping device</a> to allow more control over the representation of the device. The second device is the actual hardware device which will be used as a target for the logical name mapping device. We are using a sharedMemoryDummy backend (map file <a class="el" href="example.html#example_config_demo_example_dmap">DemoDummy.map</a>), so we can run the application locally and interact with the dummy device through QtHardMon.</p>
<p>The <a class="el" href="example.html#example_config_oven_xlmap">example xlmap mapping file</a> generates the following variable hierarchy:</p>
<ul>
<li>/Configuration/heaterMode (redirects to to HEATER.MODE, read/write)</li>
<li>/Configuration/lightOn (redirects to BOARD.GPIO_OUT0, read/write)</li>
<li>/Controller/heatingCurrent (reditects to HEATER.CURRENT_SET, read/write)</li>
<li>/Controller/temperatureReadback (redirects to SENSORS.TEMPERATURE1, read only)</li>
<li>/Monitoring/heatingCurrent (redirects to HEATER.CURRENT_READBACK, read only)</li>
<li>/Monitoring/temperatureOvenTop (redirects to SENSORS.TEMPERATURE2, read only)</li>
<li>/Monitoring/temperatureOvenBottom (redirects to SENSORS.TEMPERATURE3, read only)</li>
<li>/Monitoring/temperatureOutside (redirects to SENSORS.TEMPERATURE4, read only)</li>
</ul>
<p>In ApplicationCore all device registers are treated as unidirectional, and read/write registers will be used in the write direction only. Hence, the first 3 variables will have the device as a consumer, receiving values either from an ApplicationModule or from the control system. The other variables will use the device as a feeder, so the device will provide values to the ApplicationModules and the control system.</p>
<p>After this detour about the logical name mapping, we are now coming back to the instantiation of the DeviceModule. In case of our example, the device expects the application to poll the data (no registers support AccessMode::wait_for_new_data as the device does not support interrupts). Hence, the name of a push-type variable triggering the readout needs to be specified as a 3rd argument to the DeviceModule. This trigger variable will affect only registers which need a trigger and can even come from the device itself, in case it provides a data ready interrupt which shall be used to trigger the readout.</p>
<p>For now, the only ApplicatioModule in our application is the <a class="el" href="class_controller.html" title="[Snippet: Class Definition]">Controller</a> module, which connects to the /Controller/temperatureReadback as its input and to the /Controller/heatingCurrent as its output (variables/registers with identical name and path will be connected). Since /Controller/temperatureReadback is the push input of the <a class="el" href="class_controller.html" title="[Snippet: Class Definition]">Controller</a> module, updates to this variable will trigger the <a class="el" href="class_controller.html" title="[Snippet: Class Definition]">Controller</a> computations which will then write its result back to the /Controller/heatingCurrent register on the device.</p>
<p>Because /Controller/temperatureReadback is a push-type input of the <a class="el" href="class_controller.html" title="[Snippet: Class Definition]">Controller</a> module but a poll-type register of the device, a trigger is required to initiate the transfer. As specified, the variable /Timer/tick will be used for this.</p>
<p>TODO: Device initialisation handler</p>
<h1><a class="anchor" id="conceptualOverview_PeriodicTriggers"></a>
Periodic Triggers</h1>
<p>So far, there is no source specified for the variable /Timer/tick. In this case, the control system will automatically be used as a source. Since all control system variables are considered push type, they can be used as a trigger. Any write to this variable from the control system side will now trigger the device readouts, which could be realised e.g. as a button on a control system panel. While this might be useful in some cases, we cannot run a control loop like this.</p>
<p>To provide a trigger for periodic tasks, Application Core provides a generic ApplicationModule called <a class="el" href="struct_chimera_t_k_1_1_periodic_trigger.html" title="Simple periodic trigger that fires a variable once per second.">ChimeraTK::PeriodicTrigger</a>. We can instantiate it in the application like this:</p>
<div class="fragment"><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  <a class="code" href="struct_chimera_t_k_1_1_periodic_trigger.html">ctk::PeriodicTrigger</a> timer{<span class="keyword">this</span>, <span class="stringliteral">&quot;Timer&quot;</span>, <span class="stringliteral">&quot;Periodic timer for the controller&quot;</span>};</div>
<div class="ttc" id="astruct_chimera_t_k_1_1_periodic_trigger_html"><div class="ttname"><a href="struct_chimera_t_k_1_1_periodic_trigger.html">ChimeraTK::PeriodicTrigger</a></div><div class="ttdoc">Simple periodic trigger that fires a variable once per second.</div><div class="ttdef"><b>Definition:</b> <a href="_periodic_trigger_8h_source.html#l00017">PeriodicTrigger.h:17</a></div></div>
</div><!-- fragment --><p> This will publish the following variables (with the given instance name "Timer"):</p>
<ul>
<li>/Timer/period</li>
<li>/Timer/tick</li>
</ul>
<p>/Timer/period allows to configure the trigger period and will default to 1000ms. /Timer/tick then is the trigger output. It is of the type uint64_t and will contain the trigger counter (starting with 0 at application start).</p>
<p>Because the name for the output has been already specified as a trigger in the DeviceModule, it will initiate the device readout and hence indirectly the <a class="el" href="class_controller.html" title="[Snippet: Class Definition]">Controller</a> module computations. The type and value do not matter for this purpose, so the trigger counter is discarded when being used as a DeviceModule trigger, but it remains visible to the control system.</p>
<h1><a class="anchor" id="conceptualOverview_ConfigReader"></a>
Configuration constants</h1>
<ul>
<li><a class="el" href="struct_chimera_t_k_1_1_config_reader.html" title="Generic module to read an XML config file and provide the defined values as constant variables.">ChimeraTK::ConfigReader</a> is another generic ApplicationModule</li>
<li>provides variables defined in XML config file with contant values</li>
<li>example: instantiation and config file (providing /Timer/period)</li>
</ul>
<h1><a class="anchor" id="conceptualOverview_VariableGroup"></a>
Variable groups</h1>
<ul>
<li>VariableGroups can organise process variables inside ApplicatioModules hierarchically</li>
<li>VariableGroup contains any number of process variable accessors and other VariableGroups</li>
<li>An ApplicationModule is also a VariableGroup</li>
<li>VariableGroup offers group operations affecting all accessors inside: VariableGroup::readAll(), VariableGroup::writeAll() etc.</li>
<li>Note: module and variable names can contain hierarchies as well (with slashes as separators, both relative and absolute). The same hierarchy can be obtained in different ways. ModuleGroups and VariableGroups should be used to organsie the source code.</li>
</ul>
<h1><a class="anchor" id="conceptualOverview_ApplicationModel"></a>
The Application model</h1>
<ul>
<li>Framework collects information about application structure</li>
<li>Used by framework to make connections</li>
<li>Advanced ApplicationModules might use it as well, e.g. to auto-connect to all modules of a certain type (needs separate tutorial)</li>
<li>Developers can use it for documentation and debugging</li>
<li>example: Show model as DOT graph</li>
<li>XML generator</li>
</ul>
<h1><a class="anchor" id="conceptualOverview_FanOuts"></a>
Fanouts</h1>
<ul>
<li>Process variables often have multiple consumers: copy necessary</li>
<li>FeedingFanOut: Create copy of ApplicationModule output and distribute to multiple consumers (within thread of ApplicationModule)</li>
<li>ThreadedFanOut: Create copy of control system variable or push-type device variable and distribute, within its own thread</li>
<li>TriggerFanOut: like special ApplicationModule, waiting for trigger, reading all device variables with that trigger and distribute (one TriggerFanOut per device and trigger)</li>
<li>ConsumingFanOut: Special case: Poll-type register with exactly one poll-type consumer (ApplicationModule). Polling directly from device by ApplicationModule code (no trigger is used). Additional consumers possible but must be push type (push happens when ApplicationModule decides to poll).</li>
</ul>
<h1><a class="anchor" id="conceptualOverview_InitialValues"></a>
Initial values</h1>
<ul>
<li>Each ApplicatioModule starts its <a class="el" href="test_illegal_networks_8cc.html#af14601579e7c6dd672a85c562800b1fa">mainLoop()</a> with initial values present in each variable</li>
<li>Initial values must be provided to all process variables in time</li>
<li>Otherwise: ApplicatioModule will not start</li>
<li>Variables which are fed by the control system get their initial value from the control sytem's persistency layer</li>
<li>Device registers will be read once after the device is opened</li>
<li>ApplicationModules: developer must take care. Write before first blocking read in <a class="el" href="test_illegal_networks_8cc.html#af14601579e7c6dd672a85c562800b1fa">mainLoop()</a>, or write in prepare().</li>
<li>Circular dependencies possible: Two ApplicationModules might wait for each other. In this case at least one of them needs to write initial values in prepare(), so the other can enter the <a class="el" href="test_illegal_networks_8cc.html#af14601579e7c6dd672a85c562800b1fa">mainLoop()</a> and write its initial values.</li>
</ul>
<h1><a class="anchor" id="conceptualOverview_ExceptionHandling"></a>
Device exception handling</h1>
<ul>
<li>Device exceptions are handled by framework, no need to catch them</li>
<li>DeviceModule goes into error state and attempts to recover (reopen)</li>
<li>ApplicationModules and the control system are informed by marking data with ChimeraTK::DataValidity::invalid (see Section <a class="el" href="conceptual_overview.html#conceptualOverview_DataValidity">Data validity propagation</a>)</li>
<li>During recovery: re-execute device initialisation (initialisation handlers), restore last-written values, re-read initial values, then continue normal operation</li>
<li>In most cases, no special care required by application developers</li>
<li>If needed, actions can be triggered by reacting on the variable /Device/&lt;alias&gt;/deviceBecameFunctional or /Device/&lt;alias&gt;/status</li>
</ul>
<h1><a class="anchor" id="conceptualOverview_DataValidity"></a>
Data validity propagation</h1>
<ul>
<li>If any input of ApplicationModule marked as ChimeraTK::DataValidity::invalid, all written outputs will be marked as ChimeraTK::DataValidity::invalid, too.</li>
<li>Attention required: if ApplicatioModule writes not always all outputs, ChimeraTK::DataValidity::invalid flag may stay indefinitively. Make sure to propagate ChimeraTK::DataValidity::ok to all outputs even if value is still valid.</li>
<li>ChimeraTK::DataValidity::invalid can come from Device exceptions (see Section <a class="el" href="conceptual_overview.html#conceptualOverview_ExceptionHandling">Device exception handling</a>) but also other reasons, e.g. DoocsBackend sees stale data</li>
<li>ApplicatioModule can set ChimeraTK::DataValidity::invalid intentionally by calling ApplicatioModule::incrementDataFaultCounter() and clear it by ApplicatioModule::decrementDataFaultCounter() (make sure to pair this properly!)</li>
</ul>
<h1><a class="anchor" id="conceptualOverview_ControlSystemIntegration"></a>
Control system integration</h1>
<ul>
<li>Control system adapter integrates application into DOOCS, EPICS, OPC UA, Tango etc.</li>
<li>Adapter-specific config file controls features like histories etc.</li>
<li>Also name mapping possible</li>
<li>cmake macro for choosing adapter at compile time</li>
<li>Example: DOOCS adapter config </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">index</a></li>
    <li class="footer">Generated on Wed Jan 17 2024 04:53:54 for ChimeraTK-ApplicationCore by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
