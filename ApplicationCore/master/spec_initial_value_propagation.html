<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ChimeraTK-ApplicationCore: Technical specification: Propagation of initial values V1.0</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ChimeraTK_Logo_whitebg.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ChimeraTK-ApplicationCore
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('spec_initial_value_propagation.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Technical specification: Propagation of initial values V1.0 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><blockquote class="doxtable">
<p><b>NOTICE FOR FUTURE RELEASES: AVOID CHANGING THE NUMBERING!</b> The tests refer to the sections, incl.</p>
</blockquote>
<p>links and unlinked references from tests or other parts of the specification. These break, or even worse become wrong, when they are not changed consistenty!</p>
<h2>A. Introduction</h2>
<p>This document describes how initial values are propagated from the control system persistency layer, from the devices and from application modules into the attached components (control system, devices and other application modules).</p>
<p>This specification goes beyond ApplicationCore. It has impact on other <a class="el" href="namespace_chimera_t_k.html" title="InvalidityTracer application module. ">ChimeraTK</a> libraries like DeviceAccess, the ControlSystemAdapter and even backends and adapter implementations.</p>
<h2>B. Definitions</h2>
<ul>
<li>Initial value: The start value of a process variable. The value is available to the receiving end of the process variable at a well defined point in time at the start. This is a logical concept. It is to be distinguished from the (often hardcoded) "value after construction" of the <code>ProcessArray</code> or any other <code>NDRegisterAccessor</code> implementation. The point in time when the value becomes available is well-defined, as described in the section C (high-level requirements).</li>
</ul>
<h2>C. High-level requirements</h2>
<ol type="1">
<li>Initial values are available to all <code><a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a></code>s at the start of the <code><a class="el" href="class_chimera_t_k_1_1_application_module.html#a21fb69e51e5d150ae2718715c942e0f8" title="To be implemented by the user: function called in a separate thread executing the main loop of the mo...">ApplicationModule::mainLoop()</a></code>. No call to <code>TransferElement::read()</code> etc. is required. This implies that the <code><a class="el" href="class_chimera_t_k_1_1_application_module.html#a21fb69e51e5d150ae2718715c942e0f8" title="To be implemented by the user: function called in a separate thread executing the main loop of the mo...">ApplicationModule::mainLoop()</a></code> is not started until all initial values are available, including those coming from devices which might potentially be offline, or from other <code><a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a></code>s.</li>
<li><code><a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a></code> implementations can either provide initial values for their outputs in <code><a class="el" href="class_chimera_t_k_1_1_module.html#af2807dcc289719688b513e05ca6f1568" title="Prepare the execution of the module. ">ApplicationModule::prepare()</a></code> (if the initial value doesn't depend on any inputs) or right after the start of the <code><a class="el" href="class_chimera_t_k_1_1_application_module.html#a21fb69e51e5d150ae2718715c942e0f8" title="To be implemented by the user: function called in a separate thread executing the main loop of the mo...">ApplicationModule::mainLoop()</a></code> (if the initial value needs to be computed from the incoming initial values of the inputs).</li>
<li><a class="anchor" id="C_3"></a>The "value after construction"<a class="el" href="spec_initial_value_propagation.html#comment_C_3">(*)</a> is not propagated automatically during initial value propagation, not even with the <code>DataValidity::faulty</code> flag set. It is not visible to user code in the <code><a class="el" href="class_chimera_t_k_1_1_application_module.html#a21fb69e51e5d150ae2718715c942e0f8" title="To be implemented by the user: function called in a separate thread executing the main loop of the mo...">ApplicationModule::mainLoop()</a></code>.<ol type="a">
<li><a class="anchor" id="C_3_a"></a>An partial exception to this rule is the case if a device breaks (i.e. throws an exception) right after it has been successfully opened and initialised. In this case, the value of the variable is the value after construction and the <code>DataValidity::faulty</code> flag is set, but the VersionNumber is not <code>{nullptr}</code>. <a class="el" href="spec_initial_value_propagation.html#comment_C_3_a">(*)</a></li>
</ol>
</li>
<li>Since <code><a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a></code>s and devices might wait for initial values from other <code><a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a></code>s and devices, the modules might end up in a dead lock due to a circular connection. The circular connection is legal, but the dead lock situation needs to be broken by one <code><a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a></code> writing its initial value during <code><a class="el" href="class_chimera_t_k_1_1_module.html#af2807dcc289719688b513e05ca6f1568" title="Prepare the execution of the module. ">ApplicationModule::prepare()</a></code>.<ol type="a">
<li>In case of such dead lock situation, there will be an error message stating the reason for the dead lock, and the application will be terminated.</li>
</ol>
</li>
<li>(removed)</li>
<li>The control system does not wait for "initial values" as such. The first value of a process variable is sent to the control system when available. This may depend even on external conditions like the availability of devices, e.g. the control system interface has to run even if devices are not available and hence cannot send an inital value.</li>
<li>The first value received by the control system can be an initial value. This is different to ApplicationModules, where an initial value is never seen as a new value that can be read because they are always already there and received when the main loop starts.</li>
<li>Control system variables show the <code>DataValidity::faulty</code> flag until they have received the first valid value.</li>
<li>For push-type variables from devices, the initial is automatically send by the backend. The framework can just wait for a value to arrive. 9.1 According to the TransferElement specification, also after recovery from an exception the current value is send again. No special action needed by AplicationCore (c.f. <a class="el" href="spec_execption_handling.html">Technical specification: Exception handling for device runtime errors V1.0</a>).</li>
</ol>
<h3>(*) Comments</h3>
<ul>
<li><a class="anchor" id="comment_C_3"></a><a class="el" href="spec_initial_value_propagation.html#C_3">3.</a> The value which is set in the constructor of all process variables is determined at compile time and usually is 0, which is basically always wrong. It is very important that no wrong data is transported initially. If it gets propagated within the application, modules will process this value (usually even if <code>DataValidity::faulty</code> is set), despite the value might present an inconsistent state with other process variables. If it gets propagated to the control system, other applications might act on an again inconsistent state.</li>
<li><a class="anchor" id="comment_C_3_a"></a><a class="el" href="spec_initial_value_propagation.html#C_3_a">3.a.</a> This exempt case happens rarely in real applications and can be excluded in automated tests, hence it presents an acceptable simplification for the implementation (which otherwise had to retry the read attempt). It only occurs if the device was working and then immediately fails again before the initial value could be read.</li>
</ul>
<h2>D. Detailed requirements</h2>
<ol type="1">
<li>All <code>NDRegisterAccessor</code> implementations (including but not limited to the <code>ProcessArray</code>) have the <code>DataValidity::faulty</code> flag set after construction for the receiving end. This ensures, all data is marked as <code>faulty</code> as long as no sensible initial values have been propagated. The sending end has <code>DataValidity::ok</code> after construction, so that the first written data automatically propagates the ok state by default. For bidirectional variables, this is the case for both directions separately. [ <a class="el" href="test_initial_value_spec_d8_8cc.html#testD1InitialValue_D_1">T</a>]</li>
<li>All <code>NDRegisterAccessor</code> implementations have initially a <code>VersionNumber</code> constructed with a <code>nullptr</code>, which allows to check whether this variable is still at its "value after construction", or the initial value propagation already took place. [ <a class="el" href="test_initial_value_spec_d8_8cc.html#testD1InitialValue_D_2">T</a>]</li>
<li><code><a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a></code> (and <code><a class="el" href="class_chimera_t_k_1_1_threaded_fan_out.html" title="FanOut implementation with an internal thread which waits for new data which is read from the given f...">ThreadedFanOut</a></code>/<code><a class="el" href="class_chimera_t_k_1_1_trigger_fan_out.html" title="InternalModule which waits for a trigger, then reads a number of variables and distributes each of th...">TriggerFanOut</a></code>) propagate the <code>DataValidity</code> of its outputs according to the state of all inputs. This behaviour is identical to later during normal data processing and specified in the <a class="el" href="spec_data_validity_propagation.html">Technical specification: data validity propagation</a>. [ <a class="el" href="test_initial_value_spec_d8_8cc.html#testD1InitialValue_D_3">T</a>]</li>
<li>(removed)</li>
<li>Control system variables: [Testing should be done in control system adapter.]<ol type="a">
<li>Variables with the control-system-to-application direction are written exactly once at application start by the control system adapter with their initial values from the persistency layer. This is done before <code><a class="el" href="namespace_chimera_t_k.html#a69c04b7fb1519cd2b454be33d88bb72daa53108f7543b75adbb34afc035d4cdf6" title="Actual run phase with full multi threading. ">ApplicationBase::run()</a></code> is called, or soon after (major parts of the application will be blocked until it's done). If the persistency layer can persist the <code>DataValidity</code>, the initial value have the correct validity. Otherwise, initial values always have the <code>DataValidity::ok</code>.</li>
<li>Variables with the application-to-control-system direction conceptually do not have an "initial value". The control system adapter implementation does not wait for an initial value to show up. The first value of these variables are written at an undefined time after the <code><a class="el" href="namespace_chimera_t_k.html#a69c04b7fb1519cd2b454be33d88bb72daa53108f7543b75adbb34afc035d4cdf6" title="Actual run phase with full multi threading. ">ApplicationBase::run()</a></code> has been called. They might or might not be initial values of other modues. The control system adapter does not expect any specific behaviour. Entities writing to these variables do not need to take any special precautions.</li>
</ol>
</li>
<li>Device variables:<ol type="a">
<li>Write accessors are written after the device is opened and the initialisation is done, as soon as the initial value is available for that variable. Initial values can be present through 5.a, 6.b, 6.c or 7. [ <a class="el" href="test_initial_value_spec_d8_8cc.html#testD6_a1_InitialValue">T</a>]</li>
<li>Initial values for read accessors without AccessMode::wait_for_new_data are read after the device is openend and the initialsation is done. [ <a class="el" href="test_initial_value_spec_d8_8cc.html#testD6_b_InitialValue">T</a>]</li>
<li>Initial values for read accessors with AccessMode::wait_for_new_data are provided by the Device backend as the first value after the device has been opeend and asynchronous reads have been activated. [ <a class="el" href="test_initial_value_spec_d8_8cc.html#testD6_c_InitialValue">T</a>]</li>
</ol>
</li>
<li>Outputs of <code><a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a></code>s:<ol type="a">
<li>Initial values can be written in <code><a class="el" href="class_chimera_t_k_1_1_module.html#af2807dcc289719688b513e05ca6f1568" title="Prepare the execution of the module. ">ApplicationModule::prepare()</a></code>, if the value does not depend on any input values (since input values are not available during <code>prepare()</code>). [ <a class="el" href="test_initial_value_spec_d8_8cc.html#testD7_1_InitialValue">T</a>]</li>
<li>Alternatively, initial values can be written in <code><a class="el" href="class_chimera_t_k_1_1_application_module.html#a21fb69e51e5d150ae2718715c942e0f8" title="To be implemented by the user: function called in a separate thread executing the main loop of the mo...">ApplicationModule::mainLoop()</a></code> before calling any <code>read</code> function, if they depend on initial values of the inputs. Typically, to propagate the initial values of its inputs, an <code><a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a></code> will run its computations and write its outputs first before waiting for new data with a blocking <code>read()</code> and the end of the processing loop. The application author needs to take into account that the <code><a class="el" href="class_chimera_t_k_1_1_application_module.html#a21fb69e51e5d150ae2718715c942e0f8" title="To be implemented by the user: function called in a separate thread executing the main loop of the mo...">ApplicationModule::mainLoop()</a></code> will only start after all inputs have their initial values available, which might depend on the avaialbility of devices. [ <a class="el" href="test_initial_value_spec_d8_8cc.html#testD7_2_InitialValue">T</a>]</li>
<li>Since in <code><a class="el" href="class_chimera_t_k_1_1_module.html#af2807dcc289719688b513e05ca6f1568" title="Prepare the execution of the module. ">ApplicationModule::prepare()</a></code> all devices are still closed, any writes to device variables at this point need to be delayed until the device is open. As the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a> takes care of this, the appciation module can just call write() on its output and does not have to do any special actions here (see <a class="el" href="spec_execption_handling.html#b_2_3">Technical specification: Exception handling for device runtime errors B.2.3</a>).</li>
</ol>
</li>
<li><a class="anchor" id="InitialValuesInputsOfApplicationCore_D_8"></a>Inputs of <code><a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a></code>s:<ol type="a">
<li>Initial values are read by the framwork before the start of <code><a class="el" href="class_chimera_t_k_1_1_application_module.html#a21fb69e51e5d150ae2718715c942e0f8" title="To be implemented by the user: function called in a separate thread executing the main loop of the mo...">ApplicationModule::mainLoop()</a></code> (but already in the same thread which later executes the <code>mainLoop()</code>).</li>
<li>Initial values are read by calling <code>TransferElement::read()</code>, which <em>freezes</em> until the initial value has arrived, both with <code>AccessMode::wait_for_new_data</code> and without.<ol type="i">
<li><a class="anchor" id="initialValue_D_8_b_i"></a>For device variables the ExeptionHandlingDecorator freezes the variable until the device is available. [ <a class="el" href="test_initial_value_spec_d8_8cc.html#testInitialValue_D_8_b_i">T</a>]</li>
<li><a class="anchor" id="initialValue_D_8_b_ii"></a>ProcessArray freeze in their implementation until the initial value is received (see. <a class="el" href="spec_initial_value_propagation.html#initialValue_E_process_arrays">E ProcessArrays</a>). [ <a class="el" href="test_initial_value_spec_d8_8cc.html#testInitialValue_D_8_b_ii">T</a>]</li>
<li><a class="anchor" id="initialValue_D_8_b_iii"></a>Constants can be read exactly once in case of <code>AccessMode::wait_for_new_data</code>, so the initial value can be received. (see. <a class="el" href="spec_initial_value_propagation.html#initialValue_d_10">10</a>) [ <a class="el" href="test_initial_value_spec_d8_8cc.html#testInitialValue_D_8_b_iii">T</a>]</li>
</ol>
</li>
</ol>
</li>
<li>The module-like fan outs <code><a class="el" href="class_chimera_t_k_1_1_threaded_fan_out.html" title="FanOut implementation with an internal thread which waits for new data which is read from the given f...">ThreadedFanOut</a></code> and <code><a class="el" href="class_chimera_t_k_1_1_trigger_fan_out.html" title="InternalModule which waits for a trigger, then reads a number of variables and distributes each of th...">TriggerFanOut</a></code> (does not apply to the accessor-like fan outs <code><a class="el" href="class_chimera_t_k_1_1_feeding_fan_out.html" title="NDRegisterAccessor implementation which distributes values written to this accessor out to any number...">FeedingFanOut</a></code> and <code><a class="el" href="class_chimera_t_k_1_1_consuming_fan_out.html" title="FanOut implementation which acts as a read-only (i.e. ">ConsumingFanOut</a></code>)<ol type="a">
<li>The fan outs have a transparent behaviour, i.e. an entity that receives an initial value through a fan out sees the same behaviour as if a direct connection would have been realised.</li>
<li><a class="anchor" id="initialValueThreaddedFanOut_D_9_b"></a>This implies that the inputs are treated like described in 8.b. [ <a class="el" href="test_initial_value_spec_d8_8cc.html#testInitialValueThreaddedFanOut_D_9_b">T for ThreadedFanOut</a>] [ T for TriggerFanOut]</li>
<li><a class="anchor" id="initialValue_d_9_3"></a>The initial value is propagated immediately to the outputs. <a class="el" href="spec_initial_value_propagation.html#initialValue_comment_d_9_3">(*)</a></li>
</ol>
</li>
<li><a class="anchor" id="initialValue_d_10"></a>Constants (<code><a class="el" href="class_chimera_t_k_1_1_application.html#ac218f88f11166c115b0facb6a2c981f5" title="Convenience function for creating constants. ">Application::makeConstant()</a></code>): [ <a class="el" href="test_initial_value_spec_d8_8cc.html#testConstantD10InitialValue_D_10">T</a>]<ol type="a">
<li>Constant accessors only have one value, which is propagates as the intitial value. They conceptually behave like a process array that is written exactly once by the framework.<ol type="i">
<li>This implies that in case of <code>AccessMode::wait_for_new_data</code> the value can be read exactly once. This is enough to propagate the initial value. Any further read() to the variable will block infinitely.</li>
</ol>
</li>
<li>Values are propagated before the <code><a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a></code> threads are starting (just like initial values written in <code><a class="el" href="class_chimera_t_k_1_1_module.html#af2807dcc289719688b513e05ca6f1568" title="Prepare the execution of the module. ">ApplicationModule::prepare()</a></code>)</li>
<li>Devices are not opened yet at this point in time. Delaying the write is done with the same mechanism as described in 7.c.</li>
</ol>
</li>
<li>Variables with a return channel ("bidirectional variables", <code><a class="el" href="struct_chimera_t_k_1_1_scalar_push_input_w_b.html" title="Convenience class for input scalar accessors with return channel (&quot;write back&quot;) and UpdateMode::push...">ScalarPushInputWB</a></code>, <code><a class="el" href="struct_chimera_t_k_1_1_scalar_output_push_r_b.html" title="Convenience class for output scalar accessors with return channel (&quot;read back&quot;) (always UpdateMode::p...">ScalarOutputPushRB</a></code> and the array variants) behave like their unidirectional pendants, i.e. the existence of the return channel is ignored during the initial value propagation.</li>
</ol>
<h3>Comments</h3>
<ul>
<li>To 5.: This is the responsibility of each control system adpater implementation.</li>
<li>To 7. and 10.: An output of a <code><a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a></code> with an initial value written in <code><a class="el" href="class_chimera_t_k_1_1_module.html#af2807dcc289719688b513e05ca6f1568" title="Prepare the execution of the module. ">ApplicationModule::prepare()</a></code> and later never written again behaves in the same way as a constant.</li>
<li><a class="anchor" id="initialValue_comment_d_9_3"></a>To <a class="el" href="spec_initial_value_propagation.html#initialValue_d_9_3">9.c</a>: Even if devices connected to outputs are in fault state, the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a> takes care that the writing is delayed. The fan out is not blocked by this.</li>
</ul>
<h2>E. Implementation</h2>
<h3>NDRegisterAccessor implementations</h3>
<ul>
<li>Each <code>NDRegisterAccessor</code> must implement 1. separately.</li>
<li>Each <code>NDRegisterAccessor</code> must implement 2. separately. All accessors should already have a <code>VersionNumber</code> data member called <code>currentVersion</code> or similar, it simply needs to be constructed with a <code>nullptr</code> as an argument.</li>
</ul>
<h3><a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a></h3>
<ul>
<li>Implement 3, implementation will be already covered by normal flag propagation</li>
<li>API documentation must contain 7.</li>
<li>Implements 8. (hence takes part in 5.a, 6.b and 7 implicitly):<ul>
<li>All inputs of the module must be read in the <code><a class="el" href="class_chimera_t_k_1_1_application_module.html#ac2c8911aaa22fca678cfd5f79c0a1f0f" title="Wrapper around mainLoop(), to execute additional tasks in the thread before entering the main loop...">ApplicationModule::mainLoopWrapper()</a></code> before the call to <code>mainLoop()</code>.</li>
</ul>
</li>
</ul>
<h3><a class="el" href="class_chimera_t_k_1_1_threaded_fan_out.html" title="FanOut implementation with an internal thread which waits for new data which is read from the given f...">ThreadedFanOut</a></h3>
<ul>
<li>Implement 3, implementation will be already covered by normal flag propagation</li>
<li>Needs to implement 9. (hence takes part in 5.a, 6 and 7 implicitly):<ul>
<li>structure the fan out's "mainLoop"-equivalent (<code><a class="el" href="class_chimera_t_k_1_1_threaded_fan_out.html#aec8d6bcf52e7887791968acf8ac2a3e1" title="Synchronise feeder and the consumers. ">ThreadedFanOut::run()</a></code>) like this:<ul>
<li>read initial values</li>
<li>begin loop</li>
<li>write outputs</li>
<li>read input</li>
<li>cycle loop</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="el" href="class_chimera_t_k_1_1_trigger_fan_out.html" title="InternalModule which waits for a trigger, then reads a number of variables and distributes each of th...">TriggerFanOut</a></h3>
<ul>
<li>Implement 3, implementation will be already covered by normal flag propagation</li>
<li>Needs to implement 9. (hence takes part in 5.a, 6, and 7 implicitly):<ul>
<li>In contrast to the <code><a class="el" href="class_chimera_t_k_1_1_threaded_fan_out.html" title="FanOut implementation with an internal thread which waits for new data which is read from the given f...">ThreadedFanOut</a></code>, the <code><a class="el" href="class_chimera_t_k_1_1_trigger_fan_out.html" title="InternalModule which waits for a trigger, then reads a number of variables and distributes each of th...">TriggerFanOut</a></code> has only poll-type data inputs which are all coming from the same device. Data inputs cannot come from non-devices.</li>
<li>Structure the fan out's "mainLoop"-equivalent (<code><a class="el" href="class_chimera_t_k_1_1_trigger_fan_out.html#ac46817d485e17425b7200cfe5c3c7bff" title="Synchronise feeder and the consumers. ">TriggerFanOut::run()</a></code>) like this:<ul>
<li>read initial value of trigger input</li>
<li>begin loop</li>
<li>read data inputs via <code>TransferGroup</code></li>
<li>write outputs</li>
<li>read trigger</li>
<li>cycle loop</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a></h3>
<p>All points are already covered by <a class="el" href="spec_execption_handling.html">Technical specification: Exception handling for device runtime errors V1.0</a>.</p>
<h3><a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a></h3>
<p>All points are already covered by <a class="el" href="spec_execption_handling.html">Technical specification: Exception handling for device runtime errors V1.0</a>.</p>
<h3><a class="el" href="class_chimera_t_k_1_1_application.html">Application</a></h3>
<p>(This section refers to the class <code><a class="el" href="class_chimera_t_k_1_1_application.html">Application</a></code>, not to the user-defined application.)</p>
<ul>
<li>Implements 10.b and partly 10.c (in combination with the exception handling mechanism)</li>
</ul>
<h3>ControlSystemAdapter</h3>
<ul>
<li>Must implement 5.a<ul>
<li>Needs to be done in all adapters separately</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="initialValue_E_process_arrays"></a>ProcessArrays</h3>
<ul>
<li>Must implement 8.b.ii, especially if wait_for_new_data is <em>not</em> set.</li>
</ul>
<p>As ProcessArrays do not have a synchronous read channel which can be used to obtain the "current value", the implementation freezes all read operations (even readNonBlocking() and readLatest()) until a first value has been send. This is consistent with the behaviour of the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a>, which freezes until the device has become available and the synchronous channel can deliver data.</p>
<p>Comment: The original idea of an extra function readBlocking() only for process arrays does not work, because it breaks abstraction. To use it one would have to dynamic cast a TransferElement to ProcessArray, which does not work when the object is decorated (which it always is).</p>
<h2>F. Known bugs [OUTDATED!!!]</h2>
<h3>DeviceAccess interface</h3>
<ul>
<li>1. is currently not implementable for (potentially) bidirectional accessors (like most backend accessors). An interface change is required to allow separete <code>DataValidity</code> flags for each direction.</li>
</ul>
<h3>NDRegisterAccessor implementations</h3>
<ul>
<li>1. is not implemented for Device implementations (only the <code>UnidirectionalProcessArray</code> is correct at the moment).</li>
<li>2. is not implemented for Device implementations (only the <code>UnidirectionalProcessArray</code> is correct at the moment).</li>
<li>Exceptions are currently thrown in the wrong place (see implementation section for the NDRegisterAccessor). A possible implementation to help backends complying with this rule would be:<ul>
<li>Introduce non-virtual <code>TransferElement::readTransfer()</code> etc, i.e. all functions like <code>do[...]Transfer[...]()</code> should have non-virtual pendants without <code>do</code>.</li>
<li>These new functions will call the actual <code>do[...]Transfer[...]()</code> function, but place a try-catch-block around to catch all <a class="el" href="namespace_chimera_t_k.html" title="InvalidityTracer application module. ">ChimeraTK</a> exceptions</li>
<li>The exceptions are stored and operation is continued. In case of boolean return values correct values must be implemented:<ul>
<li><code>doReadTransferNonBlocking()</code>and <code>doReadTransferLatest()</code> must return false (there was no new data), except for the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a> which has to return true if it will do a recovery in postRead() and there will be new data.</li>
<li><code>doWriteTransfer()</code> shall return true (dataLost), except for the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a>. It should return true only if the data of the recovery accessor is replaced and the previous value has not been written to the hardware.</li>
</ul>
</li>
<li><code>postRead()</code> and <code>postWrite()</code> must always be called. It currently depends on the boolean return value if there is one. Instead this value has to be handed to <code>postRead()</code> and <code>postWrite()</code> as an argument. Only the implementation can decide what it has to do and what can be skipped.</li>
<li>With <code>TransferElement::postRead()</code> resp. <code>TransferElement::postWrite()</code> non-virtual wrappers for the post-actions already exist. In these functions, the stored exception should be thrown.</li>
<li>All decorators and decorator-like accessors must be changed to call always the (new or existing) non-virtual functions in their virtual <code>do[...]</code> functions. This applies to both the transfer functions and the pre/post actions (for the latter it should be already the case).</li>
<li>It is advisable to add an assert that no unthrown exception is present before storing a new exception, to prevent that exceptions might get lost due to errors in the business logic.</li>
</ul>
</li>
</ul>
<h3><a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a> / <a class="el" href="class_chimera_t_k_1_1_entity_owner.html" title="Base class for owners of other EntityOwners (e.g. ">EntityOwner</a></h3>
<ul>
<li>3. is not properly implemented, the <code>faultCounter</code> variable itself is currently part of the EntitiyOwner. It will be moved to a helper class, so multiple instances can be used (needed for the <a class="el" href="class_chimera_t_k_1_1_trigger_fan_out.html" title="InternalModule which waits for a trigger, then reads a number of variables and distributes each of th...">TriggerFanOut</a>). It is the responsibility of the decorators which manipulate the DataFaultCounter to increase the counter when they come up with faulty data in the inital state (see <a class="el" href="spec_data_validity_propagation.html">Technical specification: data validity propagation Specification version V1.0</a>).</li>
</ul>
<h3><a class="el" href="class_chimera_t_k_1_1_trigger_fan_out.html" title="InternalModule which waits for a trigger, then reads a number of variables and distributes each of th...">TriggerFanOut</a></h3>
<ul>
<li>3. is not correctly implemented, it needs to be done on a per-variable level.</li>
<li>It currently implements its own exception handling (including the <code>Device::isOpened()</code> check), but in a wrong way. After the <code>NDRegisterAccessor</code> has been fixed, this needs to be removed.</li>
</ul>
<h3><a class="el" href="class_chimera_t_k_1_1_device_module.html" title="Implementes access to a ChimeraTK::Device. ">DeviceModule</a></h3>
<p>Probably all points are duplicates with <a class="el" href="spec_execption_handling.html">Technical specification: Exception handling for device runtime errors V1.0</a>.</p>
<ul>
<li>Merge <code>DeviceModule::writeAfterOpen/writeRecoveryOpen</code> lists.</li>
<li>Implement mechanism to block read/write operations in other threads until after the initialsation is done.</li>
</ul>
<h3><a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application. ">ExceptionHandlingDecorator</a></h3>
<p>Some points are duplicates with <a class="el" href="spec_execption_handling.html">Technical specification: Exception handling for device runtime errors V1.0</a>.</p>
<ul>
<li>It waits until the device is opened, but not until after the initialisation is done.</li>
<li>Provide non-blocking function.</li>
<li>Implement special treatment for first <code>readLatest()</code> operation to always block in the very first call until the device is available.<ul>
<li>Since <code>readLatest()</code> is always the first <code>read</code>-type function called, it is acceptable if all <code>read</code>-type functions implement this behaviour. Choose whatever is easier to implement, update the implementation section of this specification to match the chosen implementation.</li>
</ul>
</li>
</ul>
<h3><a class="el" href="class_chimera_t_k_1_1_variable_network_node.html" title="Class describing a node of a variable network. ">VariableNetworkNode</a></h3>
<ul>
<li>Rename <code>VariableNetworkNode::hasInitialValue()</code> into <code>VariableNetworkNode::initialValueUpdateMode()</code>, and change the return type to <code>UpdateMode</code>. Remove the InitialValueMode enum.</li>
<li>Remove data member storing the presence of an initial value, this is now always the case. Change <code>VariableNetworkNode::initialValueType()</code> accordingly.</li>
<li>Document cleanly that the initialValueUpdateMode is different from the normal update mode as described in 8b.</li>
</ul>
<h3>ControlSystemAdapter</h3>
<ul>
<li>EPICS-Adapter might not properly implement 5.a, needs to be checked. Especially it might not be guaranteed that all variables are written (and not only those registered in the autosave plugin).</li>
<li>The <code>UnidirectionalProcessArray</code> uses always a default start value of <code>DataValidity::ok</code>, but overwrites this with <code>DataValidity::faulty</code> for the receivers in the factory function <code>UnidirectionalProcessArray::createSynchronizedProcessArray()</code> (both implementations, see UnidirectionalProcessArray.h). This can be solved more elegant after the DeviceAccess interface change described above.</li>
</ul>
<h3>Non-memeber functions</h3>
<ul>
<li>Implement the missing convenience function</li>
</ul>
<h3>Documentation</h3>
<ul>
<li>Documentation of ControlSystemAdapter should mention that implementations must take care about 5.</li>
<li>Documentation for <a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a> should mention 7.</li>
<li>Documentation of VariableNetworkNode::initialValueUpdateMode() </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">index</a></li>
    <li class="footer">Generated on Wed Aug 25 2021 03:53:47 for ChimeraTK-ApplicationCore by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
