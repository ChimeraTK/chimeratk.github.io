<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ChimeraTK-ApplicationCore: Technical specification: Exception handling for device runtime errors V1.0</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ChimeraTK_Logo_whitebg.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ChimeraTK-ApplicationCore
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('spec_execption_handling.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Technical specification: Exception handling for device runtime errors V1.0 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><blockquote class="doxtable">
<p>This version is identical to V1.0RC2WIP.</p>
<p></p>
</blockquote>
<blockquote class="doxtable">
<p><b>NOTICE FOR FUTURE RELEASES: AVOID CHANGING THE NUMBERING!</b> The tests refer to the sections, incl. links and unlinked references from tests or other parts of the specification. These break, or even worse become wrong, when they are not changed consistenty! </p>
</blockquote>
<h1><a class="anchor" id="spec_execptionHandling_intro"></a>
A. Introduction</h1>
<ul>
<li>1. Exceptions are handled by ApplicationCore in a way that the application developer does not need to care much about it.</li>
<li>2. ChimeraTK::runtime_error exceptions are caught by the framework and are reported to the <a class="el" href="class_chimera_t_k_1_1_device_module.html">DeviceModule</a>.</li>
<li>3. The <a class="el" href="class_chimera_t_k_1_1_device_module.html">DeviceModule</a> handles this exception and periodically tries to reopen the device.</li>
<li>4. Communication with the faulty device is <em>skipped</em>, <em>frozen</em> or <em>delayed</em> until the device is functional again (see <a class="el" href="spec_execption_handling.html#spec_exceptionHandling_intro_terminology">A.9</a>).</li>
<li>5. In case of several devices only the faulty device is affected.</li>
<li>6. Faulty devices do not prevent the application from starting, only the parts of the application that depend on the fault device are waiting for the device to come up.</li>
<li>7. Input variables of ApplicationModules which cannot be read due to a faulty device will set and propagate the DataValidity::faulty flag (see also the <a class="el" href="spec_data_validity_propagation.html">Technical specification: data validity propagation</a>).</li>
<li>8. When the device becomes functional, it will be (re)initialised by using application-defined initialisation handlers and also recover the last known values of its process variables.</li>
</ul>
<h2><a class="anchor" id="spec_exceptionHandling_intro_terminology"></a>
A.9 Special terminology used in this document</h2>
<ul>
<li>9.1 A <em>read operation</em> might be <em>skipped</em>. It means there will be no new data because the operation will not take place at all. Instead, the <em>function called returns immediately</em> and data is marked as DataValidity::faulty. Note: This term is also used if there is no new data because a running operation is interrupted by an exception.</li>
<li><a class="anchor" id="a_9_2"></a>9.2 A <em>read operation</em> might be <em>frozen</em>. This means, the <em>function called will not return until the fault state is resolved</em> and the operation is executed. Freezing only happens on operations with a pre-existing fault state (*).</li>
<li>9.3 A <em>write operation</em> might be <em>delayed</em>. This means, the operation will not be executed immediately and <em>the calling thread continues</em>. The operation will be asynchronosuly executed when the fault state is resolved. Note that the VersionNumber specified in the write operation will be retained and also used for the delayed write operation.</li>
<li>9.4 Whenever a write operation or a call to write() is mentioned, destructive writes via writeDestructively() are included. The destructive write optimisation makes no difference for the exception handling.</li>
</ul>
<h2><a class="anchor" id="spec_exceptionHandling_intro_comments"></a>
(*) Comments</h2>
<ul>
<li><a class="el" href="spec_execption_handling.html#a_9_2">9.2</a> If the device was ok and an exception occurs during the operation, it will be skipped.</li>
</ul>
<h1><a class="anchor" id="spec_execptionHandling_behaviour"></a>
B. Behavioural description</h1>
<ul>
<li>1. All ChimeraTK::runtime_error exceptions thrown by device register accessors are handled by the framework and are never exposed to user code in ApplicationModules.<ul>
<li><a class="anchor" id="b_1_1"></a>1.1 ChimeraTK::logic_error exceptions are left unhandled and will terminate the application. These errors may only occur in the (re-)initialisation phase (up to the point where all devices are opened and initialised) and point to a severe configuration error which is not recoverable. <a class="el" href="spec_execption_handling.html#comment_b_1_1">(*)</a></li>
<li><a class="anchor" id="b_1_2"></a>1.2 <b>Exception handling and DataValidity flag propagation is implemented such that it is transparent to a module whether it is directly connected to a device, or whether a fanout or another application module is in between.</b> This is the central requirement from which most other requirements are derived.<ul>
<li><a class="anchor" id="b_1_2_1"></a>1.2.1 The only exception to this rule can occur if the application buffer is changed by the user code between two reads to a TransferElement, see <a class="el" href="spec_execption_handling.html#exceptionHandling_b_2_2_6">2.2.6</a>.</li>
</ul>
</li>
<li><a class="anchor" id="exceptionHandling_b_1_3"></a>1.3 boost::numeric::bad_numeric_cast exceptions are treated like ChimeraTK::logic_error. They originate from picking the wrong data type in the program code or the configuration and are also not recoverable by re-opening the device.</li>
<li><a class="anchor" id="exceptionHandling_b_1_4"></a>1.4 The only other exception allowed by the DeviceAccess::TransferElement specificaton is boost::thread_interrupted. It must not be caught by the exception handling decorator because it is used to cleanly shut down the application.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="spec_exceptionHandling_behaviour_runtime_errors"></a>
Runtime error handling</h2>
<ul>
<li><a class="anchor" id="b_2"></a>2. When a ChimeraTK::runtime_error has been received by the framework (thrown by a device register accessor):<ul>
<li><a class="anchor" id="exceptionHandling_b_2_1"></a>2.1 The exception status is published as a process variable together with an error message. [<a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_2_1">T</a>]<ul>
<li>2.1.1 The variable <code>Devices/&lt;alias&gt;/status</code> contains a boolean flag whether the device is in an error state.</li>
<li>2.1.2 The variable <code>Devices/&lt;alias&gt;/message</code> contains an error message, if the device is in an error state, or an empty string otherwise.</li>
</ul>
</li>
<li><a class="anchor" id="b_2_2"></a>2.2 Read operations will propagate the DataValidity::faulty flag to the owning module / fan out:<ul>
<li>2.2.1 The normal module algorithm code will be continued, to allow this flag to propagate to the outputs in the same way as if it had been received through the process variable itself (cf. <a class="el" href="spec_execption_handling.html#b_1_2">1.2</a>). [no test, just an intro]</li>
<li><a class="anchor" id="exceptionHandling_b_2_2_2"></a>2.2.2 The DataValidity::faulty flag resulting from the fault state is propagated once, even if the variable had the a DataValidity::faulty flag already set previously for another reason. [<a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_2_2_2_poll">T</a>, <a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_2_2_2_push">T</a>]</li>
<li><a class="anchor" id="exceptionHandling_b_2_2_3"></a>2.2.3 Read operations without AccessMode::wait_for_new_data are <em>skipped</em> until the device is fully recovered again (cf. <a class="el" href="spec_execption_handling.html#b_3_1">3.1</a>). The first skipped read operation will have a new VersionNumber. [<a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_2_2_3">T</a>, <a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_2_2_3_TrFO">T</a>]</li>
<li><a class="anchor" id="exceptionHandling_b_2_2_4"></a>2.2.4 Read operations with AccessMode::wait_for_new_data will be <em>skipped</em> once for each accessor to propagate the DataValidity::faulty flag (which counts as new data, i.e. readNonBlocking()/readLatest() will return true (= hasNewData), and a new VersionNumber is obtained) [<a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_2_2_4_blocking">T</a>, <a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_2_2_4_nonBlocking">T</a>, <a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_2_2_4_latest">T</a>, <a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_2_2_4_ThFO">T</a>, <a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_2_2_4_TrFO">T</a>]. Subsequently:<ul>
<li><a class="anchor" id="exceptionHandling_b_2_2_4_1"></a>2.2.4.1 non-blocking read operations (readNonBlocking() and readLatest()) are <em>skipped</em> and return false (= no new data), until the device is recovered [<a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_2_2_4_1_nonBlocking">T</a>, <a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_2_2_4_1_latest">T</a>], and</li>
<li><a class="anchor" id="exceptionHandling_b_2_2_4_2"></a>2.2.4.2 blocking read operations (read()) will be <em>frozen</em> until the device is recovered. [<a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_2_2_4_2">T</a>]</li>
<li><a class="anchor" id="exceptionHandling_b_2_2_4_3"></a>2.2.4.3 After the device is fully recovered (cf. <a class="el" href="spec_execption_handling.html#b_3_1">3.1</a>), the current value is (synchronously) read from the device. This is the first value received by the accessor after an exception. [<a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_2_2_4_3">T</a>]</li>
</ul>
</li>
<li><a class="anchor" id="exceptionHandling_b_2_2_5"></a>2.2.5 The VersionNumbers returned in case of an exception are the same for the same exception, even across variables and modules. It will be generated in the moment the exception is reported. <a class="el" href="spec_execption_handling.html#comment_b_2_2_5">(*)</a> [<a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_2_2_5">T</a>]</li>
<li><a class="anchor" id="exceptionHandling_b_2_2_6"></a>2.2.6 The data buffer is not updated. This guarantees that the data buffer stays on the last known value if the user code has not modified it since the last read. [<a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_2_2_6">T</a>]<ul>
<li>2.2.6.1 This is different to a working device or an implementation without exception handling, where a returning read() has overwritten the data content of the buffer. If an application requires the last read value in the data buffer, it must not change it in the user code. This is the only exception to the <em>golden rule</em> <a class="el" href="spec_execption_handling.html#b_1_2">1.2</a>. [No test, as out of scope]</li>
</ul>
</li>
</ul>
</li>
<li><a class="anchor" id="b_2_3"></a>2.3 Write operations will be <em>delayed</em> until the device is fully recovered again (cf. <a class="el" href="spec_execption_handling.html#b_3_1">3.1</a>).<ul>
<li><a class="anchor" id="exceptionHandling_b_2_3_1"></a>2.3.1 In case of a fault state (new or persisting), the actual write operation will take place asynchronously when the device is recovering. [tested by <a class="el" href="spec_execption_handling.html#exceptionHandling_b_3_1_2">3.1.2</a>]</li>
<li><a class="anchor" id="exceptionHandling_b_2_3_2"></a>2.3.2 The same mechanism as used for <a class="el" href="spec_execption_handling.html#exceptionHandling_b_3_1_2">3.1.2</a> is used here, hence the order of write operations is guaranteed across accessors, but only the latest written value of each accessor prevails. <a class="el" href="spec_execption_handling.html#comment_b_2_3_2">(*)</a> [tested by <a class="el" href="spec_execption_handling.html#exceptionHandling_b_3_1_2">3.1.2</a>]</li>
<li><a class="anchor" id="exceptionHandling_b_2_3_3"></a>2.3.3 The return value of write() indicates whether data was lost in the transfer. If the write has to be delayed due to an exception, the return value will be true (= data lost) if a previously delayed and not-yet written value is discarded in the process, false (= no data lost) otherwise. [<a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_2_3_3">T</a>]</li>
<li><a class="anchor" id="b_2_3_4"></a>2.3.4 When the delayed value is finally written to the device during the recovery procedure, the return value of the write() is ignored. <a class="el" href="spec_execption_handling.html#comment_b_2_3_4">(*)</a> [not testable]</li>
<li><a class="anchor" id="exceptionHandling_b_2_3_5"></a>2.3.5 It is guaranteed that the write takes place before the device is considered fully recovered again and other transfers are allowed (cf. <a class="el" href="spec_execption_handling.html#b_3_1">3.1</a>). [<a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_2_3_5">T</a>]</li>
<li><a class="anchor" id="exceptionHandling_b_2_3_6"></a>2.3.6 Write operations to registers of the type ChimeraTK::Void are not delayed. <a class="el" href="spec_execption_handling.html#comment_b_2_3_6">(*)</a> [tested by <a class="el" href="spec_execption_handling.html#exceptionHandling_b_3_1_2">3.1.2</a>]</li>
</ul>
</li>
<li><a class="anchor" id="b_2_4"></a>2.4 In case of exceptions, there is no guaranteed realtime behaviour, not even for "non-blocking" transfers. <a class="el" href="spec_execption_handling.html#comment_b_2_4">(*)</a> [not testable]</li>
<li><a class="anchor" id="exceptionHandling_b_2_5"></a>2.5 TransferElement::isReadable(), TransferElement::isWriteable() and TransferElement::isReadonly() return with values as if reading and writing would be allowed. <a class="el" href="spec_execption_handling.html#exceptionHandling_comment_b_2_5">(*)</a> [<a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_2_5">T</a>]</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="spec_execptionHandling_behaviour_recovery"></a>
Recovery</h2>
<ul>
<li>3. The framework tries to resolve an exception state by periodically re-opening the faulty device.<ul>
<li><a class="anchor" id="b_3_1"></a>3.1 After successfully re-opening the device, a recovery procedure is executed before allowing any read/write operations from the ApplicationModules and FanOuts again. This recovery procedure involves:<ul>
<li><a class="anchor" id="exceptionHandling_b_3_1_1"></a>3.1.1 the execution of so-called initialisation handlers (see <a class="el" href="spec_execption_handling.html#exceptionHandling_b_3_2">3.2</a>) [<a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_3_1_1">T</a>], and</li>
<li><a class="anchor" id="exceptionHandling_b_3_1_2"></a>3.1.2 restoring all registers that have been written since the start of the application with their latest values. The register values are restored in the same order they were written. Registers of the type ChimeraTK::Void are not written. <a class="el" href="spec_execption_handling.html#comment_b_3_1_2">(*)</a> [<a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_3_1_2">T</a>]</li>
<li><a class="anchor" id="exceptionHandling_b_3_1_3"></a>3.1.3 The asynchronous read transfers of the device are (re-)activated by calling Device::activateAsyncReads(). [<a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_3_1_3">T</a>]</li>
<li><a class="anchor" id="exceptionHandling_b_3_1_4"></a>3.1.4 Finally, <code>Devices/&lt;alias&gt;/deviceBecameFunctional</code> is written to inform any module subscribing to this variable about the finished recovery. <a class="el" href="spec_execption_handling.html#comment_b_3_1_4">(*)</a> [<a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_3_1_4">T</a>]</li>
</ul>
</li>
<li><a class="anchor" id="exceptionHandling_b_3_2"></a>3.2 Any number of initialisation handlers can be added to the <a class="el" href="class_chimera_t_k_1_1_device_module.html">DeviceModule</a> in the user code. Initialisation handlers are callback functions which will be executed when a device is opened for the first time and after a device recovers from an exception, before any application-initiated transfers are executed (including delayed write transfers). See <a class="el" href="class_chimera_t_k_1_1_device_module.html#a4a9e010d61ef112b7d688e72cbfc20a3">DeviceModule::addInitialisationHandler()</a>. [<a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_3_2">T</a>]</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="spec_execptionHandling_behaviour_startup"></a>
Startup</h2>
<ul>
<li>4. The behaviour at application start (at which all devices are still closed at first) is similar to the case of a later received exception. The only differences are mentioned in <a class="el" href="spec_execption_handling.html#b_4_2">4.2</a>.<ul>
<li><a class="anchor" id="exceptionHandling_b_4_1"></a>4.1 Even if some devices are initially in a persisting error state, the part of the application which does not interact with the faulty devices starts and works normally. [<a class="el" href="test_exception_handling_8cc.html#testExceptionHandling_b_4_1">T</a>]</li>
<li><a class="anchor" id="b_4_2"></a>4.2 Initial values are correctly propagated after a device is opened. See the <a class="el" href="spec_initial_value_propagation.html">Technical specification: propagation of initial values</a>. Especially, all read operations (even readNonBlocking/readLatest or without AccessMode::wait_for_new_data) will be <em>frozen</em> until an initial value has been successfully read. <a class="el" href="spec_execption_handling.html#comment_b_4_2">(*)</a> [test in other spec]</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="spec_execptionHandling_behaviour_forced_recovery"></a>
Forced Recovery</h2>
<ul>
<li><a class="anchor" id="b_5"></a>5. Any <a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a> can explicitly report a problem with the device by calling <a class="el" href="class_chimera_t_k_1_1_device_module.html#a866cf974d4a178d389753536be5a88db" title="Use this function to report an exception.">DeviceModule::reportException()</a>. This allows the reinitialisation of a device e.g. after a reboot of the device which didn't result in an exception (e.g. because it was too quick to be noticed, or rebooting the device takes place without interrupting the communication).</li>
</ul>
<h2><a class="anchor" id="spec_execptionHandling_behaviour_comments"></a>
(*) Comments</h2>
<ul>
<li><a class="anchor" id="comment_b_1_1"></a><a class="el" href="spec_execption_handling.html#b_1_1">1.1</a> In future, maybe logic_errors are also handled, so configuration errors can nicely be presented to the control system. This may be important especially since logic_errors may depend also on the configuration of external components (devices). If e.g. a device is changed (e.g. device is another control system application which has been modified), logic_errors may be thrown in the recovery phase, despite the device had been successfully initialsed previously.</li>
<li><a class="anchor" id="comment_b_2_2_5"></a><a class="el" href="spec_execption_handling.html#exceptionHandling_b_2_2_5">2.2.5</a> Without changing the VersionNumber, the faulty-marked data might get correlated with good data (e.g. a trigger number which is also used as a trigger to read data from the device), resulting in marking the originally good data as faulty, just because an exception has been received <em>after</em> the good data was processed. Using a VersionNumber generated when reporting the exception ensures that the VersionNumber is older than any data read from the device after recovery. There might still be a race condition if a trigger is delayed for some reason for the entire time of detecting and reporting an exception and recovering the device, in which case the trigger number is older than the exception, but the data is still newer and shouldn't really be correlated with the trigger any more. Since ApplicationModules will always use the newest VersionNumber of its inputs, in this case the VersionNumber from the exception will still be used, which is not ideal but should merely prevent the correlation of the data with other data.</li>
<li><a class="anchor" id="comment_b_2_3_2"></a><a class="anchor" id="comment_b_3_1_4"></a><a class="el" href="spec_execption_handling.html#exceptionHandling_b_2_3_2">2.3.2</a> / <a class="el" href="spec_execption_handling.html#exceptionHandling_b_3_1_4">3.1.4</a> If timing is important for write operations (e.g. must not write a sequence of registers too fast), or if multiple values need to be written to the same register in sequence, the application cannot fully rely on the framework's recovery procedure. The framework hence provides the process variable <code>Devices/&lt;alias&gt;/deviceBecameFunctional</code> for each device, which will be written each time the recovery procedure is completed (cf. <a class="el" href="spec_execption_handling.html#exceptionHandling_b_3_1_4">3.1.4</a>). ApplicationModules which implement such timed sequence need to receive this variable and restart the entire sequence after the recovery.</li>
<li><a class="anchor" id="comment_b_2_3_4"></a><a class="el" href="spec_execption_handling.html#b_2_3_4">2.3.4</a> The TransferElement specification B.7.2 guarantees that only old data may be lost in a write transfer, hence the latest data is guaranteed to be written to the device during recovery.</li>
<li><a class="anchor" id="comment_b_2_3_6"></a><a class="el" href="spec_execption_handling.html#exceptionHandling_b_2_3_6">2.3.6</a> Void-typed registers trigger actions and do not carry data. Hence no value can be restored, but instead an action would be triggered which is usually unwanted at the time of recovery (e.g. board reset). If the action is explicitly wanted during recovery, it can be triggered in the recovery handler instead.</li>
<li><a class="anchor" id="comment_b_2_4"></a><a class="el" href="spec_execption_handling.html#b_2_4">2.4</a> Even read without wait_for_new_data and write operations are not truely non-blocking, since they are still synchronous. The "non-blocking" guarantee only means that the operation does not block until new data has arrived, and that it is not frozen until the device is recovered. For the duration of the recovery procedure and of course for timeout periods these operations may still block. readNonBlocking() and readLatest() with wait_for_new_data could in theory be truely lock-free and wait-free, but the synchronisation mechanism in case of exceptions are not implemented as such. In case of exceptions, the application usually anway does not behave normally any more. If needed, this limitation could be lifted with a more complicated implementation in the future.</li>
<li><a class="anchor" id="exceptionHandling_comment_b_2_5"></a><a class="el" href="spec_execption_handling.html#exceptionHandling_b_2_5">2.5</a> These functions can throw runtime errors if the behaviour has to be determined from the running device. In this case readability and writeability can change on the device (cf. <a href="https://chimeratk.github.io/DeviceAccess/master/spec__transfer_element.html">TransferElement specification</a> C.5.3). Suppressing the exception and allowing the operation does not pose the risk of getting a ChimeraTK::logic_error in the preXxx() phase of the operation because all transfer elements are tested for this during device recovery (cf. <a class="el" href="spec_execption_handling.html#exceptionHandling_c_3_3_3">C.3.3.3</a>).</li>
<li><a class="anchor" id="comment_b_3_1_2"></a><a class="el" href="spec_execption_handling.html#exceptionHandling_b_3_1_2">3.1.2</a> For some applications, the order of writes may be important, e.g. if firmware expects this. Please note that the VersionNumber is insufficient as a sorting criteria, since many writes may have been done with the same VersionNumber (in an <a class="el" href="class_chimera_t_k_1_1_application_module.html">ApplicationModule</a>, the VersionNumber used for the writes is determined by the largest VersionNumber of the inputs).</li>
<li><a class="anchor" id="comment_b_4_2"></a><a class="el" href="spec_execption_handling.html#b_4_2">4.2</a> DataValidity::faulty is initially set by default, so there is no need to propagate this flag initially. To prevent race conditions and undefined behaviour (especially in automated tests), it even needs to be made sure that the flag is not propagated unnecessarily. The behaviour of non-blocking reads presents a slight asymmetry between the initial device opening and a later recovery. This will in particular be visible when restarting a server while a device is offline. If a module only uses readLatest()/readNonBlocking() (= read() for poll-type inputs) for the offline device, the module was still running before the server restart using the last known values for the dysfunctional registers (and flagging all outputs as faulty). After the restart, the module has to wait for the initial value and hence will not run until the device becomes functional again. To make this behaviour symmetric, one would need to persist the values of device inputs. Since this only affects a corner case in which likely no usable output is produced anyway, this slight inconsistency is considered acceptable.</li>
</ul>
<h1><a class="anchor" id="spec_execptionHandling_high_level_implmentation"></a>
C. Implementation</h1>
<p>A so-called <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application.">ExceptionHandlingDecorator</a> is placed around all device register accessors (used in ApplicationModules and FanOuts). It is responsible for catching the exceptions and implementing most of the behaviour described in <a class="el" href="spec_execption_handling.html#b_2">B.2</a>, and its implementation is described in <a class="el" href="spec_execption_handling.html#spec_execptionHandling_high_level_implmentation_decorator">C.2</a>. It has to work closely with the <a class="el" href="class_chimera_t_k_1_1_device_module.html">DeviceModule</a> and there is a complex synchronisation and locking scheme, which is described in <a class="el" href="spec_execption_handling.html#spec_execptionHandling_high_level_implmentation_interface">C.1</a>. The sequence executed in the <a class="el" href="class_chimera_t_k_1_1_device_module.html">DeviceModule</a> is described in <a class="el" href="spec_execption_handling.html#spec_execptionHandling_high_level_implmentation_deviceModule">C.3</a>.</p>
<h2><a class="anchor" id="spec_execptionHandling_high_level_implmentation_interface"></a>
C.1 Internal interface between ExceptionHandlingDecorator and DeviceModule</h2>
<p>Note: This section defines the internal interface on a low level. Helper functions, like getters and setters, are intenionally not mentioned here, since those are (in this context) unimportant details which can be chosen at will to structure the code conveniently. The entire interface between the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application.">ExceptionHandlingDecorator</a> and the <a class="el" href="class_chimera_t_k_1_1_device_module.html">DeviceModule</a> should be protected and the two classes should be friends, to prevent interference with the interface from other entities. Only <a class="el" href="class_chimera_t_k_1_1_device_module.html#a866cf974d4a178d389753536be5a88db" title="Use this function to report an exception.">DeviceModule::reportException()</a> is public, see <a class="el" href="spec_execption_handling.html#b_5">B.5</a>.</p>
<ul>
<li>1.1 The boolean flag DeviceModule::deviceHasError<ul>
<li>1.1.1 is used by the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application.">ExceptionHandlingDecorator</a> to detect prevailing error conditions, to know when transfers have to be skipped or delayed (cf. <a class="el" href="spec_execption_handling.html#c_2_4">2.4</a>).</li>
<li>1.1.2 The access is protected by the DeviceModule::errorMutex:<ul>
<li>shared lock allows to read</li>
<li>unique lock allows to read and write</li>
</ul>
</li>
</ul>
</li>
<li><a class="anchor" id="c_1_2"></a>1.2 The atomic DeviceModule::synchronousTransferCounter <a class="el" href="spec_execption_handling.html#comment_c_1_2">(*)</a><ul>
<li>1.2.1 tracks the number of on-going synchronous transfers, and</li>
<li>1.2.2 is used by the <a class="el" href="class_chimera_t_k_1_1_device_module.html">DeviceModule</a> to wait until they are all terminated (<a class="el" href="spec_execption_handling.html#c_3_3_15">3.3.15</a>).</li>
</ul>
</li>
<li><a class="anchor" id="c_1_3"></a>1.3 The elements of the DeviceModule::recoveryHelpers list<ul>
<li>1.3.1 are used to delay write operations and to restore the last-written values during recovery.</li>
<li><a class="anchor" id="c_1_3_2"></a>1.3.2 are protected by the DeviceModule::recoveryMutex:<ul>
<li>shared lock allows to update the application buffer of <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#a1c13eb170308c756b559d46c35681d14">RecoveryHelper::accessor</a> and to update the other members of the <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html" title="A Helper struct to store an accessor and a version number.">RecoveryHelper</a> structure <a class="el" href="spec_execption_handling.html#comment_c_1_3_2">(*)</a></li>
<li>unique lock allows to call RecoveryHelper::accessor.write() and to read/write the other members of the <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html" title="A Helper struct to store an accessor and a version number.">RecoveryHelper</a> structure</li>
</ul>
</li>
</ul>
</li>
<li>1.4 The cppext::future_queue DeviceModule::errorQueue<ul>
<li>1.4.1 is used by the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application.">ExceptionHandlingDecorator</a> to inform the <a class="el" href="class_chimera_t_k_1_1_device_module.html">DeviceModule</a> about new exceptions.</li>
</ul>
</li>
<li>1.5 DeviceModule::listOfReadRegisters resp. DeviceModule::listOfWriteRegisters<ul>
<li>1.5.1 are used to check that all used registers are existing and have the right direction after (re-)opening the device.</li>
<li>1.5.2 No lock for accessing is required, since the lists are filled in the constructors of the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application.">ExceptionHandlingDecorator</a> and in the following only used by the <a class="el" href="class_chimera_t_k_1_1_device_module.html">DeviceModule</a> thread.</li>
</ul>
</li>
<li>1.6 The following mutexes govern critical sections (besides variable access listed above):<ul>
<li><a class="anchor" id="c_1_6_1"></a>1.6.1 DeviceModule::errorMutex protects <a class="el" href="spec_execption_handling.html#comment_c_1_6_1">(*)</a><ul>
<li>the (positive) decision to start a transfer followed by incrementing the DeviceModule::synchronousTransferCounter in <a class="el" href="spec_execption_handling.html#c_2_4_3">2.4.3</a> to <a class="el" href="spec_execption_handling.html#c_2_4_5">2.4.5</a>, against</li>
<li>setting DeviceModule::deviceHasError flag in <a class="el" href="spec_execption_handling.html#c_2_7_1">2.7.1</a>.</li>
</ul>
</li>
<li><a class="anchor" id="c_1_6_2"></a>1.6.2 DeviceModule::recoveryMutex protects <a class="el" href="spec_execption_handling.html#comment_c_1_6_2">(*)</a><ul>
<li>writing the DeviceModule::recoveryHelpers to the device and clearing the DeviceModule::deviceHasError flag in <a class="el" href="spec_execption_handling.html#c_3_3_6">3.3.6</a> to <a class="el" href="spec_execption_handling.html#c_3_3_7">3.3.7</a>, against</li>
<li>updating the DeviceModule::recoveryHelpers in <a class="el" href="spec_execption_handling.html#c_2_2">2.2</a> and deciding whether to skip the write operation in <a class="el" href="spec_execption_handling.html#c_2_4">2.4</a>.</li>
</ul>
</li>
<li><a class="anchor" id="c_1_6_3"></a>1.6.3 DeviceModule::initialValueMutex protects <a class="el" href="spec_execption_handling.html#comment_c_1_6_3">(*)</a><ul>
<li>the start of a read operation of an initial value in <a class="el" href="spec_execption_handling.html#c_2_3">2.3</a>, against</li>
<li>the setup phase of a device until it has been opened and recovered for the very first time in <a class="el" href="spec_execption_handling.html#c_3_1">3.1</a> to <a class="el" href="spec_execption_handling.html#c_3_3_10">3.3.10</a>.</li>
</ul>
</li>
</ul>
</li>
<li>1.7 The DeviceModule::exceptionVersionNumber<ul>
<li>1.7.1 is generated by <a class="el" href="class_chimera_t_k_1_1_device_module.html">DeviceModule</a>:reportException(), and</li>
<li>1.7.2 is used by the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application.">ExceptionHandlingDecorator</a> as VersionNumber for the propagation of the DataValidity::faulty flag after an exception.</li>
<li>1.7.3 The access is protected by the DeviceModule::errorMutex:<ul>
<li>shared lock allows to read</li>
<li>unique lock allows to read and write</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="spec_execptionHandling_high_level_implmentation_interface_comments"></a>
(*) Comments</h3>
<ul>
<li><a class="anchor" id="comment_c_1_2"></a><a class="el" href="spec_execption_handling.html#c_1_2">1.2</a> Reason for not using an (exclusive) lock: Incrementing and decrementing the counter is done in the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application.">ExceptionHandlingDecorator</a> for each operation, even if there is no exception or error state. Concurrent operations must not exclude each other, to allow lockfree operation in the no-exception case (if the backend supports it) and to avoid priority inversion, if different application threads have different priorities.</li>
<li><a class="anchor" id="comment_c_1_3_2"></a><a class="el" href="spec_execption_handling.html#c_1_3_2">1.3.2</a> A shared lock (in contrast to an exclusive lock) is used for the same reasons as in <a class="el" href="spec_execption_handling.html#c_1_2">1.2</a>. It might be confusing that in this case the shared lock is used for writing, while the exclusive lock is used for reading. The reason is that here each 'producer thread' is holding it's own buffer, so the producers don't interfere with each other. A single, separate reader thread however must access <em>all</em> buffers at once, and must lock out the producers with the exclusive lock (in contrast to <a class="el" href="spec_execption_handling.html#c_1_2">1.2</a>, where the mutex prodects a shared resource from concurrent writes).</li>
<li><a class="anchor" id="comment_c_1_6_1"></a><a class="el" href="spec_execption_handling.html#c_1_6_1">1.6.1</a> This prevents a race condition in <a class="el" href="spec_execption_handling.html#c_3_3_15">3.3.15</a>. If a (synchronous) transfer might be started after DeviceModule::deviceHasError has been set, the barrier for new transfers in <a class="el" href="spec_execption_handling.html#c_3_3_15">3.3.15</a> would not be effective and the transfer might be even executed only after the device has been re-openend (<a class="el" href="spec_execption_handling.html#c_3_3_1">3.3.1</a>) but before the recovery is complete.</li>
<li><a class="anchor" id="comment_c_1_6_2"></a><a class="el" href="spec_execption_handling.html#c_1_6_2">1.6.2</a> This prevents data loss due to a race condition. If the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application.">ExceptionHandlingDecorator</a> would update the corresponding DeviceModule::recoveryHelpers list entry only after it has been written to the device by the <a class="el" href="class_chimera_t_k_1_1_device_module.html">DeviceModule</a> thread in <a class="el" href="spec_execption_handling.html#c_3_3_6">3.3.6</a>, but the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application.">ExceptionHandlingDecorator</a> would decide not to execute the write operation (<a class="el" href="spec_execption_handling.html#c_2_4">2.4</a>) because the <a class="el" href="class_chimera_t_k_1_1_device_module.html">DeviceModule</a> thread has not yet cleared the error flag in <a class="el" href="spec_execption_handling.html#c_3_3_7">3.3.7</a>, the data would not be written to the device at all.</li>
<li><a class="anchor" id="comment_c_1_6_3"></a><a class="el" href="spec_execption_handling.html#c_1_6_3">1.6.3</a> This implements freezing reads until the initial value can be read, cf. <a class="el" href="spec_execption_handling.html#b_4_2">B.4.2</a>.</li>
</ul>
<h2><a class="anchor" id="spec_execptionHandling_high_level_implmentation_decorator"></a>
C.2 ExceptionHandlingDecorator</h2>
<h3><a class="anchor" id="spec_execptionHandling_high_level_implmentation_decorator_structure"></a>
Structure</h3>
<ul>
<li><a class="anchor" id="c_2_1"></a>2.1 A second, undecorated copy of each writeable device register accessor <a class="el" href="spec_execption_handling.html#comment_c_2_1">(*)</a>, the so-called recovery accessor, is stored in the DeviceModule::recoveryHelpers. These recoveryHelpers are used to set the initial values of registers when the device is opened for the first time and to recover the last written values during the recovery procedure.<ul>
<li><a class="anchor" id="c_2_1_1"></a>2.1.1 The DeviceModule::recoveryHelpers is a list of <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html" title="A Helper struct to store an accessor and a version number.">RecoveryHelper</a> objects, which each contain:<ul>
<li><a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#a1c13eb170308c756b559d46c35681d14">RecoveryHelper::accessor</a>, the recovery accessor itself,</li>
<li><a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#ac4c488a3aecf5f363b46f15c26b566ee">RecoveryHelper::versionNumber</a>, the VersionNumber of the (potentially unwritten) data stored in the value buffer of the accessor,</li>
<li><a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#a02f305373033ff9001e294b6fe15c1bd">RecoveryHelper::writeOrder</a>, an ordering parameter which determines the order of write opereations during recovery.</li>
<li><a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#acb690e93ebfcb0bc7d49b4ea16344637">RecoveryHelper::wasWritten</a>, a flag which indicates whether the data in the value buffer of the <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#a1c13eb170308c756b559d46c35681d14">RecoveryHelper::accessor</a> has already been written to the device. <a class="el" href="spec_execption_handling.html#comment_c_2_1_1">(*)</a></li>
</ul>
</li>
<li><a class="anchor" id="c_2_1_2"></a>2.1.2 Ordering can be done per device <a class="el" href="spec_execption_handling.html#comment_c_2_1_2">(*)</a>, hence each <a class="el" href="class_chimera_t_k_1_1_device_module.html">DeviceModule</a> has one 64-bit atomic counter DeviceModule::writeCounter which is incremented for each write operation and the value is stored in <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#a02f305373033ff9001e294b6fe15c1bd">RecoveryHelper::writeOrder</a>.<ul>
<li>2.1.2.1 The writeOrder of each <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html" title="A Helper struct to store an accessor and a version number.">RecoveryHelper</a> is initialised with 0, which means "not written yet".</li>
<li>2.1.2.2 The first writeOrder that is given out by the <a class="el" href="class_chimera_t_k_1_1_device_module.html">DeviceModule</a> is 1.</li>
</ul>
</li>
<li>2.1.3 The <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html" title="A Helper struct to store an accessor and a version number.">RecoveryHelper</a> objects may be accessed only under a lock, see <a class="el" href="spec_execption_handling.html#c_1_3">1.3</a>.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="spec_execptionHandling_high_level_implmentation_decorator_behaviour"></a>
Behaviour</h3>
<ul>
<li><a class="anchor" id="c_2_2"></a>2.2 In doPreWrite() the <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html" title="A Helper struct to store an accessor and a version number.">RecoveryHelper</a> is updated while holding a shared lock on DeviceModule::recoveryMutex:<ul>
<li><a class="anchor" id="c_2_2_1"></a>2.2.1 These steps need to be done unconditionally at the very beginning of doPreWrite(), before <a class="el" href="spec_execption_handling.html#c_2_4">2.4</a> and before delegating to preWrite(). <a class="el" href="spec_execption_handling.html#comment_c_2_2_1">(*)</a></li>
<li>2.2.2 If the <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#acb690e93ebfcb0bc7d49b4ea16344637">RecoveryHelper::wasWritten</a> flag was previously not set and the writeOrder is not 0 any more, the return value of doWriteTransfer() must be forced to true (data lost).</li>
<li>2.2.3 Update the value buffer of the <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#a1c13eb170308c756b559d46c35681d14">RecoveryHelper::accessor</a>, update the <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#ac4c488a3aecf5f363b46f15c26b566ee">RecoveryHelper::versionNumber</a>, set the <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#a02f305373033ff9001e294b6fe15c1bd">RecoveryHelper::writeOrder</a> to the DeviceModule::writeCounter after (atomically) incrementing it, and clear the <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#acb690e93ebfcb0bc7d49b4ea16344637">RecoveryHelper::wasWritten</a> flag. (cf. <a class="el" href="spec_execption_handling.html#b_2_3">b_2_3</a>)</li>
<li><a class="anchor" id="c_2_2_4"></a>2.2.4 The check whether to execute the transfer (cf. <a class="el" href="spec_execption_handling.html#c_2_4">2.4</a>) has to be done without releasing the lock between the update of the <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html" title="A Helper struct to store an accessor and a version number.">RecoveryHelper</a> and the check. <a class="el" href="spec_execption_handling.html#comment_c_2_2_4">(*)</a></li>
</ul>
</li>
<li><a class="anchor" id="c_2_3"></a>2.3 In doPreRead() it is checked if the transfer element has seen an initial value by checking whether the current version number is still {nullptr} (cf. <a class="el" href="spec_execption_handling.html#b_4_2">B.4.2</a>)<ul>
<li>2.3.1 This is done as the first thing unconditionally for all read types, as no read must return with the "value after constuction". (For further details, see the <a class="el" href="spec_initial_value_propagation.html">intial value propagation specfication</a>)</li>
<li><a class="anchor" id="c_2_3_2"></a>2.3.2 If there has not been an initial value yet, the read is frozen by acquiring a shared lock on the DeviceModule::initialValueMutex. <a class="el" href="spec_execption_handling.html#comment_c_2_3_2">(*)</a></li>
<li><a class="anchor" id="c_2_3_3"></a>2.3.3 As soon as the lock has been acquired it can be released immediately. The device should now be functional and an initial value can be read. <a class="el" href="spec_execption_handling.html#comment_c_2_3_3">(*)</a></li>
<li>2.3.4 A check whether to freeze for a recovery of asynchronous transfers as rescribed in <a class="el" href="spec_execption_handling.html#exceptionHandling_b_2_2_4">B.2.2.4</a> is not done in doPreRead(). The backend takes care of this and the operation automatically freezes when waiting for data from the decorated transfer element, and resumes once the backend starts sending data again. There is nothing extra to do for the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application.">ExceptionHandlingDecorator</a> in this case.</li>
<li><a class="anchor" id="c_2_3_5"></a>2.3.5 The lock on the DeviceModule::errorMutex must not be held in this step to prevent dead-lock with the DeviceModule::initialValueMutex. <a class="el" href="spec_execption_handling.html#comment_c_2_3_5">(*)</a></li>
</ul>
</li>
<li><a class="anchor" id="c_2_4"></a>2.4 In doPreRead()/doPreWrite(), it is decided whether to execute the target's transfer.<ul>
<li><a class="anchor" id="c_2_4_1"></a>2.4.1 This is only applicable to read operations without AccessMode::wait_for_new_data, and to write operations <a class="el" href="spec_execption_handling.html#comment_c_2_4_1">(*)</a>.</li>
<li>2.4.2 This part requires a shared lock on the DeviceModule::errorMutex.</li>
<li><a class="anchor" id="c_2_4_3"></a>2.4.3 Transfers are only executed if DeviceModule::deviceHasError == false (cf. <a class="el" href="spec_execption_handling.html#b_2_3">B.2.3</a> and <a class="el" href="spec_execption_handling.html#exceptionHandling_b_2_2_3">B.2.2.3</a>).</li>
<li>2.4.4 If a transfer is not executed, none of the pre/transfer/post functions must be delegated to the target accessor.</li>
<li><a class="anchor" id="c_2_4_5"></a>2.4.5 If the transfer is executed, the DeviceModule::synchronousTransferCounter must be incremented.</li>
<li><a class="anchor" id="c_2_4_6"></a>2.4.6 To prevent the execution of the transfer, a ChimeraTK::runtime_error is thrown before calling _target::preXxx() <a class="el" href="spec_execption_handling.html#exceptionHandling_comment_c_2_4_6">(*)</a>.<ul>
<li><a class="anchor" id="c_2_4_6_1"></a>2.4.6.1 The <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application.">ExceptionHandlingDecorator</a> remembers that it raised the exception, so in doPostXxx it does not call _target::postXxx(), (c.f. <a class="el" href="spec_execption_handling.html#c_2_6_1">2.6.1</a>).</li>
</ul>
</li>
</ul>
</li>
<li><a class="anchor" id="c_2_5"></a>2.5 <em>deleted</em></li>
<li>2.6 In doPostRead()/doPostWrite():<ul>
<li><a class="anchor" id="c_2_6_1"></a>2.6.1 Delegate to postRead() / postWrite() (see <a class="el" href="spec_execption_handling.html#c_2_7">2.7</a>), if there was no exception raised by the ExceptionHandling decorator itself (see <a class="el" href="spec_execption_handling.html#c_2_4_6_1">2.4.6.1</a>).</li>
<li><a class="anchor" id="c_2_6_2"></a>2.6.2 In doPostWrite() the <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#acb690e93ebfcb0bc7d49b4ea16344637">RecoveryHelper::wasWritten</a> flag is set (while holding a shared lock on DeviceModule::recoveryMutex) if the write was successful (no exception thrown; data lost flag does not matter here). <a class="el" href="spec_execption_handling.html#comment_c_2_6_2">(*)</a></li>
<li><a class="anchor" id="c_2_6_3"></a>2.6.3 If the DeviceModule::synchronousTransferCounter was incremented in <a class="el" href="spec_execption_handling.html#c_2_4_5">2.4.5</a>, decrement it. <a class="el" href="spec_execption_handling.html#comment_c_2_6_3">(*)</a></li>
<li><a class="anchor" id="c_2_6_4"></a>2.6.4 In doPostRead(), _dataValidity and _versionNumber are set to<ul>
<li>DataValidity::faulty and DeviceModule::exceptionVersionNumber, respectively, if an exception was thrown in <a class="el" href="spec_execption_handling.html#c_2_4_6">2.4.6</a> to prevent the transfer, or caught from the delegated postXxx() (see <a class="el" href="spec_execption_handling.html#c_2_7">2.7</a>)</li>
<li>the target's data validity and version number, respectively, in all other cases</li>
</ul>
</li>
</ul>
</li>
<li><a class="anchor" id="c_2_7"></a>2.7 In doPostRead()/doPostWrite(), any ChimeraTK::runtime_error exception thrown by the delegated postRead()/postWrite() is caught <a class="el" href="spec_execption_handling.html#comment_c_2_7">(*)</a>. The following actions are executed in case of a ChimeraTK::runtime_error:<ul>
<li><a class="anchor" id="c_2_7_1"></a>2.7.1 The error is reported to the <a class="el" href="class_chimera_t_k_1_1_device_module.html">DeviceModule</a> via <a class="el" href="class_chimera_t_k_1_1_device_module.html#a866cf974d4a178d389753536be5a88db" title="Use this function to report an exception.">DeviceModule::reportException()</a> (cf. <a class="el" href="spec_execption_handling.html#spec_execptionHandling_high_level_implmentation_reportException">C.4</a>). This automatically sets DeviceModule::deviceHasError to true. From this point on, no new transfers will be started. <a class="el" href="spec_execption_handling.html#comment_c_2_7_1">(*)</a></li>
</ul>
</li>
<li>2.8 The constructor of the decorator<ul>
<li>2.8.1 receives the <a class="el" href="class_chimera_t_k_1_1_variable_network_node.html" title="Class describing a node of a variable network.">VariableNetworkNode</a> for the device variable, to enable it to create additional, undecorated copies of the register accessor,</li>
<li>2.8.2 puts the name of the register (from the <a class="el" href="class_chimera_t_k_1_1_variable_network_node.html" title="Class describing a node of a variable network.">VariableNetworkNode</a>) to DeviceModule::listOfReadRegisters resp. DeviceModule::listOfWriteRegisters depending on the direction the accessor is used, and</li>
<li>2.8.3 creates the recovery accessor and initialises the <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html" title="A Helper struct to store an accessor and a version number.">RecoveryHelper</a> object.</li>
<li>2.8.4 Note: The alias name of the device can be obtained from the <a class="el" href="class_chimera_t_k_1_1_variable_network_node.html" title="Class describing a node of a variable network.">VariableNetworkNode</a>, which allows to obtain the corresponding <a class="el" href="class_chimera_t_k_1_1_device_module.html">DeviceModule</a> via Application::deviceModuleList (change the list into a map).</li>
<li>2.8.5 The code instantiating the decorator (Application::createDeviceVariable()) makes sure that the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application.">ExceptionHandlingDecorator</a> is "inside" the <a class="el" href="class_chimera_t_k_1_1_meta_data_propagating_register_decorator.html" title="NDRegisterAccessorDecorator which propagates meta data attached to input process variables through th...">MetaDataPropagatingRegisterDecorator</a>, so in case of an exception the dataValidity flag is properly propagated to the owning module/fan out (cf. <a class="el" href="spec_execption_handling.html#c_2_6_4">2.6.4</a>).</li>
</ul>
</li>
<li><a class="anchor" id="c_2_9"></a>2.9 When a ChimeraTK::runtime_error is caught in isReadable(), isWriteable() or isReadOnly(), the <a class="el" href="class_chimera_t_k_1_1_device_module.html">DeviceModule</a> is informed via <a class="el" href="class_chimera_t_k_1_1_device_module.html#a866cf974d4a178d389753536be5a88db" title="Use this function to report an exception.">DeviceModule::reportException()</a>.</li>
</ul>
<h3><a class="anchor" id="spec_execptionHandling_high_level_implmentation_decorator_comments"></a>
(*) Comments</h3>
<ul>
<li><a class="anchor" id="comment_c_2_1"></a><a class="el" href="spec_execption_handling.html#c_2_1">2.1</a> Possible future change: Output accessors can have the option not to have a <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html" title="A Helper struct to store an accessor and a version number.">RecoveryHelper</a>. This is needed for instance for "trigger registers" which start an operation on the hardware. Also void registers don't have a <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html" title="A Helper struct to store an accessor and a version number.">RecoveryHelper</a> (once the void data type is supported by <a class="el" href="namespace_chimera_t_k.html" title="InvalidityTracer application module.">ChimeraTK</a>).</li>
<li><a class="anchor" id="comment_c_2_1_1"></a><a class="el" href="spec_execption_handling.html#c_2_1_1">2.1.1</a> The written flag cannot be replaced by comparing RecoveryHelper::accessor.getCurrentVersion() and <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#ac4c488a3aecf5f363b46f15c26b566ee">RecoveryHelper::versionNumber</a>, because normal writes (without exceptions) would not update the version number of the <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#a1c13eb170308c756b559d46c35681d14">RecoveryHelper::accessor</a>. The written flag could also be made atomic to avoid acquiring the shared lock in postWrite(), but since the shared lock will never block (if acquired before counting down the DeviceModule::synchronousTransferCounter) there is probably no benifit in using an atomic here.</li>
<li><a class="anchor" id="comment_c_2_1_2"></a><a class="el" href="spec_execption_handling.html#c_2_1_2">2.1.2</a> The ordering guarantee cannot work across DeviceModules anyway. Different devices may go offline and recover at different times. Even in case of two DeviceModules which actually refer to the same hardware device there is no synchronisation mechanism which ensures the recovering procedure is done in a defined order.</li>
<li><a class="anchor" id="comment_c_2_2_1"></a><a class="el" href="spec_execption_handling.html#c_2_2_1">2.2.1</a> Updating the recoveryHelper first ensures that no data is lost, even if the write operation attempt is concurrent with a recovery. See <a class="el" href="spec_execption_handling.html#c_1_6_2">1.6.2</a>.</li>
<li><a class="anchor" id="comment_c_2_2_4"></a><a class="el" href="spec_execption_handling.html#c_2_2_4">2.2.4</a> Extending the duration of the lock until the decision whether to skip the transfer will prevent unncessary duplicate writes, which otherwise could occur if the <a class="el" href="class_chimera_t_k_1_1_device_module.html">DeviceModule</a> went through the whole critical section <a class="el" href="spec_execption_handling.html#c_3_3_5">3.3.5</a> to <a class="el" href="spec_execption_handling.html#c_3_3_8">3.3.8</a> in between. Two mutexes have to be shared-locked in <a class="el" href="spec_execption_handling.html#c_2_4">2.4</a> then at the same time (DeviceModule::recoveryMutex and DeviceModule::errorMutex, which is acquired second). This does not present any risk of dead locks, since the only place where the DeviceModule::errorMutex is unique-locked (see <a class="el" href="class_chimera_t_k_1_1_device_module.html#a866cf974d4a178d389753536be5a88db" title="Use this function to report an exception.">DeviceModule::reportException()</a>) no other mutex is acquired.</li>
<li><a class="anchor" id="comment_c_2_3_2"></a><a class="el" href="spec_execption_handling.html#c_2_3_2">2.3.2</a> In principle just getting and releasing the shared lock on DeviceModule::initialValueMutex unconditionally would be a sufficient implementation. The version number cannot be valid if the lock cannot be acquired yet, and after this the exclusive lock is never acquired again after it has been relased in <a class="el" href="spec_execption_handling.html#c_3_3_10">3.3.10</a>. However, checking the version number is probably cheaper than acquiring the lock in each doPreRead().</li>
<li><a class="anchor" id="comment_c_2_3_3"></a><a class="el" href="spec_execption_handling.html#c_2_3_3">2.3.3</a> There is one situation where the data content of the "value after construction" is propagated: If the device, which was functional when leaving <a class="el" href="spec_execption_handling.html#c_2_3">2.3</a> but is broken already in <a class="el" href="spec_execption_handling.html#c_2_4">2.4</a>, or an exception is received while getting the initial value, the operation is skipped. It returns with the data invalid flag, but there never was a valid intial value before. This can only happen if there are exceptions on the device, never at the normal start of the application with working devices.</li>
<li><a class="anchor" id="comment_c_2_3_5"></a><a class="el" href="spec_execption_handling.html#c_2_3_5">2.3.5</a> If the shared lock on the DeviceModule::errorMutex would be held while waiting for the shared lock for the DeviceModule::initialValueMutex it would dead-lock with the <a class="el" href="class_chimera_t_k_1_1_device_module.html">DeviceModule</a>, which needs the exclusive lock of DeviceModule::errorMutex to release the DeviceModule::initialValueMutex in <a class="el" href="spec_execption_handling.html#c_3_3_10">3.3.10</a>. The only thing that can happend by not having the DeviceModule::errorMutex is that in case of a device error the transfer is already skipped in <a class="el" href="spec_execption_handling.html#c_2_4">2.4</a> and not by an exception in the transfer.</li>
<li><a class="anchor" id="comment_c_2_4_1"></a><a class="el" href="spec_execption_handling.html#c_2_4_1">2.4.1</a> In case of read operations with AccessMode::wait_for_new_data, there is no doXxxTransferYyy() called by the TransferElement. The requirement in <a class="el" href="spec_execption_handling.html#exceptionHandling_b_2_2_4">B.2.2.4</a> is fullfilled by the backend implementations, see the TransferElement specification in DeviceAccess.</li>
<li><a class="anchor" id="exceptionHandling_comment_c_2_4_6"></a><a class="el" href="spec_execption_handling.html#c_2_4_6">2.4.6</a> The actual implementation to skip the transfer is done in the TransferElement and the TransferGroup. If the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application.">ExceptionHandlingDecorator</a> would implement it by overriding doXxxTransferYyy() it would not work for the TransferGroup, which instead calls the transfer function of the LowLevelTransferElement.</li>
<li><a class="anchor" id="comment_c_2_6_2"></a><a class="el" href="spec_execption_handling.html#c_2_6_2">2.6.2</a> The <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#acb690e93ebfcb0bc7d49b4ea16344637">RecoveryHelper::wasWritten</a> flag is used to report loss of data. If the loss of data is already reported directly, it should not later be reported again. Hence the written flag is set even if there was a loss of data in this context. Setting the flag is ideally done before decrementing the DeviceModule::synchronousTransferCounter in <a class="el" href="spec_execption_handling.html#c_2_6_3">2.6.3</a>, because this eliminates the possibility that acquiring the shared lock on the DeviceModule::recoveryMutex could block (exclusive lock is only acquired during recovery, which cannot start before DeviceModule::synchronousTransferCounter == 0)</li>
<li><a class="anchor" id="comment_c_2_6_3"></a><a class="el" href="spec_execption_handling.html#c_2_6_3">2.6.3</a> The state of DeviceModule::deviceHasError does not matter here. The counter always MUST be decreased after a transfer (if it has been incremented in the corresponding preXxx()), whether the transfer failed or not.</li>
<li><a class="anchor" id="comment_c_2_7"></a><a class="el" href="spec_execption_handling.html#c_2_7">2.7</a> Remember: exceptions from other phases are redirected to the post phase by the TransferElement base class.</li>
<li><a class="anchor" id="comment_c_2_7_1"></a><a class="el" href="spec_execption_handling.html#c_2_7_1">2.7.1</a> No transfers will be started in any of the accessors of the device, including this one. This is important to avoid the race condition described in the comment to <a class="el" href="spec_execption_handling.html#c_1_6_1">1.6.1</a></li>
</ul>
<h2><a class="anchor" id="spec_execptionHandling_high_level_implmentation_deviceModule"></a>
C.3 DeviceModule</h2>
<ul>
<li><a class="anchor" id="c_3_1"></a>3.1 The application always starts with all devices as closed. For each device, the initial value for <code>Devices/&lt;alias&gt;/status</code> is set to 1 and the initial value for <code>Devices/&lt;alias&gt;/message</code> is set to an error that the device has not been opened yet (the message will be overwritten with the real error message if the first attempt to open fails, see <a class="el" href="spec_execption_handling.html#c_3_3_1">3.3.1</a>).</li>
<li><a class="anchor" id="c_3_2"></a>3.2 The <a class="el" href="class_chimera_t_k_1_1_device_module.html">DeviceModule</a> locks the DeviceModule::initialValueMutex (cf. <a class="el" href="spec_execption_handling.html#c_2_3">2.3</a>). This happens before launching any module and fan out threads.</li>
<li>3.3 In the <a class="el" href="class_chimera_t_k_1_1_device_module.html">DeviceModule</a> thread, the following procedure is executed (in a loop until termination):<ul>
<li><a class="anchor" id="c_3_3_1"></a>3.3.1 The <a class="el" href="class_chimera_t_k_1_1_device_module.html">DeviceModule</a> tries to open the device until it succeeds and Device::isFunctional() returns true.<ul>
<li>3.3.1.1 If the very first attempt to open the device after the application start fails, the error message of the exception is used to overwrite the content of <code>Devices/&lt;alias&gt;/message</code>. Otherwise error messages of exceptions thrown by Device::open() are not visible.</li>
</ul>
</li>
<li><a class="anchor" id="c_3_3_2"></a>3.3.2 The queue of reported exceptions is cleared. <a class="el" href="spec_execption_handling.html#comment_c_3_3_2">(*)</a></li>
<li><a class="anchor" id="exceptionHandling_c_3_3_3"></a>3.3.3 Check that all registers on DeviceModule::listOfReadRegisters are isReadable() and all registers on DeviceModule::listOfWriteRegisters are isWriteable().<ul>
<li>3.3.3.1 This involves obtaining an accessor for the register first, which is discarded after the check.</li>
<li>3.3.3.2 If there is an exception, update <code>Devices/&lt;alias&gt;/message</code> with the error message and go back to <a class="el" href="spec_execption_handling.html#c_3_3_1">3.3.1</a>.</li>
<li>3.3.3.3 If one of the accessors does not meet this condition, throw a ChimeraTK::logic_error.</li>
</ul>
</li>
<li>3.3.4 The device is initialised by iterating DeviceModule::initialisationHandlers list and executing the functors.<ul>
<li>3.3.4.1 If there is an exception, update <code>Devices/&lt;alias&gt;/message</code> with the error message and go back to <a class="el" href="spec_execption_handling.html#c_3_3_1">3.3.1</a>.</li>
</ul>
</li>
<li><a class="anchor" id="c_3_3_5"></a>3.3.5 Obtain unique lock on DeviceModule::recoveryMutex.</li>
<li><a class="anchor" id="c_3_3_6"></a>3.3.6 Call write() on all valid <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#a1c13eb170308c756b559d46c35681d14">RecoveryHelper::accessor</a> using <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#ac4c488a3aecf5f363b46f15c26b566ee">RecoveryHelper::versionNumber</a>, in the ascending order of the <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#a02f305373033ff9001e294b6fe15c1bd">RecoveryHelper::writeOrder</a>.<ul>
<li>3.3.6.1 A <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#a1c13eb170308c756b559d46c35681d14">RecoveryHelper::accessor</a> is considered "valid", if it has already received a value, i.e. <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#ac4c488a3aecf5f363b46f15c26b566ee">RecoveryHelper::versionNumber</a> != {nullptr}</li>
<li>3.3.6.2 If there is an exception, update <code>Devices/&lt;alias&gt;/message</code> with the error message, release the lock and go back to <a class="el" href="spec_execption_handling.html#c_3_3_1">3.3.1</a>.</li>
<li>3.3.6.3 If successful, set <a class="el" href="struct_chimera_t_k_1_1_recovery_helper.html#acb690e93ebfcb0bc7d49b4ea16344637">RecoveryHelper::wasWritten</a> to true.</li>
</ul>
</li>
<li><a class="anchor" id="c_3_3_7"></a>3.3.7 While holding the DeviceModule::errorMutex: Clear the DeviceModule::deviceHasError flag to allow the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application.">ExceptionHandlingDecorator</a> to execute read/write operations again (cf. <a class="el" href="spec_execption_handling.html#c_3_3_13">3.3.13</a>)</li>
<li><a class="anchor" id="c_3_3_8"></a>3.3.8 Release lock on DeviceModule::recoveryMutex (was obtained in <a class="el" href="spec_execption_handling.html#c_3_3_5">3.3.5</a>).</li>
<li>3.3.9 (Re-)activate the asynchronous read transfers of the device by calling Device::activateAsyncRead().</li>
<li><a class="anchor" id="c_3_3_10"></a>3.3.10 Release the DeviceModule::initialValueMutex, if this point is passed for the very first time (was obtained in <a class="el" href="spec_execption_handling.html#c_3_2">3.2</a>, cf. <a class="el" href="spec_execption_handling.html#c_2_3">2.3</a>). <a class="el" href="spec_execption_handling.html#comment_c_3_3_10">(*)</a></li>
<li>3.3.11 <code>Devices/&lt;alias&gt;/status</code> is set to 0 and <code>Devices/&lt;alias&gt;/message</code> is set to an empty string. <code>Devices/&lt;alias&gt;/deviceBecameFunctional</code> is written.</li>
<li>3.3.12 The DeviceModuleThread waits for the next reported exception.</li>
<li><a class="anchor" id="c_3_3_13"></a>3.3.13 An exception is received. The call to reportException (cf. <a class="el" href="spec_execption_handling.html#spec_execptionHandling_high_level_implmentation_reportException">C.4</a>) in the other thread has already set deviceHasError to true <a class="el" href="spec_execption_handling.html#comment_c_3_3_13">(*)</a>. From this point on, no new transfers will be started.</li>
<li>3.3.14 <code>Devices/&lt;alias&gt;/status</code> is set to 1 and <code>Devices/&lt;alias&gt;/message</code> is set to the first received exception message.</li>
<li><a class="anchor" id="c_3_3_15"></a>3.3.15 The device module waits until all running synchronous read and write operations of ExceptionHandlingDecorators have ended (wait until DeviceModule::synchronousTransferCounter == 0). <a class="el" href="spec_execption_handling.html#comment_c_3_3_15">(*)</a></li>
<li>3.3.16 The thread goes back to <a class="el" href="spec_execption_handling.html#c_3_3_1">3.3.1</a> and tries to re-open the device.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="spec_execptionHandling_high_level_implmentation_deviceModule_comments"></a>
(*) Comments</h3>
<ul>
<li><a class="anchor" id="comment_c_3_3_2"></a><a class="el" href="spec_execption_handling.html#c_3_3_2">3.3.2</a> The exact place when this is done does not matter, as long as it is done after <a class="el" href="spec_execption_handling.html#c_3_3_15">3.3.15</a> (no ongoing synchronous transfers) and before <a class="el" href="spec_execption_handling.html#c_3_3_7">3.3.7</a> (resetting deciveHasError). As soon as DeviceModule::deviceHasError is cleared, new exceptions can be reported, which would be lost if the list was cleared afterwards. As <a class="el" href="class_chimera_t_k_1_1_device_module.html#a866cf974d4a178d389753536be5a88db" title="Use this function to report an exception.">DeviceModule::reportException()</a> will only write to the exception queue if DeviceModule::deviceHasError is true, and then sets DeviceModule::deviceHasError to true while holding a lock, there will only be one exception in the queue anyway. There are race conditions if exceptions reported by the backend from the same error arrive late. It can trigger a second, unnecessary recovery. But an exception cannot be missed if the error queue is cleared before resetting DeviceModule::deviceHasError.</li>
<li><a class="anchor" id="comment_c_3_3_10"></a><a class="el" href="spec_execption_handling.html#c_3_3_10">3.3.10</a> Releasing the DeviceModule::initialValueMutex has to happen after <a class="el" href="spec_execption_handling.html#c_3_3_7">3.3.7</a> (clearing DeviceModule::deviceHasError) to prevent the <a class="el" href="class_chimera_t_k_1_1_exception_handling_decorator.html" title="Decorator of the NDRegisterAccessor which facilitates tests of the application.">ExceptionHandlingDecorator</a> from erroneously detecting a device error in <a class="el" href="spec_execption_handling.html#c_2_4_3">2.4.3</a> after waiting for the DeviceModule::initialValueMutex in <a class="el" href="spec_execption_handling.html#c_2_3">2.3</a>.</li>
<li><a class="anchor" id="comment_c_3_3_13"></a><a class="el" href="spec_execption_handling.html#c_3_3_13">3.3.13</a> Setting the DeviceModule::deviceHasError flag has to be done in the application thread which has caught the exception. If you just send a message and let the device module do both setting and clearing of the flag you can have a race condition: Another accessor can still start a transfer until the <a class="el" href="class_chimera_t_k_1_1_device_module.html">DeviceModule</a> has woken up and set the flag, which can be avoided. Note that the original, severe race condition that let to this design (the same thread would not freeze because the desicion to do so was done in pre-read) does not exist any more since the backend has taken over the responsibility not to send any new data to the queue after an exception has been reported.</li>
<li><a class="anchor" id="comment_c_3_3_15"></a><a class="el" href="spec_execption_handling.html#c_3_3_15">3.3.15</a> The backend takes care that after an exception all transfer elements with "waitForNewData" will not start new asynchronous transfers until they have been re-activated with Device::activateAsyncReads() (see DeviceAccess TransferElement specification).</li>
</ul>
<h2><a class="anchor" id="spec_execptionHandling_high_level_implmentation_reportException"></a>
C.4 DeviceModule::reportException()</h2>
<ul>
<li>4.1 Acquire unique lock on DeviceModule::errorMutex (keep until function returns).</li>
<li>4.2 Just return, if DeviceModule::deviceHasError is already true.</li>
<li><a class="anchor" id="c_4_3"></a>4.3 Set DeviceModule::deviceHasError to true <a class="el" href="spec_execption_handling.html#comment_c_4_3">(*)</a>.</li>
<li>4.4 Generate a new VersionNumber and store in DeviceModule::exceptionVersionNumber.</li>
<li>4.5 Write exception message to DeviceModule::errorQueue.</li>
</ul>
<h3><a class="anchor" id="spec_execptionHandling_high_level_implmentation_reportException_comments"></a>
(*) Comments</h3>
<ul>
<li><a class="anchor" id="comment_c_4_3"></a><a class="el" href="spec_execption_handling.html#c_4_3">4.3</a> See also comment for <a class="el" href="spec_execption_handling.html#comment_c_2_7_1">2.7.1</a></li>
</ul>
<h1><a class="anchor" id="spec_execptionHandling_known_issues"></a>
D. Known issues</h1>
<p>TODO </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">index</a></li>
    <li class="footer">Generated on Thu Sep 7 2023 03:53:54 for ChimeraTK-ApplicationCore by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
