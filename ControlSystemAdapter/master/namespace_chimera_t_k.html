<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ChimeraTK-ControlSystemAdapter: ChimeraTK Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ChimeraTK_Logo_whitebg.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ChimeraTK-ControlSystemAdapter
   &#160;<span id="projectnumber">master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespace_chimera_t_k.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ChimeraTK Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_chimera_t_k_1_1csa__helpers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k_1_1csa__helpers.html">csa_helpers</a></td></tr>
<tr class="memdesc:namespace_chimera_t_k_1_1csa__helpers"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sub-namespace in order not to expose the classes to the <a class="el" href="namespace_chimera_t_k.html">ChimeraTK</a> namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_application_base.html">ApplicationBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for applications.  <a href="class_chimera_t_k_1_1_application_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_bidirectional_process_array.html">BidirectionalProcessArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the process array that transports data in both directions.  <a href="class_chimera_t_k_1_1_bidirectional_process_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_control_system_p_v_manager.html">ControlSystemPVManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manager for process variables on the control-system side.  <a href="class_chimera_t_k_1_1_control_system_p_v_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_decorator_factory.html">DecoratorFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_chimera_t_k_1_1_decorator_map_key.html">DecoratorMapKey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key type for the global decorator map.  <a href="struct_chimera_t_k_1_1_decorator_map_key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_decorator_type_holder.html">DecoratorTypeHolder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_device_p_v_manager.html">DevicePVManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manager for process variables on the device side.  <a href="class_chimera_t_k_1_1_device_p_v_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_chimera_t_k_1_1_img_header.html">ImgHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image header.  <a href="struct_chimera_t_k_1_1_img_header.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_img_view.html">ImgView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">provides convenient matrix-like access for <a class="el" href="class_chimera_t_k_1_1_mapped_image.html" title="interface to an image that is mapped onto a 1D array of ValType ">MappedImage</a>  <a href="class_chimera_t_k_1_1_img_view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_manual_time_stamp_source.html">ManualTimeStampSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The code manually has to set a time stamp, which is then disctributed to the connected PVs.  <a href="class_chimera_t_k_1_1_manual_time_stamp_source.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_mapped_image.html">MappedImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">interface to an image that is mapped onto a 1D array of ValType  <a href="class_chimera_t_k_1_1_mapped_image.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_mapped_struct.html">MappedStruct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides interface to a struct that is mapped onto a 1D array of ValType StructHeader must be derived from <a class="el" href="struct_chimera_t_k_1_1_opaque_struct_header.html" title="generic header for opaque struct handling It has fields needed for communication in the same process...">OpaqueStructHeader</a>.  <a href="class_chimera_t_k_1_1_mapped_struct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_chimera_t_k_1_1_opaque_struct_header.html">OpaqueStructHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">generic header for opaque struct handling It has fields needed for communication in the same process, e.g.  <a href="struct_chimera_t_k_1_1_opaque_struct_header.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_persistent_data_storage.html">PersistentDataStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Persistent data storage for process variables.  <a href="class_chimera_t_k_1_1_persistent_data_storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array version of the ProcessVariable.  <a href="class_chimera_t_k_1_1_process_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_p_v_manager.html">PVManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_chimera_t_k_1_1_status_accessor_base.html">StatusAccessorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class - used to avoid code duplication in StatusOutput, StatusPushInput and StatusPollInput.  <a href="struct_chimera_t_k_1_1_status_accessor_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_chimera_t_k_1_1_status_with_message_reader.html">StatusWithMessageReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is for consistent readout of StatusWithMessage - DeviceAccess version.  <a href="struct_chimera_t_k_1_1_status_with_message_reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_status_with_message_reader_base.html">StatusWithMessageReaderBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">only for code deduplication, not for direct use. Used by <a class="el" href="struct_chimera_t_k_1_1_status_with_message_reader.html" title="This is for consistent readout of StatusWithMessage - DeviceAccess version. ">StatusWithMessageReader</a> and StatusWithMessageInput  <a href="class_chimera_t_k_1_1_status_with_message_reader_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_decorator.html">TypeChangingDecorator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strictly this is not a real decorator.  <a href="class_chimera_t_k_1_1_type_changing_decorator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_direct_cast_decorator.html">TypeChangingDirectCastDecorator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This decorator does not do mathematical rounding and range checking, but directly assigns the data types (C-style direct conversion).  <a href="class_chimera_t_k_1_1_type_changing_direct_cast_decorator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_direct_cast_decorator_3_01_chimera_t_k_1_1_void_00_01_chimera_t_k_1_1_void_01_4.html">TypeChangingDirectCastDecorator&lt; ChimeraTK::Void, ChimeraTK::Void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for Void as user type and string as impl type.  <a href="class_chimera_t_k_1_1_type_changing_direct_cast_decorator_3_01_chimera_t_k_1_1_void_00_01_chimera_t_k_1_1_void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_direct_cast_decorator_3_01_chimera_t_k_1_1_void_00_01_i_m_p_l___t_01_4.html">TypeChangingDirectCastDecorator&lt; ChimeraTK::Void, IMPL_T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial template specialisation for Void as user type.  <a href="class_chimera_t_k_1_1_type_changing_direct_cast_decorator_3_01_chimera_t_k_1_1_void_00_01_i_m_p_l___t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_direct_cast_decorator_3_01_chimera_t_k_1_1_void_00_01std_1_1string_01_4.html">TypeChangingDirectCastDecorator&lt; ChimeraTK::Void, std::string &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for Void as user type and string as impl type.  <a href="class_chimera_t_k_1_1_type_changing_direct_cast_decorator_3_01_chimera_t_k_1_1_void_00_01std_1_1string_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_direct_cast_decorator_3_01std_1_1string_00_01_chimera_t_k_1_1_void_01_4.html">TypeChangingDirectCastDecorator&lt; std::string, ChimeraTK::Void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for Void as impl type and string as user type.  <a href="class_chimera_t_k_1_1_type_changing_direct_cast_decorator_3_01std_1_1string_00_01_chimera_t_k_1_1_void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_direct_cast_decorator_3_01std_1_1string_00_01_i_m_p_l___t_01_4.html">TypeChangingDirectCastDecorator&lt; std::string, IMPL_T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial template specialisation for strings as user type.  <a href="class_chimera_t_k_1_1_type_changing_direct_cast_decorator_3_01std_1_1string_00_01_i_m_p_l___t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_direct_cast_decorator_3_01_t_00_01_chimera_t_k_1_1_void_01_4.html">TypeChangingDirectCastDecorator&lt; T, ChimeraTK::Void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial template specialisation for Void as impl type.  <a href="class_chimera_t_k_1_1_type_changing_direct_cast_decorator_3_01_t_00_01_chimera_t_k_1_1_void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_direct_cast_decorator_3_01_t_00_01std_1_1string_01_4.html">TypeChangingDirectCastDecorator&lt; T, std::string &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial template specialisation for strings as impl type.  <a href="class_chimera_t_k_1_1_type_changing_direct_cast_decorator_3_01_t_00_01std_1_1string_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_range_checking_decorator.html">TypeChangingRangeCheckingDecorator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This decorator uses the boost numeric converter which performs two tasks:  <a href="class_chimera_t_k_1_1_type_changing_range_checking_decorator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_range_checking_decorator_3_01_chimera_t_k_1_1_void_00_01_chimera_t_k_1_1_void_01_4.html">TypeChangingRangeCheckingDecorator&lt; ChimeraTK::Void, ChimeraTK::Void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_range_checking_decorator_3_01_chimera_t_k_1_1_void_00_01_i_m_p_l___t_01_4.html">TypeChangingRangeCheckingDecorator&lt; ChimeraTK::Void, IMPL_T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_range_checking_decorator_3_01_chimera_t_k_1_1_void_00_01std_1_1string_01_4.html">TypeChangingRangeCheckingDecorator&lt; ChimeraTK::Void, std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_range_checking_decorator_3_01std_1_1string_00_01_chimera_t_k_1_1_void_01_4.html">TypeChangingRangeCheckingDecorator&lt; std::string, ChimeraTK::Void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_range_checking_decorator_3_01std_1_1string_00_01_i_m_p_l___t_01_4.html">TypeChangingRangeCheckingDecorator&lt; std::string, IMPL_T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_range_checking_decorator_3_01_t_00_01_chimera_t_k_1_1_void_01_4.html">TypeChangingRangeCheckingDecorator&lt; T, ChimeraTK::Void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_range_checking_decorator_3_01_t_00_01std_1_1string_01_4.html">TypeChangingRangeCheckingDecorator&lt; T, std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_string_impl_decorator.html">TypeChangingStringImplDecorator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is intended as a base class.  <a href="class_chimera_t_k_1_1_type_changing_string_impl_decorator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_string_impl_decorator_3_01_chimera_t_k_1_1_void_00_01_chimera_t_k_1_1_void_01_4.html">TypeChangingStringImplDecorator&lt; ChimeraTK::Void, ChimeraTK::Void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual partial implementation for Void as user type and Void as impl type.  <a href="class_chimera_t_k_1_1_type_changing_string_impl_decorator_3_01_chimera_t_k_1_1_void_00_01_chimera_t_k_1_1_void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_string_impl_decorator_3_01_chimera_t_k_1_1_void_00_01_i_m_p_l___t_01_4.html">TypeChangingStringImplDecorator&lt; ChimeraTK::Void, IMPL_T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual partial implementation for Void as user type.  <a href="class_chimera_t_k_1_1_type_changing_string_impl_decorator_3_01_chimera_t_k_1_1_void_00_01_i_m_p_l___t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_string_impl_decorator_3_01_chimera_t_k_1_1_void_00_01std_1_1string_01_4.html">TypeChangingStringImplDecorator&lt; ChimeraTK::Void, std::string &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual partial implementation for Void as user type and std::string as impl type.  <a href="class_chimera_t_k_1_1_type_changing_string_impl_decorator_3_01_chimera_t_k_1_1_void_00_01std_1_1string_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_string_impl_decorator_3_01std_1_1string_00_01_chimera_t_k_1_1_void_01_4.html">TypeChangingStringImplDecorator&lt; std::string, ChimeraTK::Void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual partial implementation for std::string as user type and Void as impl type.  <a href="class_chimera_t_k_1_1_type_changing_string_impl_decorator_3_01std_1_1string_00_01_chimera_t_k_1_1_void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_string_impl_decorator_3_01std_1_1string_00_01_i_m_p_l___t_01_4.html">TypeChangingStringImplDecorator&lt; std::string, IMPL_T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual partial implementation for strings as user type.  <a href="class_chimera_t_k_1_1_type_changing_string_impl_decorator_3_01std_1_1string_00_01_i_m_p_l___t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_string_impl_decorator_3_01_t_00_01_chimera_t_k_1_1_void_01_4.html">TypeChangingStringImplDecorator&lt; T, ChimeraTK::Void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual partial implementation for Void as impl type.  <a href="class_chimera_t_k_1_1_type_changing_string_impl_decorator_3_01_t_00_01_chimera_t_k_1_1_void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_string_impl_decorator_3_01_t_00_01std_1_1string_01_4.html">TypeChangingStringImplDecorator&lt; T, std::string &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual partial implementation for strings as impl type.  <a href="class_chimera_t_k_1_1_type_changing_string_impl_decorator_3_01_t_00_01std_1_1string_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_type_changing_void_impl_decorator.html">TypeChangingVoidImplDecorator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is intended as a base class.  <a href="class_chimera_t_k_1_1_type_changing_void_impl_decorator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_unidirectional_process_array.html">UnidirectionalProcessArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the process array that transports data in a single direction.  <a href="class_chimera_t_k_1_1_unidirectional_process_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a192dc5dbf7ebc07b1c012381df066b4e"><td class="memItemLeft" align="right" valign="top">typedef ChimeraTK::TransferElement&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#a192dc5dbf7ebc07b1c012381df066b4e">ProcessVariable</a></td></tr>
<tr class="separator:a192dc5dbf7ebc07b1c012381df066b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a377d018f686a15e28e316b2255030d62"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#a377d018f686a15e28e316b2255030d62">ImgFormat</a> { <br />
&#160;&#160;<a class="el" href="namespace_chimera_t_k.html#a377d018f686a15e28e316b2255030d62ac9f88e098f6fe4e4e112eeb05ccb9671">ImgFormat::Unset</a> = 0, 
<a class="el" href="namespace_chimera_t_k.html#a377d018f686a15e28e316b2255030d62ac8cfe3d00282445878661f32adca48ef">ImgFormat::Gray8</a>, 
<a class="el" href="namespace_chimera_t_k.html#a377d018f686a15e28e316b2255030d62a2a6ec0dac8730c09dba12f860dbbad12">ImgFormat::Gray16</a>, 
<a class="el" href="namespace_chimera_t_k.html#a377d018f686a15e28e316b2255030d62a08415b81fed4feed7d982c9919ac08ee">ImgFormat::RGB24</a>, 
<br />
&#160;&#160;<a class="el" href="namespace_chimera_t_k.html#a377d018f686a15e28e316b2255030d62ad9e8e4a9228ed56eceb29f0a1223b02b">ImgFormat::RGBA32</a>
<br />
 }</td></tr>
<tr class="separator:a377d018f686a15e28e316b2255030d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1335f948996830a55e08acf57cbab631"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#a1335f948996830a55e08acf57cbab631">ImgOptions</a> { <a class="el" href="namespace_chimera_t_k.html#a1335f948996830a55e08acf57cbab631abba47a7c03289a67ca347baa3f55be2f">ImgOptions::RowMajor</a> = 1, 
<a class="el" href="namespace_chimera_t_k.html#a1335f948996830a55e08acf57cbab631a9e91437ff30e153a77db79d1a362893a">ImgOptions::ColMajor</a> = 0
 }</td></tr>
<tr class="separator:a1335f948996830a55e08acf57cbab631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e41ad56888f34fba9598d89cc6bbcc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#aa7e41ad56888f34fba9598d89cc6bbcc">SynchronizationDirection</a> { <a class="el" href="namespace_chimera_t_k.html#aa7e41ad56888f34fba9598d89cc6bbcca0b7ae0252039e5d7b24f3d28cfd274bc">SynchronizationDirection::controlSystemToDevice</a>, 
<a class="el" href="namespace_chimera_t_k.html#aa7e41ad56888f34fba9598d89cc6bbcca5cc2e1ae8338cefe481b446fac79ed6d">SynchronizationDirection::deviceToControlSystem</a>, 
<a class="el" href="namespace_chimera_t_k.html#aa7e41ad56888f34fba9598d89cc6bbccae4dc2e9671c1874f0e2e9dd07eabcb0b">SynchronizationDirection::bidirectional</a>
 }<tr class="memdesc:aa7e41ad56888f34fba9598d89cc6bbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direction when synchronizing process variables.  <a href="namespace_chimera_t_k.html#aa7e41ad56888f34fba9598d89cc6bbcc">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aa7e41ad56888f34fba9598d89cc6bbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378b03423a5a360b373d3d14136c1b96"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96">DecoratorType</a> { <a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96a7585f22b9855288d28ebea110ab39224">DecoratorType::limiting</a>, 
<a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96a6b6318f96cdc11c6a547dcb8753e0a15">DecoratorType::C_style_conversion</a>
 }<tr class="memdesc:a378b03423a5a360b373d3d14136c1b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">There are three types of TypeChanging decorators which do different data conversions from the user data type to the implementation data type.  <a href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a378b03423a5a360b373d3d14136c1b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad9aabee6f1b52f3c1fb9c870c87fc1ab"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad9aabee6f1b52f3c1fb9c870c87fc1ab"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr, typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#ad9aabee6f1b52f3c1fb9c870c87fc1ab">createBidirectionalSynchronizedProcessArray</a> (std::size_t size, const ChimeraTK::RegisterPath &amp;name=&quot;&quot;, const std::string &amp;unit=&quot;&quot;, const std::string &amp;description=&quot;&quot;, T initialValue=T(), std::size_t numberOfBuffers=3, const AccessModeFlags &amp;flags={AccessMode::wait_for_new_data})</td></tr>
<tr class="memdesc:ad9aabee6f1b52f3c1fb9c870c87fc1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a bidirectional synchronized process array.  <a href="#ad9aabee6f1b52f3c1fb9c870c87fc1ab">More...</a><br /></td></tr>
<tr class="separator:ad9aabee6f1b52f3c1fb9c870c87fc1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac9be97863e3d082eeeb0460dc67452"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8ac9be97863e3d082eeeb0460dc67452"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr, typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#a8ac9be97863e3d082eeeb0460dc67452">createBidirectionalSynchronizedProcessArray</a> (const std::vector&lt; T &gt; &amp;initialValue, const ChimeraTK::RegisterPath &amp;name=&quot;&quot;, const std::string &amp;unit=&quot;&quot;, const std::string &amp;description=&quot;&quot;, std::size_t numberOfBuffers=3, const AccessModeFlags &amp;flags={AccessMode::wait_for_new_data})</td></tr>
<tr class="memdesc:a8ac9be97863e3d082eeeb0460dc67452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a bidirectional synchronized process array.  <a href="#a8ac9be97863e3d082eeeb0460dc67452">More...</a><br /></td></tr>
<tr class="separator:a8ac9be97863e3d082eeeb0460dc67452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da887c3ca7c2351d7d6331b5636bd24"><td class="memItemLeft" align="right" valign="top">std::pair&lt; boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_control_system_p_v_manager.html">ControlSystemPVManager</a> &gt;, boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_device_p_v_manager.html">DevicePVManager</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#a2da887c3ca7c2351d7d6331b5636bd24">createPVManager</a> ()</td></tr>
<tr class="memdesc:a2da887c3ca7c2351d7d6331b5636bd24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a PV manager and returns a pair containing references to its <a class="el" href="class_chimera_t_k_1_1_control_system_p_v_manager.html">ControlSystemPVManager</a> and <a class="el" href="class_chimera_t_k_1_1_device_p_v_manager.html">DevicePVManager</a> interfaces.  <a href="#a2da887c3ca7c2351d7d6331b5636bd24">More...</a><br /></td></tr>
<tr class="separator:a2da887c3ca7c2351d7d6331b5636bd24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0956da557455c1cde83d2295dd1ae961"><td class="memTemplParams" colspan="2">template&lt;class UserType &gt; </td></tr>
<tr class="memitem:a0956da557455c1cde83d2295dd1ae961"><td class="memTemplItemLeft" align="right" valign="top">boost::shared_ptr&lt; ChimeraTK::NDRegisterAccessor&lt; UserType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#a0956da557455c1cde83d2295dd1ae961">getDecorator</a> (const boost::shared_ptr&lt; ChimeraTK::TransferElement &gt; &amp;transferElement, <a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96">DecoratorType</a> decoratorType=<a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96a7585f22b9855288d28ebea110ab39224">DecoratorType::limiting</a>)</td></tr>
<tr class="memdesc:a0956da557455c1cde83d2295dd1ae961"><td class="mdescLeft">&#160;</td><td class="mdescRight">The factory function for type changing decorators.  <a href="#a0956da557455c1cde83d2295dd1ae961">More...</a><br /></td></tr>
<tr class="separator:a0956da557455c1cde83d2295dd1ae961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9cd0ba3253ed6f31af03005a2acb61"><td class="memTemplParams" colspan="2">template&lt;class UserType &gt; </td></tr>
<tr class="memitem:a5d9cd0ba3253ed6f31af03005a2acb61"><td class="memTemplItemLeft" align="right" valign="top">boost::shared_ptr&lt; ChimeraTK::NDRegisterAccessor&lt; UserType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#a5d9cd0ba3253ed6f31af03005a2acb61">getDecorator</a> (ChimeraTK::TransferElementAbstractor &amp;transferElement, <a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96">DecoratorType</a> decoratorType=<a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96a7585f22b9855288d28ebea110ab39224">DecoratorType::limiting</a>)</td></tr>
<tr class="separator:a5d9cd0ba3253ed6f31af03005a2acb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade942ee5a562daf9a6bafe21ad4e39cc"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="struct_chimera_t_k_1_1_decorator_map_key.html">DecoratorMapKey</a>, boost::shared_ptr&lt; ChimeraTK::TransferElement &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#ade942ee5a562daf9a6bafe21ad4e39cc">getGlobalDecoratorMap</a> ()</td></tr>
<tr class="memdesc:ade942ee5a562daf9a6bafe21ad4e39cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quasi singleton to have a unique, global map across UserType templated factories.  <a href="#ade942ee5a562daf9a6bafe21ad4e39cc">More...</a><br /></td></tr>
<tr class="separator:ade942ee5a562daf9a6bafe21ad4e39cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b513f257155d9245ebed197db95a8fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#a3b513f257155d9245ebed197db95a8fc">setEnableProcessArrayThreadSafetyCheck</a> (bool enable)</td></tr>
<tr class="memdesc:a3b513f257155d9245ebed197db95a8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Globally enable or disable the thread safety check on each read/write.  <a href="#a3b513f257155d9245ebed197db95a8fc">More...</a><br /></td></tr>
<tr class="separator:a3b513f257155d9245ebed197db95a8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4267298283650894fb5cd0a843d7504"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac4267298283650894fb5cd0a843d7504"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr, typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#ac4267298283650894fb5cd0a843d7504">createSynchronizedProcessArray</a> (std::size_t size, const ChimeraTK::RegisterPath &amp;name=&quot;&quot;, const std::string &amp;unit=&quot;&quot;, const std::string &amp;description=&quot;&quot;, T initialValue=T(), std::size_t numberOfBuffers=3, const AccessModeFlags &amp;flags={AccessMode::wait_for_new_data})</td></tr>
<tr class="memdesc:ac4267298283650894fb5cd0a843d7504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a synchronized process array.  <a href="#ac4267298283650894fb5cd0a843d7504">More...</a><br /></td></tr>
<tr class="separator:ac4267298283650894fb5cd0a843d7504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0615f64225f18201afa045e8eb0d7187"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0615f64225f18201afa045e8eb0d7187"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr, typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#a0615f64225f18201afa045e8eb0d7187">createSynchronizedProcessArray</a> (const std::vector&lt; T &gt; &amp;initialValue, const ChimeraTK::RegisterPath &amp;name=&quot;&quot;, const std::string &amp;unit=&quot;&quot;, const std::string &amp;description=&quot;&quot;, std::size_t numberOfBuffers=3, const AccessModeFlags &amp;flags={AccessMode::wait_for_new_data})</td></tr>
<tr class="memdesc:a0615f64225f18201afa045e8eb0d7187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a synchronized process array.  <a href="#a0615f64225f18201afa045e8eb0d7187">More...</a><br /></td></tr>
<tr class="separator:a0615f64225f18201afa045e8eb0d7187"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5453614d4428268571689bca7bbf571b"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="struct_chimera_t_k_1_1_decorator_map_key.html">DecoratorMapKey</a>, boost::shared_ptr&lt; ChimeraTK::TransferElement &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_chimera_t_k.html#a5453614d4428268571689bca7bbf571b">globalDecoratorMap</a></td></tr>
<tr class="separator:a5453614d4428268571689bca7bbf571b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a192dc5dbf7ebc07b1c012381df066b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a192dc5dbf7ebc07b1c012381df066b4e">&#9670;&nbsp;</a></span>ProcessVariable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ChimeraTK::TransferElement <a class="el" href="namespace_chimera_t_k.html#a192dc5dbf7ebc07b1c012381df066b4e">ChimeraTK::ProcessVariable</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_process_variable_8h_source.html#l00007">7</a> of file <a class="el" href="_process_variable_8h_source.html">ProcessVariable.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a378b03423a5a360b373d3d14136c1b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378b03423a5a360b373d3d14136c1b96">&#9670;&nbsp;</a></span>DecoratorType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96">ChimeraTK::DecoratorType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>There are three types of TypeChanging decorators which do different data conversions from the user data type to the implementation data type. </p>
<ul>
<li>limiting This decorator limits the data to the maximum possible in the target data type (for instance 500 will result in 127 in int8_t and 255 in uint8_t, -200 will be -128 in int8t, 0 in uint8_t). This decorator also does correct rounding from floating point to integer type. </li>
<li>C_style_conversion This decorator does a direct cast like an assigment in C/C++ does it. For instance 500 (=0x1f4) will result in 0xf4 for an 8 bit integer, which is interpreted as 244 in uint8_t and -12 in int8_t. Digits after the decimal point are cut when converting a floating point value to an integer type. This decorator can be useful to display unsigned integers which use the full dynamic range in a control system which only supports signed data types (the user has to correctly interpret the 'wrong' representation), of for bit fields where it is acceptable to lose the higher bits. </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a378b03423a5a360b373d3d14136c1b96a7585f22b9855288d28ebea110ab39224"></a>limiting&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a378b03423a5a360b373d3d14136c1b96a6b6318f96cdc11c6a547dcb8753e0a15"></a>C_style_conversion&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_type_changing_decorator_8h_source.html#l00030">30</a> of file <a class="el" href="_type_changing_decorator_8h_source.html">TypeChangingDecorator.h</a>.</p>

</div>
</div>
<a id="a377d018f686a15e28e316b2255030d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377d018f686a15e28e316b2255030d62">&#9670;&nbsp;</a></span>ImgFormat</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_chimera_t_k.html#a377d018f686a15e28e316b2255030d62">ChimeraTK::ImgFormat</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a377d018f686a15e28e316b2255030d62ac9f88e098f6fe4e4e112eeb05ccb9671"></a>Unset&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a377d018f686a15e28e316b2255030d62ac8cfe3d00282445878661f32adca48ef"></a>Gray8&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a377d018f686a15e28e316b2255030d62a2a6ec0dac8730c09dba12f860dbbad12"></a>Gray16&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a377d018f686a15e28e316b2255030d62a08415b81fed4feed7d982c9919ac08ee"></a>RGB24&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a377d018f686a15e28e316b2255030d62ad9e8e4a9228ed56eceb29f0a1223b02b"></a>RGBA32&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_mapped_image_8h_source.html#l00077">77</a> of file <a class="el" href="_mapped_image_8h_source.html">MappedImage.h</a>.</p>

</div>
</div>
<a id="a1335f948996830a55e08acf57cbab631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1335f948996830a55e08acf57cbab631">&#9670;&nbsp;</a></span>ImgOptions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_chimera_t_k.html#a1335f948996830a55e08acf57cbab631">ChimeraTK::ImgOptions</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1335f948996830a55e08acf57cbab631abba47a7c03289a67ca347baa3f55be2f"></a>RowMajor&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1335f948996830a55e08acf57cbab631a9e91437ff30e153a77db79d1a362893a"></a>ColMajor&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_mapped_image_8h_source.html#l00079">79</a> of file <a class="el" href="_mapped_image_8h_source.html">MappedImage.h</a>.</p>

</div>
</div>
<a id="aa7e41ad56888f34fba9598d89cc6bbcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e41ad56888f34fba9598d89cc6bbcc">&#9670;&nbsp;</a></span>SynchronizationDirection</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_chimera_t_k.html#aa7e41ad56888f34fba9598d89cc6bbcc">ChimeraTK::SynchronizationDirection</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direction when synchronizing process variables. </p>
<p>A process variable may be synchronized from the device library to the control system (input) or from the control system to the device library (output). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa7e41ad56888f34fba9598d89cc6bbcca0b7ae0252039e5d7b24f3d28cfd274bc"></a>controlSystemToDevice&#160;</td><td class="fielddoc"><p>Synchronize from the control system to the device library. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa7e41ad56888f34fba9598d89cc6bbcca5cc2e1ae8338cefe481b446fac79ed6d"></a>deviceToControlSystem&#160;</td><td class="fielddoc"><p>Synchronize from the device library to the control system. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa7e41ad56888f34fba9598d89cc6bbccae4dc2e9671c1874f0e2e9dd07eabcb0b"></a>bidirectional&#160;</td><td class="fielddoc"><p>Synchronize in both directions. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_synchronization_direction_8h_source.html#l00011">11</a> of file <a class="el" href="_synchronization_direction_8h_source.html">SynchronizationDirection.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad9aabee6f1b52f3c1fb9c870c87fc1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9aabee6f1b52f3c1fb9c870c87fc1ab">&#9670;&nbsp;</a></span>createBidirectionalSynchronizedProcessArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr, typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr &gt; ChimeraTK::createBidirectionalSynchronizedProcessArray </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ChimeraTK::RegisterPath &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unit</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>initialValue</em> = <code>T()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>numberOfBuffers</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AccessModeFlags &amp;&#160;</td>
          <td class="paramname"><em>flags</em> = <code>{AccessMode::wait_for_new_data}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a bidirectional synchronized process array. </p>
<p>A bidirectional synchronized process array works as a pair of two process arrays, where changes written on either side can be read on the respective other side.</p>
<p>The synchronization is implemented in a thread-safe manner, so that the two coupled process arrays can safely be used by different threads without a mutex. However, both process arrays each only support a single thread. This means that access to each process array have to be protected with a mutex if more than one thread wants to access it.</p>
<p>The number of buffers specifies how many buffers are allocated for the send / receive mechanism. The minimum number (and default) is two. This number specifies, how many times ProcessArray::write() can be called in a row without losing data when readNonBlocking() is not called in between. The specified number of buffers is used for each direction.</p>
<p>The specified time-stamp sources are used for determining the current time when sending a value. The receiver will be updated with this time stamp when receiving the value. If no time-stamp source is specified, the current system-time when the value is sent is used. The first specified time-stamp source is used when sending values from the first returned process array and the second specified time-stamp source is used when sending values from the second returned process array.</p>
<p>The specified initial value is used for all the elements of the array.</p>
<p>Of the two returned process arrays, only the first one can take an optional persistent data storage. Trying to set a persistent data storage on the first one results in an exception. </p>

<p class="definition">Definition at line <a class="el" href="_bidirectional_process_array_8h_source.html#l00364">364</a> of file <a class="el" href="_bidirectional_process_array_8h_source.html">BidirectionalProcessArray.h</a>.</p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_chimera_t_k_ad9aabee6f1b52f3c1fb9c870c87fc1ab_cgraph.svg" width="515" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_chimera_t_k_ad9aabee6f1b52f3c1fb9c870c87fc1ab_icgraph.svg" width="475" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8ac9be97863e3d082eeeb0460dc67452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac9be97863e3d082eeeb0460dc67452">&#9670;&nbsp;</a></span>createBidirectionalSynchronizedProcessArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr, typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr &gt; ChimeraTK::createBidirectionalSynchronizedProcessArray </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>initialValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ChimeraTK::RegisterPath &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unit</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>numberOfBuffers</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AccessModeFlags &amp;&#160;</td>
          <td class="paramname"><em>flags</em> = <code>{AccessMode::wait_for_new_data}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a bidirectional synchronized process array. </p>
<p>A bidirectional synchronized process array works as a pair of two process arrays, where changes written on either side can be read on the respective other side.</p>
<p>The synchronization is implemented in a thread-safe manner, so that the two coupled process arrays can safely be used by different threads without a mutex. However, both process arrays each only support a single thread. This means that access to each process array have to be protected with a mutex if more than one thread wants to access it.</p>
<p>The number of buffers specifies how many buffers are allocated for the send / receive mechanism. The minimum number (and default) is two. This number specifies, how many times ProcessArray::write() can be called in a row without losing data when readNonBlocking() is not called in between. The specified number of buffers is used for each direction.</p>
<p>The specified time-stamp source is used for determining the current time when sending a value. The receiver will be updated with this time stamp when receiving the value. If no time-stamp source is specified, the current system-time when the value is sent is used.</p>
<p>The array's size is set to the number of elements stored in the vector provided for initialization and all elements are initialized with the values provided by this vector.</p>
<p>Of the two returned process arrays, only the first one can take an optional persistent data storage. Trying to set a persistent data storage on the first one results in an exception. </p>

<p class="definition">Definition at line <a class="el" href="_bidirectional_process_array_8h_source.html#l00394">394</a> of file <a class="el" href="_bidirectional_process_array_8h_source.html">BidirectionalProcessArray.h</a>.</p>
<div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_chimera_t_k_a8ac9be97863e3d082eeeb0460dc67452_cgraph.svg" width="515" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2da887c3ca7c2351d7d6331b5636bd24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da887c3ca7c2351d7d6331b5636bd24">&#9670;&nbsp;</a></span>createPVManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_control_system_p_v_manager.html">ControlSystemPVManager</a> &gt;, shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_device_p_v_manager.html">DevicePVManager</a> &gt; &gt; ChimeraTK::createPVManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a PV manager and returns a pair containing references to its <a class="el" href="class_chimera_t_k_1_1_control_system_p_v_manager.html">ControlSystemPVManager</a> and <a class="el" href="class_chimera_t_k_1_1_device_p_v_manager.html">DevicePVManager</a> interfaces. </p>
<p>The <a class="el" href="namespace_chimera_t_k.html#a2da887c3ca7c2351d7d6331b5636bd24">createPVManager()</a> function is used to instantiate a <a class="el" href="class_chimera_t_k_1_1_p_v_manager.html">PVManager</a>.</p>
<p>The <a class="el" href="class_chimera_t_k_1_1_device_p_v_manager.html">DevicePVManager</a> is only intended for use by the device-library thread and the <a class="el" href="class_chimera_t_k_1_1_control_system_p_v_manager.html">ControlSystemPVManager</a> is only intended for use by the control-system thread. </p>

<p class="definition">Definition at line <a class="el" href="_p_v_manager_8cc_source.html#l00044">44</a> of file <a class="el" href="_p_v_manager_8cc_source.html">PVManager.cc</a>.</p>
<div id="dynsection-3" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-3-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-3-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-3-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespace_chimera_t_k_a2da887c3ca7c2351d7d6331b5636bd24_icgraph.svg" width="100%" height="442"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="ac4267298283650894fb5cd0a843d7504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4267298283650894fb5cd0a843d7504">&#9670;&nbsp;</a></span>createSynchronizedProcessArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr, typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr &gt; ChimeraTK::createSynchronizedProcessArray </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ChimeraTK::RegisterPath &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unit</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>initialValue</em> = <code>T()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>numberOfBuffers</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AccessModeFlags &amp;&#160;</td>
          <td class="paramname"><em>flags</em> = <code>{AccessMode::wait_for_new_data}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a synchronized process array. </p>
<p>A synchronized process array works as a pair of two process arrays, where the pair's first acts as a sender and the second one acts as a receiver.</p>
<p>The sender allows full read-write access. Changes that have been made to the sender can be sent to the receiver through the ProcessArray::write() method. The receiver can be updated with these changes by calling its readNonBlocking() method.</p>
<p>The synchronization is implemented in a thread-safe manner, so that the sender and the receiver can safely be used by different threads without a mutex. However, both the sender and receiver each only support a single thread. This means that the sender or the receiver have to be protected with a mutex if more than one thread wants to access either of them.</p>
<p>The number of buffers specifies how many buffers are allocated for the send / receive mechanism. The minimum number (and default) is two. This number specifies, how many times ProcessArray::write() can be called in a row without losing data when readNonBlocking() is not called in between.</p>
<p>The specified time-stamp source is used for determining the current time when sending a value. The receiver will be updated with this time stamp when receiving the value. If no time-stamp source is specified, the current system-time when the value is sent is used.</p>
<p>The specified initial value is used for all the elements of the array. </p>

<p class="definition">Definition at line <a class="el" href="_unidirectional_process_array_8h_source.html#l00578">578</a> of file <a class="el" href="_unidirectional_process_array_8h_source.html">UnidirectionalProcessArray.h</a>.</p>
<div id="dynsection-4" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-4-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-4-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-4-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespace_chimera_t_k_ac4267298283650894fb5cd0a843d7504_icgraph.svg" width="100%" height="300"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="a0615f64225f18201afa045e8eb0d7187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0615f64225f18201afa045e8eb0d7187">&#9670;&nbsp;</a></span>createSynchronizedProcessArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr, typename <a class="el" href="class_chimera_t_k_1_1_process_array.html">ProcessArray</a>&lt; T &gt;::SharedPtr &gt; ChimeraTK::createSynchronizedProcessArray </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>initialValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ChimeraTK::RegisterPath &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unit</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>numberOfBuffers</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AccessModeFlags &amp;&#160;</td>
          <td class="paramname"><em>flags</em> = <code>{AccessMode::wait_for_new_data}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a synchronized process array. </p>
<p>A synchronized process array works as a pair of two process arrays, where pair's first acts as a sender and the second one acts as a receiver.</p>
<p>The sender allows full read-write access. Changes that have been made to the sender can be sent to the receiver through the ProcessArray::write() method. The receiver can be updated with these changes by calling its readNonBlocking() method.</p>
<p>The synchronization is implemented in a thread-safe manner, so that the sender and the receiver can safely be used by different threads without a mutex. However, both the sender and receiver each only support a single thread. This means that the sender or the receiver have to be protected with a mutex if more than one thread wants to access either of them.</p>
<p>The number of buffers specifies how many buffers are allocated for the send / receive mechanism. The minimum number (and default) is two. This number specifies, how many times ProcessArray::write() can be called in a row without losing data when readNonBlocking() is not called in between.</p>
<p>The specified time-stamp source is used for determining the current time when sending a value. The receiver will be updated with this time stamp when receiving the value. If no time-stamp source is specified, the current system-time when the value is sent is used.</p>
<p>The array's size is set to the number of elements stored in the vector provided for initialization and all elements are initialized with the values provided by this vector. </p>

<p class="definition">Definition at line <a class="el" href="_unidirectional_process_array_8h_source.html#l00595">595</a> of file <a class="el" href="_unidirectional_process_array_8h_source.html">UnidirectionalProcessArray.h</a>.</p>

</div>
</div>
<a id="a0956da557455c1cde83d2295dd1ae961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0956da557455c1cde83d2295dd1ae961">&#9670;&nbsp;</a></span>getDecorator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UserType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt; ChimeraTK::NDRegisterAccessor&lt; UserType &gt; &gt; ChimeraTK::getDecorator </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; ChimeraTK::TransferElement &gt; &amp;&#160;</td>
          <td class="paramname"><em>transferElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96">DecoratorType</a>&#160;</td>
          <td class="paramname"><em>decoratorType</em> = <code><a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96a7585f22b9855288d28ebea110ab39224">DecoratorType::limiting</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The factory function for type changing decorators. </p>
<p>TypeChanging decorators take a transfer element (usually NDRegisterAccessor&lt;ImplType&gt;) and wraps it in an NDRegisterAccessor&lt;UserType&gt;. It automatically performs the right type conversion (configurable as argument of the factory function). The decorator has it's own buffer of type UserType and synchronises it in the preWrite() and postRead() functions with the implementation. You don't have to care about the implementation type of the transfer element. The factory will automatically create the correct decorator.</p>
<p>Note: it is possible to obtain multiple decorators of different types for the same accessor. The user needs to ensure that the preXxx/postXxx transfer functions are properly called for all decorators when required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transferElement</td><td>The TransferElement to be decorated. It can either be an NDRegisterAccessor (usually the case) or and NDRegisterAccessorBridge (but here the user already picks the type he wants). </td></tr>
    <tr><td class="paramname">decoratorType</td><td>The type of decorator you want (see description of DecoratorType) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_type_changing_decorator_8h_source.html#l00652">652</a> of file <a class="el" href="_type_changing_decorator_8h_source.html">TypeChangingDecorator.h</a>.</p>
<div id="dynsection-5" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-5-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-5-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-5-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_chimera_t_k_a0956da557455c1cde83d2295dd1ae961_cgraph.svg" width="502" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5d9cd0ba3253ed6f31af03005a2acb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9cd0ba3253ed6f31af03005a2acb61">&#9670;&nbsp;</a></span>getDecorator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UserType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;ChimeraTK::NDRegisterAccessor&lt;UserType&gt; &gt; ChimeraTK::getDecorator </td>
          <td>(</td>
          <td class="paramtype">ChimeraTK::TransferElementAbstractor &amp;&#160;</td>
          <td class="paramname"><em>transferElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96">DecoratorType</a>&#160;</td>
          <td class="paramname"><em>decoratorType</em> = <code><a class="el" href="namespace_chimera_t_k.html#a378b03423a5a360b373d3d14136c1b96a7585f22b9855288d28ebea110ab39224">DecoratorType::limiting</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_changing_decorator_8h_source.html#l00058">58</a> of file <a class="el" href="_type_changing_decorator_8h_source.html">TypeChangingDecorator.h</a>.</p>

</div>
</div>
<a id="ade942ee5a562daf9a6bafe21ad4e39cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade942ee5a562daf9a6bafe21ad4e39cc">&#9670;&nbsp;</a></span>getGlobalDecoratorMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; <a class="el" href="struct_chimera_t_k_1_1_decorator_map_key.html">DecoratorMapKey</a>, boost::shared_ptr&lt; ChimeraTK::TransferElement &gt; &gt; &amp; ChimeraTK::getGlobalDecoratorMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quasi singleton to have a unique, global map across UserType templated factories. </p>
<p>We need it to loop up if a decorator has already been created for the transfer element, and return this if so. Multiple decorators for the same transfer element don't work. </p>

<p class="definition">Definition at line <a class="el" href="_type_changing_decorator_8cc_source.html#l00008">8</a> of file <a class="el" href="_type_changing_decorator_8cc_source.html">TypeChangingDecorator.cc</a>.</p>
<div id="dynsection-6" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-6-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-6-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-6-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespace_chimera_t_k_ade942ee5a562daf9a6bafe21ad4e39cc_icgraph.svg" width="532" height="104"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a3b513f257155d9245ebed197db95a8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b513f257155d9245ebed197db95a8fc">&#9670;&nbsp;</a></span>setEnableProcessArrayThreadSafetyCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChimeraTK::setEnableProcessArrayThreadSafetyCheck </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Globally enable or disable the thread safety check on each read/write. </p>
<p>This will throw an assertion if the thread id has been changed since the last read/write operation which has been executed with the safety check enabled. This will only have an effect if debug compiler flags are enabled. </p>

<p class="definition">Definition at line <a class="el" href="_unidirectional_process_array_8cc_source.html#l00007">7</a> of file <a class="el" href="_unidirectional_process_array_8cc_source.html">UnidirectionalProcessArray.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a5453614d4428268571689bca7bbf571b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5453614d4428268571689bca7bbf571b">&#9670;&nbsp;</a></span>globalDecoratorMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="struct_chimera_t_k_1_1_decorator_map_key.html">DecoratorMapKey</a>, boost::shared_ptr&lt;ChimeraTK::TransferElement&gt; &gt; ChimeraTK::globalDecoratorMap</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_type_changing_decorator_8cc_source.html#l00006">6</a> of file <a class="el" href="_type_changing_decorator_8cc_source.html">TypeChangingDecorator.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_chimera_t_k.html">ChimeraTK</a></li>
    <li class="footer">Generated on Fri Nov 18 2022 04:55:05 for ChimeraTK-ControlSystemAdapter by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
