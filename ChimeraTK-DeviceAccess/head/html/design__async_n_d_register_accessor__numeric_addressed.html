<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ChimeraTK-DeviceAccess: Design: AsyncNDRegisterAccessor</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ChimeraTK_Logo_whitebg.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ChimeraTK-DeviceAccess
   &#160;<span id="projectnumber">03.15.02</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('design__async_n_d_register_accessor__numeric_addressed.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Design: <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html" title="The AsyncNDRegisterAccessor implements a data transport queue with typed data as continuation of the ...">AsyncNDRegisterAccessor</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="conceptOverview"></a>
Concept overview</h1>
<dl class="section warning"><dt>Warning</dt><dd>This document is supposed to help with understanding the code structure. It also contains a lot of technical details that led to certain design decisions. As the structure is still in the flow, it might contain outdated information.</dd></dl>
<h6></h6>
<h2><a class="anchor" id="design_AsyncAccessorManager"></a>
AsyncNDRegisterAccessors and the AsyncAccessorManager</h2>
<h6></h6>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_1.svg" width="592" height="162"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<ul>
<li>The <a class="el" href="class_chimera_t_k_1_1async_1_1_async_accessor_manager.html" title="The AsyncAccessorManager has three main functionalities:">AsyncAccessorManager</a> is a base clase which manages the subscriptions of accessors requested by the users.</li>
<li>For each AsyncAccessor that the user requests, an <a class="el" href="struct_chimera_t_k_1_1async_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a> is created interally, with 1:1 correspondence AsyncAccessor â†” AsyncVar.</li>
<li>The AsyncAccessor is handed out to user. The <a class="el" href="struct_chimera_t_k_1_1async_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a> holds the a buffer which is used to fill data into the AsyncAccessor when sending.</li>
<li>The <a class="el" href="struct_chimera_t_k_1_1async_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a> knows how to fill its send buffer, i.e. it might be special for each <a class="el" href="class_chimera_t_k_1_1async_1_1_async_accessor_manager.html" title="The AsyncAccessorManager has three main functionalities:">AsyncAccessorManager</a> implementation (see <a class="el" href="class_chimera_t_k_1_1async_1_1_triggered_poll_distributor.html" title="The TriggeredPollDistributor has std::nullptr_t source data type and is polling the data for the Asyn...">TriggeredPollDistributor</a> and VarialeDistributor)</li>
<li>AsyncVar is only holding a weak pointer to the AsyncAccessor, since we want to be sensitive to the user discarding the latter</li>
</ul>
<h6></h6>
<h2><a class="anchor" id="design_TriggeredPollDistributor"></a>
The TriggeredPollDistributor</h2>
<h6></h6>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_2.svg" width="899" height="208"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<ul>
<li>The <a class="el" href="class_chimera_t_k_1_1async_1_1_triggered_poll_distributor.html" title="The TriggeredPollDistributor has std::nullptr_t source data type and is polling the data for the Asyn...">TriggeredPollDistributor</a> is polling data via synchronous accessors when a trigger (interrupt) comes in.</li>
<li>The PolledAsyncVar implements filling the send buffer from an associated syncAccessor.</li>
<li>The <a class="el" href="class_chimera_t_k_1_1async_1_1_triggered_poll_distributor.html" title="The TriggeredPollDistributor has std::nullptr_t source data type and is polling the data for the Asyn...">TriggeredPollDistributor</a> is using a transferGroup for efficiency. As the syncronous accessors and the transfer group already implement all the necessary conversion to user types, partial use or 1 D registers etc., we simply use one matching synchronous accessor for each PolledAsyncVar.</li>
</ul>
<h6></h6>
<h2><a class="anchor" id="design_SubDomain"></a>
The SubDomain</h2>
<h6></h6>
<p>The reverse ownership scheme in the <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend.html" title="Base class for address-based device backends (e.g.">NumericAddressedBackend</a></p>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_3.svg" width="2398" height="710"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<ul>
<li>The triggers (resulting from interrupts) are distributed from left to right, mostly through weak pointers (dashed lines and empty arrow head)</li>
<li>For each interrupt handler thread there is one <a class="el" href="class_chimera_t_k_1_1async_1_1_domain.html" title="The Domain is the thread-safe entry point for each distribution tree.">async::Domain</a> which implements a central lock for the whole tree behind it. It protects the trigger distribution against concurrent subscriptions of accessors and the sending of exceptions. The <a class="el" href="class_chimera_t_k_1_1async_1_1_domain.html" title="The Domain is the thread-safe entry point for each distribution tree.">Domain</a> is of the backend data type "nullptr_t" because the triggers are conceptually void. The <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend.html" title="Base class for address-based device backends (e.g.">NumericAddressedBackend</a> is holding weak pointers to the Domains. The Domains are created when they are needed, i.e. when an accessor down the tree is created. Other backends might hold shared pointers to Domains, depending on the implementation.</li>
<li>Behind each <a class="el" href="class_chimera_t_k_1_1async_1_1_domain.html" title="The Domain is the thread-safe entry point for each distribution tree.">Domain</a> there is exactly one (primary) <a class="el" href="class_chimera_t_k_1_1async_1_1_sub_domain.html" title="Send backend-specific asynchronous data to different distributors:">SubDomain</a>. The <a class="el" href="class_chimera_t_k_1_1async_1_1_sub_domain.html" title="Send backend-specific asynchronous data to different distributors:">SubDomain</a> basically is an adapter to the connected distrubutors (VariableDistributors, TriggeredPollDistributors and MuxedInterruptDistributors). Further SubDomains are behind the MuxedInterruptDistributors, one for each sub-interrupt.</li>
<li>SubDomains are identified by a qualified (i.e. heirarchical) ID (represented as a std::vector&lt;size_t&gt;). The primary <a class="el" href="class_chimera_t_k_1_1async_1_1_sub_domain.html" title="Send backend-specific asynchronous data to different distributors:">SubDomain</a> ID has a length 1, and for each hierarchy level a number is added. The <a class="el" href="class_chimera_t_k_1_1async_1_1_domain.html" title="The Domain is the thread-safe entry point for each distribution tree.">Domain</a> ID is a number, machting the first entry in the qualifiedAsyncSubDomainID. (qualifiedAsyncSubDomainID is abbeviated as qualifiedSubDomainID or qualifiedAsyncID, depending on the context). Example: The <a class="el" href="class_chimera_t_k_1_1async_1_1_sub_domain.html" title="Send backend-specific asynchronous data to different distributors:">SubDomain</a> [0,4] is responsible for sub-interrupt 4 in the <a class="el" href="class_chimera_t_k_1_1async_1_1_muxed_interrupt_distributor.html" title="Interface base class for interrupt controller handlers.">MuxedInterruptDistributor</a> [0] behind the primay <a class="el" href="class_chimera_t_k_1_1async_1_1_sub_domain.html" title="Send backend-specific asynchronous data to different distributors:">SubDomain</a> [0] in <a class="el" href="class_chimera_t_k_1_1async_1_1_domain.html" title="The Domain is the thread-safe entry point for each distribution tree.">Domain</a> 0 (see <a class="el" href="design__async_n_d_register_accessor__numeric_addressed.html#design_async_canonical_interrupt_name">Canonical interrupt names</a>).</li>
<li>The single instance of the DomainsContainter is responsible for distributing exceptions to all Domains. It is always holding weak pointers to the Domains.</li>
<li>VariableDistributors and TriggeredPollDistributors are derrived from the <a class="el" href="class_chimera_t_k_1_1async_1_1_async_accessor_manager.html" title="The AsyncAccessorManager has three main functionalities:">AsyncAccessorManager</a> and are holding accessors to the backend to read data or do handshakes (red), which in turn are holding shared pointers to the backend (shared ownership). The backend must never (also not indirectly) hold a shared pointer to any of these entities because it would introduce a closed ownership circle and the backend could never be deleted properly.</li>
<li>The ownership is depicted via solid line arrows, mostly from right to left. In the end the AsyncNDRegisterAccessors handed out to the user (green) are holding the whole trigger distribution tree. (except for the <a class="el" href="class_chimera_t_k_1_1async_1_1_domains_container.html" title="The DomainsContainer has a container with Domains and is performing actions on all of them.">DomainsContainer</a> in blue)</li>
<li>When an accessor is requested, the request goes from the <a class="el" href="class_chimera_t_k_1_1async_1_1_domains_container.html" title="The DomainsContainer has a container with Domains and is performing actions on all of them.">DomainsContainer</a> through the <a class="el" href="class_chimera_t_k_1_1async_1_1_domain.html" title="The Domain is the thread-safe entry point for each distribution tree.">Domain</a> to the primary <a class="el" href="class_chimera_t_k_1_1async_1_1_sub_domain.html" title="Send backend-specific asynchronous data to different distributors:">SubDomain</a>, which creates all required MuxedInterruptDistributors, SubDomains, VariableDistributors or TriggeredPollDistributors when needed, and hands out the <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html" title="The AsyncNDRegisterAccessor implements a data transport queue with typed data as continuation of the ...">AsyncNDRegisterAccessor</a> which holds the ownership. It shares the ownership with other AsyncNDRegisterAccessors.</li>
<li>When the last owning AsyncNDRegisterAccessors goes out of scope, the according distributors are deleted.</li>
<li>If there are no subscribers, i.e. AsyncNDRegisterAccessors being held by the application, the <a class="el" href="class_chimera_t_k_1_1async_1_1_domain.html" title="The Domain is the thread-safe entry point for each distribution tree.">Domain</a> shared pointers are empty and trigger distribution does nothing.</li>
</ul>
<h6></h6>
<h2><a class="anchor" id="design_envisioned_DoocsDistributor"></a>
Vision: Using the VariableDistributor DOOCS backend</h2>
<h6></h6>
<blockquote class="doxtable">
<p><b>ATTENTION:</b> This section is the envisioned use in the DOOCS backend. It is not implemented yet and the framework and this vision probably need a few more iterations to make it work. </p>
</blockquote>
<div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_4.svg" width="1262" height="316"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<ul>
<li>The EqData object, which is send as an asynchonous event, is distributed in the case of DOOCS. It contains all the relevant data.</li>
<li>For each ZMQ-subscription there is one <a class="el" href="class_chimera_t_k_1_1async_1_1_domain.html" title="The Domain is the thread-safe entry point for each distribution tree.">Domain</a> with its <a class="el" href="class_chimera_t_k_1_1async_1_1_sub_domain.html" title="Send backend-specific asynchronous data to different distributors:">SubDomain</a> and one VariableDistributor&lt;EqData&gt;. The variable distributor takes care of interpreting the EqData and extracting the information to be filled into the subscribed AsyncNDRegisterAccessors.</li>
</ul>
<h6></h6>
<h1><a class="anchor" id="design_AsyncNDRegisterAccessor"></a>
The AsyncNDRegisterAccessor and the AsyncAccessorManager</h1>
<h6></h6>
<p>The <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html" title="The AsyncNDRegisterAccessor implements a data transport queue with typed data as continuation of the ...">AsyncNDRegisterAccessor</a> is a generic <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html" title="N-dimensional register accessor.">NDRegisterAccessor</a> implementation for push-type data. It is used if accessors with <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read.">AccessMode::wait_for_new_data</a> are requested. See <a class="el" href="spec__transfer_element.html#transferElement_B_8">Technical specification: TransferElement B.8</a> for the requirements it is based on.</p>
<p>The <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html" title="The AsyncNDRegisterAccessor implements a data transport queue with typed data as continuation of the ...">AsyncNDRegisterAccessor</a> is a generic implementation which can be used for all backends and contains the following components</p>
<ul>
<li>a lock free queue to transport data of type NDRegisterAccessor&lt;UserType&gt;::Buffer, which contains the data value (2D vector of UserType), a <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation.">VersionNumber</a> and a DataValidity flag.</li>
<li>functions to push data and exceptions into the queue</li>
</ul>
<p><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html" title="The AsyncNDRegisterAccessor implements a data transport queue with typed data as continuation of the ...">AsyncNDRegisterAccessor</a> are read-only. If you want to write to the register you have to get an <a class="el" href="class_accessor.html">Accessor</a> without "wait_for_new_data". (N.B. in NumericAddressedBackends this is not possible, the push-type data is intrinsically read only there. For Doocs-Backends with ZMQ data it is possible to get an <a class="el" href="class_accessor.html">Accessor</a> for writing.)</p>
<p>For each primary interrupt or event there is one <a class="el" href="class_chimera_t_k_1_1async_1_1_domain.html" title="The Domain is the thread-safe entry point for each distribution tree.">async::Domain</a>. All the distribution tree behind it belongs to that <a class="el" href="class_chimera_t_k_1_1async_1_1_domain.html" title="The Domain is the thread-safe entry point for each distribution tree.">Domain</a>.</p><ul>
<li>For backends with void interrupts, there is always one primary InterruptDistributor associated to the <a class="el" href="class_chimera_t_k_1_1async_1_1_domain.html" title="The Domain is the thread-safe entry point for each distribution tree.">Domain</a>, followed by a <a class="el" href="class_chimera_t_k_1_1async_1_1_triggered_poll_distributor.html" title="The TriggeredPollDistributor has std::nullptr_t source data type and is polling the data for the Asyn...">TriggeredPollDistributor</a>, a void-type <a class="el" href="class_chimera_t_k_1_1async_1_1_variable_distributor.html">VariableDistributor</a> and/or an InterruptControllHandler. The latter has one InterruptDistributor per sub interrupt, which again can distribute to a <a class="el" href="class_chimera_t_k_1_1async_1_1_triggered_poll_distributor.html" title="The TriggeredPollDistributor has std::nullptr_t source data type and is polling the data for the Asyn...">TriggeredPollDistributor</a>, a <a class="el" href="class_chimera_t_k_1_1async_1_1_variable_distributor.html">VariableDistributor</a> and/or an InterruptControllHandler etc.</li>
<li>For push-type data (data events), there is a one distributor of the backend-specific source type, which then distributes further to the subscribed AsyncRegisterAccessors. &ndash; Example 1 (envisioned use case, not implemented yet): For Doocs, a VariableDistributor&lt;EqData&gt; is getting an EqData object which contains a double, and the has subsribers of user type doule, int and string. The VariableDistributor&lt;EqData&gt; in combination with the according AsyncVariables takes care of converting the data into the user types and filling the user-type send buffers. &ndash; Example 2 (envisioned use case, not implemented yet): EqData with an IFFF is distributed via an IFFFDistributor (also derived from <a class="el" href="class_chimera_t_k_1_1async_1_1_async_accessor_manager.html" title="The AsyncAccessorManager has three main functionalities:">AsyncAccessorManager</a> like <a class="el" href="class_chimera_t_k_1_1async_1_1_variable_distributor.html">VariableDistributor</a> and <a class="el" href="class_chimera_t_k_1_1async_1_1_triggered_poll_distributor.html" title="The TriggeredPollDistributor has std::nullptr_t source data type and is polling the data for the Asyn...">TriggeredPollDistributor</a>.). You can have individual subscriptions for each component (one integer and three floats).</li>
<li>The <a class="el" href="class_chimera_t_k_1_1async_1_1_variable_distributor.html">VariableDistributor</a> has a copy of the last distributed data. This is used as initial value for a new subscription.</li>
</ul>
<p>The <a class="el" href="class_chimera_t_k_1_1async_1_1_async_accessor_manager.html" title="The AsyncAccessorManager has three main functionalities:">AsyncAccessorManager</a> has three main functions:</p>
<ul>
<li>It serves as a factory for AsyncNDRegisterAccessors</li>
<li>It contains a list of created asynchronous accessors and a subscribe/unsubscribe mechanism</li>
<li>It provides functions to act on all asynchronous accessors</li>
</ul>
<h6></h6>
<h2><a class="anchor" id="AsyncNDRegisterAccessor_details"></a>
Design decisions and implementation details</h2>
<h6></h6>
<ul>
<li>The data transport queue contains data that is already converted to the UserType, so the potentially expensive and slow operations (data readout, de-multiplexing, data conversion) are happening only once, before the data is distributed to multiple subscribers.</li>
<li>To unsubscribe, the <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html" title="N-dimensional register accessor.">NDRegisterAccessor</a> is calling <a class="el" href="class_chimera_t_k_1_1async_1_1_async_accessor_manager.html#a8b9c1fda699e1d2cd259a7337eac528a" title="This function must only be called from the destructor of the AsyncNDRegisterAccessor which is created...">AsyncAccessorManager::unsubscribe()</a> with its <a class="el" href="class_chimera_t_k_1_1_transfer_element_i_d.html" title="Simple class holding a unique ID for a TransferElement.">TransferElementID</a> from the destructor.</li>
<li>The class <a class="el" href="struct_chimera_t_k_1_1async_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a> represents the sender side of the asynchronous accessor.<a class="el" href="design__async_n_d_register_accessor__numeric_addressed.html#asyncAccessor_comment_AsyncVariable">(*)</a> It provides functions to send data and exceptions, and it implements all the handling of the contained <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html" title="The AsyncNDRegisterAccessor implements a data transport queue with typed data as continuation of the ...">AsyncNDRegisterAccessor</a> instance. In addition it provides shape information for creating AsyncNDRegisterAccessors to the <a class="el" href="class_chimera_t_k_1_1async_1_1_async_accessor_manager.html" title="The AsyncAccessorManager has three main functionalities:">AsyncAccessorManager</a>.</li>
<li>A send buffer is contained in the <a class="el" href="struct_chimera_t_k_1_1async_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a> to avoid dynamic memory allocation.</li>
<li>The void notification queue in the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> base class is set up as a continuation of the data transport queue, such that the read operations of the notification queue trigger the filling of the user buffer.</li>
</ul>
<p><a class="anchor" id="asyncAccessor_comment_AsyncVariable"></a>(*) C++ implementation detail: There is <a class="el" href="struct_chimera_t_k_1_1async_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a> as an untyped base class and <a class="el" href="struct_chimera_t_k_1_1async_1_1_async_variable_impl.html" title="AsyncVariableImpl contains a weak pointer to an AsyncNDRegisterAccessor&lt;UserType&gt; and a send buffer N...">AsyncVariableImpl</a>, which is templated to a user type. Like this pointers to variables with different user types can be stored in one list.</p>
<h6></h6>
<h2><a class="anchor" id="AsyncNDRegisterAccessor_exceptions"></a>
Exception handling</h2>
<h6></h6>
<ul>
<li>Some classes like the <a class="el" href="class_chimera_t_k_1_1async_1_1_triggered_poll_distributor.html" title="The TriggeredPollDistributor has std::nullptr_t source data type and is polling the data for the Asyn...">TriggeredPollDistributor</a> and the MuxedInterruptDistributors need to access the hardware.</li>
<li>As this code is called from within a thread, no exceptions must escape. However, in case of an exception the backend's setException() must be called to inform the user application.</li>
<li><a class="el" href="class_chimera_t_k_1_1async_1_1_triggered_poll_distributor.html" title="The TriggeredPollDistributor has std::nullptr_t source data type and is polling the data for the Asyn...">TriggeredPollDistributor</a> and the MuxedInterruptDistributors do HW access via regular, synchrous accessors, which call the backend's setException() when an exception occurs. They just suppress the exception coming out of the accessor.</li>
<li>In setException(), the exceptions must be distributed to all async accessors. This is done through the same three as the trigger distribution.</li>
<li>As creation of accessors and distribution must not happen at the same time and are in different threads, inevitably there are locks involved. In addition, the backend might use locks internally.</li>
<li>As setException() can occur during the regular distribution, this would be a recursive iteration of the tree if it happens in the same threads, which can lead to deadlocks or lock order inversions.</li>
<li>To avoid lock order inversion, recursive tree iteration is prevented. There is only one lock in the <a class="el" href="class_chimera_t_k_1_1async_1_1_domain.html" title="The Domain is the thread-safe entry point for each distribution tree.">Domain</a>, which protects the whole tree behind it.</li>
<li>To implement the exception distribution, there is a thread in the <a class="el" href="class_chimera_t_k_1_1async_1_1_domains_container.html" title="The DomainsContainer has a container with Domains and is performing actions on all of them.">DomainsContainer</a>. setException() in informing that thread that exceptions should be distributed and then returns, such that the distribution call which executed setException() can return. The lock in the <a class="el" href="class_chimera_t_k_1_1async_1_1_domain.html" title="The Domain is the thread-safe entry point for each distribution tree.">Domain</a> is freed, and the exception distribution thread can get it.</li>
</ul>
<h6></h6>
<h2><a class="anchor" id="AsyncNDRegisterAccessor_usage"></a>
Interface for implementing backends</h2>
<h6></h6>
<p>Requirement for each backend:</p><ul>
<li>Provide (one or more) implementations of a VariableDistributor&lt;BackendSpecificDataType&gt;.</li>
<li>Provide a template-function <pre>
  template&lt;typename BackendSpecificUserType&gt;
  std::pair&lt;BackendSpecificUserType, VersionNumber&gt; getAsyncDomainInitialValue(size_t asyncDomainId);
</pre></li>
<li>Implement the virtual function (Fixme: This is NumericAddressed only at the moment. Should be generalised) <pre>
  std::future&lt;void&gt; activateSubscription(uint32_t interruptNumber, boost::shared_ptr&lt;async::DomainImpl&lt;BackendSpecificDataType&gt;&gt; asyncDomain);
</pre> Backends deriving from <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend.html" title="Base class for address-based device backends (e.g.">NumericAddressedBackend</a> create the interrupt handling thread here, and store the asyncDomain to call it from inside the thread.</li>
<li>Call <a class="el" href="class_chimera_t_k_1_1async_1_1_domains_container.html#a0f2f2b2ddf058f8d3f6d764eff583e23" title="Get an accessor from a particular domain.">DomainsContainer::subscribe()</a> in getRegisterAccessor() to create and hand out AsyncNDRegisterAccesors.</li>
<li>Fixme: should move to <a class="el" href="class_chimera_t_k_1_1_device_backend_impl.html" title="DeviceBackendImpl implements some basic functionality which should be available for all backends.">DeviceBackendImpl</a>: Activate all AsyncDomains in activateAsyncRead, and call activateSubscription() for it.</li>
</ul>
<p><a class="anchor" id="asyncAccessor_comment_AsyncVariable2"></a>(*2) The reason to put this into the <a class="el" href="struct_chimera_t_k_1_1async_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a> is coming from the <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend.html" title="Base class for address-based device backends (e.g.">NumericAddressedBackend</a>. It adds a synchronous accessor to the <a class="el" href="struct_chimera_t_k_1_1async_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a> which is used for reading and provides this information. The logic to generate this information is in the creation code for the synchronous accessor. Other backends might have similar advantages from having the functions the <a class="el" href="struct_chimera_t_k_1_1async_1_1_async_variable.html" title="Typeless base class.">AsyncVariable</a>, or at least they don't care much where the functions are implemented.</p>
<h1><a class="anchor" id="design_async_NumericAddressedBackend"></a>
Implementation in the NumericAddressedBackend</h1>
<h2><a class="anchor" id="design_async_map_file"></a>
Asynchronous registers in the map file</h2>
<pre>
# name            nElements  address  nBytes  bar  width  bitInterpretation signed accessMode
APP.0.DATA_READY          0        0       0    0      0                  0      0 INTERRUPT1
APP.0.PUSH_DATA           4       12      16    1     32                  8      1 INTERRUPT2
</pre><p>The map file has a special access mode INTERRUPTx, in addition to the synchronous modes RW and RO. x is the numeric identifyer for a device interrupt. Registers with access mode INTERRUPT are treated as read-only. Sub-interrupts (INTERRUPTx:y, INTERRUPTx:y:z, etc.) are supported in combination with MuxedInterruptDistributors (see below).</p>
<p>For interrupts it is possible to have void-type entries. The width of these "registers" is 0 bits. For consistency all other fields also have to be 0. They don't make sense in this context and have to be 0 to avoid confusion.</p>
<h3><a class="anchor" id="design_async_canonical_interrupt_name"></a>
Canonical interrupt names</h3>
<p>For each interrupt and sub-interrupt it is possible to get a void accessor via the canonical interrupt name '!x:y:z:'. For instance for an interrupt with data on INTERRUPT3:9:4, it is possible to get void accessors for '!3', '!3:9' and '!3:9:4'. This is useful to check whether a primary interrupt has arrived, or any interrupt on the controller 3:9. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Aug 27 2024 18:55:09 for ChimeraTK-DeviceAccess by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
