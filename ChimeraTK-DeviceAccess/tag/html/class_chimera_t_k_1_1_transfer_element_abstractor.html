<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ChimeraTK-DeviceAccess: ChimeraTK::TransferElementAbstractor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ChimeraTK_Logo_whitebg.png"/></td>
  <td id="projectalign">
   <div id="projectname">ChimeraTK-DeviceAccess<span id="projectnumber">&#160;03.24.01</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_chimera_t_k_1_1_transfer_element_abstractor.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_chimera_t_k_1_1_transfer_element_abstractor-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ChimeraTK::TransferElementAbstractor Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_chimera_t_k_1_1_base.html">Base</a> class for register accessors abstractors independent of the UserType.  
 <a href="class_chimera_t_k_1_1_transfer_element_abstractor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for ChimeraTK::TransferElementAbstractor:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="class_chimera_t_k_1_1_transfer_element_abstractor__inherit__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5fc3bd8768619d4f4625842b82ecdf2f" id="r_a5fc3bd8768619d4f4625842b82ecdf2f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a5fc3bd8768619d4f4625842b82ecdf2f">TransferElementAbstractor</a> (boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt; impl)</td></tr>
<tr class="memdesc:a5fc3bd8768619d4f4625842b82ecdf2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> implementation.  <br /></td></tr>
<tr class="separator:a5fc3bd8768619d4f4625842b82ecdf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8551b10b0f394763b5a250d1d5d53c" id="r_abd8551b10b0f394763b5a250d1d5d53c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#abd8551b10b0f394763b5a250d1d5d53c">TransferElementAbstractor</a> ()=default</td></tr>
<tr class="memdesc:abd8551b10b0f394763b5a250d1d5d53c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an uninitialised abstractor - just for late initialisation.  <br /></td></tr>
<tr class="separator:abd8551b10b0f394763b5a250d1d5d53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdf66927b87f55a333ec0fcdfe8873e" id="r_afcdf66927b87f55a333ec0fcdfe8873e"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#afcdf66927b87f55a333ec0fcdfe8873e">getName</a> () const</td></tr>
<tr class="memdesc:afcdf66927b87f55a333ec0fcdfe8873e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name that identifies the process variable.  <br /></td></tr>
<tr class="separator:afcdf66927b87f55a333ec0fcdfe8873e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6356a39bcb73ef14cfa3b609576def" id="r_afb6356a39bcb73ef14cfa3b609576def"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#afb6356a39bcb73ef14cfa3b609576def">getUnit</a> () const</td></tr>
<tr class="memdesc:afb6356a39bcb73ef14cfa3b609576def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the engineering unit.  <br /></td></tr>
<tr class="separator:afb6356a39bcb73ef14cfa3b609576def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed273e12e06d031eb130c7c27a63728" id="r_a5ed273e12e06d031eb130c7c27a63728"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a5ed273e12e06d031eb130c7c27a63728">getDescription</a> () const</td></tr>
<tr class="memdesc:a5ed273e12e06d031eb130c7c27a63728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the description of this variable/register.  <br /></td></tr>
<tr class="separator:a5ed273e12e06d031eb130c7c27a63728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484eb9101cf36e01d4d31d0acd1b597b" id="r_a484eb9101cf36e01d4d31d0acd1b597b"><td class="memItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a484eb9101cf36e01d4d31d0acd1b597b">getValueType</a> () const</td></tr>
<tr class="memdesc:a484eb9101cf36e01d4d31d0acd1b597b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>std::type_info</code> for the value type of this transfer element.  <br /></td></tr>
<tr class="separator:a484eb9101cf36e01d4d31d0acd1b597b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc639d986bbab7f30b86c6f8f8596e57" id="r_acc639d986bbab7f30b86c6f8f8596e57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_access_mode_flags.html">AccessModeFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#acc639d986bbab7f30b86c6f8f8596e57">getAccessModeFlags</a> () const</td></tr>
<tr class="memdesc:acc639d986bbab7f30b86c6f8f8596e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="class_chimera_t_k_1_1_access_mode_flags.html" title="Set of AccessMode flags with additional functionality for an easier handling.">AccessModeFlags</a> for this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>.  <br /></td></tr>
<tr class="separator:acc639d986bbab7f30b86c6f8f8596e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66980fe7b7c0dc937361e71b1750767f" id="r_a66980fe7b7c0dc937361e71b1750767f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a66980fe7b7c0dc937361e71b1750767f">read</a> ()</td></tr>
<tr class="memdesc:a66980fe7b7c0dc937361e71b1750767f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from the device.  <br /></td></tr>
<tr class="separator:a66980fe7b7c0dc937361e71b1750767f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96628a4ab593aff6f21d06cac6661b8" id="r_aa96628a4ab593aff6f21d06cac6661b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#aa96628a4ab593aff6f21d06cac6661b8">readNonBlocking</a> ()</td></tr>
<tr class="memdesc:aa96628a4ab593aff6f21d06cac6661b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next value, if available in the input buffer.  <br /></td></tr>
<tr class="separator:aa96628a4ab593aff6f21d06cac6661b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11934cb06f61290f398e22428b26a005" id="r_a11934cb06f61290f398e22428b26a005"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a11934cb06f61290f398e22428b26a005">readLatest</a> ()</td></tr>
<tr class="memdesc:a11934cb06f61290f398e22428b26a005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the latest value, discarding any other update since the last read if present.  <br /></td></tr>
<tr class="separator:a11934cb06f61290f398e22428b26a005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05416264bd9c68ac18d9ba5b476cc801" id="r_a05416264bd9c68ac18d9ba5b476cc801"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a05416264bd9c68ac18d9ba5b476cc801">getVersionNumber</a> () const</td></tr>
<tr class="memdesc:a05416264bd9c68ac18d9ba5b476cc801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the version number that is associated with the last transfer (i.e.  <br /></td></tr>
<tr class="separator:a05416264bd9c68ac18d9ba5b476cc801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281b905219e719a1a0cdbd9d8d42d1dd" id="r_a281b905219e719a1a0cdbd9d8d42d1dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a281b905219e719a1a0cdbd9d8d42d1dd">write</a> (<a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> versionNumber={})</td></tr>
<tr class="memdesc:a281b905219e719a1a0cdbd9d8d42d1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the data to device.  <br /></td></tr>
<tr class="separator:a281b905219e719a1a0cdbd9d8d42d1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53668fb61c4310fa8f1a11d8e414cbc8" id="r_a53668fb61c4310fa8f1a11d8e414cbc8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a53668fb61c4310fa8f1a11d8e414cbc8">writeDestructively</a> (<a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> versionNumber={})</td></tr>
<tr class="memdesc:a53668fb61c4310fa8f1a11d8e414cbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like <a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7aefb2a684e4afb7d55e6147fbe5a332ee">write()</a>, but allows the implementation to destroy the content of the user buffer in the process.  <br /></td></tr>
<tr class="separator:a53668fb61c4310fa8f1a11d8e414cbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb675e7a009887922e8975c92cb13435" id="r_adb675e7a009887922e8975c92cb13435"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#adb675e7a009887922e8975c92cb13435">isReadOnly</a> () const</td></tr>
<tr class="memdesc:adb675e7a009887922e8975c92cb13435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is read only, i.e.  <br /></td></tr>
<tr class="separator:adb675e7a009887922e8975c92cb13435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6532a803d31c0bcd2f3c63b7610ab8" id="r_a4b6532a803d31c0bcd2f3c63b7610ab8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a4b6532a803d31c0bcd2f3c63b7610ab8">isReadable</a> () const</td></tr>
<tr class="memdesc:a4b6532a803d31c0bcd2f3c63b7610ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is readable.  <br /></td></tr>
<tr class="separator:a4b6532a803d31c0bcd2f3c63b7610ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e81454408558284a43b35cf5528c490" id="r_a6e81454408558284a43b35cf5528c490"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a6e81454408558284a43b35cf5528c490">isWriteable</a> () const</td></tr>
<tr class="memdesc:a6e81454408558284a43b35cf5528c490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is writeable.  <br /></td></tr>
<tr class="separator:a6e81454408558284a43b35cf5528c490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e4e4f86c916307f345e99cf0a7915f" id="r_a82e4e4f86c916307f345e99cf0a7915f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a82e4e4f86c916307f345e99cf0a7915f">getHardwareAccessingElements</a> ()</td></tr>
<tr class="memdesc:a82e4e4f86c916307f345e99cf0a7915f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the underlying TransferElements with actual hardware access.  <br /></td></tr>
<tr class="separator:a82e4e4f86c916307f345e99cf0a7915f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274009bf1b3a598699ff725778011768" id="r_a274009bf1b3a598699ff725778011768"><td class="memItemLeft" align="right" valign="top">std::list&lt; boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a274009bf1b3a598699ff725778011768">getInternalElements</a> ()</td></tr>
<tr class="memdesc:a274009bf1b3a598699ff725778011768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the full list of TransferElements internally used by this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>.  <br /></td></tr>
<tr class="separator:a274009bf1b3a598699ff725778011768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ae997b6b9121229c466fba4a2e341d" id="r_a14ae997b6b9121229c466fba4a2e341d"><td class="memItemLeft" align="right" valign="top">const boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a14ae997b6b9121229c466fba4a2e341d">getHighLevelImplElement</a> ()</td></tr>
<tr class="memdesc:a14ae997b6b9121229c466fba4a2e341d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the highest level implementation <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>.  <br /></td></tr>
<tr class="separator:a14ae997b6b9121229c466fba4a2e341d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4016da23732e91a38e484e8cf9808f67" id="r_a4016da23732e91a38e484e8cf9808f67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a4016da23732e91a38e484e8cf9808f67">isInitialised</a> () const</td></tr>
<tr class="memdesc:a4016da23732e91a38e484e8cf9808f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if the accessor is properly initialised.  <br /></td></tr>
<tr class="separator:a4016da23732e91a38e484e8cf9808f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67bef82a23eb01b2e9f20de95ca0a75" id="r_aa67bef82a23eb01b2e9f20de95ca0a75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#aa67bef82a23eb01b2e9f20de95ca0a75">replace</a> (const <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html">TransferElementAbstractor</a> &amp;newAccessor)</td></tr>
<tr class="memdesc:aa67bef82a23eb01b2e9f20de95ca0a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a new accessor to this <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html" title="Base class for register accessors abstractors independent of the UserType.">TransferElementAbstractor</a>.  <br /></td></tr>
<tr class="separator:aa67bef82a23eb01b2e9f20de95ca0a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a21c83adc1ea35f76989a98ef1213a" id="r_ae4a21c83adc1ea35f76989a98ef1213a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#ae4a21c83adc1ea35f76989a98ef1213a">replace</a> (boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt; newImpl)</td></tr>
<tr class="memdesc:ae4a21c83adc1ea35f76989a98ef1213a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative signature of relace() with the same functionality, used when a pointer to the implementation has been obtained directly (instead of a <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html" title="Base class for register accessors abstractors independent of the UserType.">TransferElementAbstractor</a>).  <br /></td></tr>
<tr class="separator:ae4a21c83adc1ea35f76989a98ef1213a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89c3e0968687c7cf798581cd989d20a" id="r_aa89c3e0968687c7cf798581cd989d20a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#aa89c3e0968687c7cf798581cd989d20a">replaceTransferElement</a> (const boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt; &amp;newElement)</td></tr>
<tr class="memdesc:aa89c3e0968687c7cf798581cd989d20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for all underlying TransferElements which are considered identical (see mayReplaceOther()) with the given <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>.  <br /></td></tr>
<tr class="separator:aa89c3e0968687c7cf798581cd989d20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781f771e098890bc458ea65e24cea376" id="r_a781f771e098890bc458ea65e24cea376"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a781f771e098890bc458ea65e24cea376">setPersistentDataStorage</a> (boost::shared_ptr&lt; ChimeraTK::PersistentDataStorage &gt; storage)</td></tr>
<tr class="memdesc:a781f771e098890bc458ea65e24cea376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate a persistent data storage object to be updated on each write operation of this ProcessArray.  <br /></td></tr>
<tr class="separator:a781f771e098890bc458ea65e24cea376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4c01a7604516958f57d8ec67f4aa5e" id="r_afb4c01a7604516958f57d8ec67f4aa5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_transfer_element_i_d.html">TransferElementID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#afb4c01a7604516958f57d8ec67f4aa5e">getId</a> () const</td></tr>
<tr class="memdesc:afb4c01a7604516958f57d8ec67f4aa5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain unique ID for the actual implementation of this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>.  <br /></td></tr>
<tr class="separator:afb4c01a7604516958f57d8ec67f4aa5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1faf0fed03eb94768e3127b0eb067fb" id="r_ad1faf0fed03eb94768e3127b0eb067fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#ad1faf0fed03eb94768e3127b0eb067fb">setDataValidity</a> (<a class="el" href="namespace_chimera_t_k.html#a9a7d226a45242c6825eb7a26235298df">DataValidity</a> valid=<a class="el" href="namespace_chimera_t_k.html#a9a7d226a45242c6825eb7a26235298dfa444bcb3a3fcf8389296c49467f27e1d6">DataValidity::ok</a>)</td></tr>
<tr class="memdesc:ad1faf0fed03eb94768e3127b0eb067fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current DataValidity for this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>.  <br /></td></tr>
<tr class="separator:ad1faf0fed03eb94768e3127b0eb067fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90132a50a99c2bff143b4937ff242789" id="r_a90132a50a99c2bff143b4937ff242789"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_chimera_t_k.html#a9a7d226a45242c6825eb7a26235298df">DataValidity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a90132a50a99c2bff143b4937ff242789">dataValidity</a> () const</td></tr>
<tr class="memdesc:a90132a50a99c2bff143b4937ff242789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return current validity of the data.  <br /></td></tr>
<tr class="separator:a90132a50a99c2bff143b4937ff242789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc158c26e1523d3b1ef1f5a3bbfcc07" id="r_a3fc158c26e1523d3b1ef1f5a3bbfcc07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a3fc158c26e1523d3b1ef1f5a3bbfcc07">interrupt</a> ()</td></tr>
<tr class="memdesc:a3fc158c26e1523d3b1ef1f5a3bbfcc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return from a blocking read immediately and throw boost::thread_interrupted.  <br /></td></tr>
<tr class="separator:a3fc158c26e1523d3b1ef1f5a3bbfcc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8fdf8df3b0e5a41749d13698035648" id="r_a8e8fdf8df3b0e5a41749d13698035648"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_read_any_group.html">ReadAnyGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a8e8fdf8df3b0e5a41749d13698035648">getReadAnyGroup</a> () const</td></tr>
<tr class="memdesc:a8e8fdf8df3b0e5a41749d13698035648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the <a class="el" href="class_chimera_t_k_1_1_read_any_group.html" title="Group several registers (= TransferElement) to allow waiting for an update of any of the registers.">ReadAnyGroup</a> this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> is part of, or nullptr if not in a <a class="el" href="class_chimera_t_k_1_1_read_any_group.html" title="Group several registers (= TransferElement) to allow waiting for an update of any of the registers.">ReadAnyGroup</a>.  <br /></td></tr>
<tr class="separator:a8e8fdf8df3b0e5a41749d13698035648"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aea884943cf09b1544983a16d9438ae18" id="r_aea884943cf09b1544983a16d9438ae18"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#aea884943cf09b1544983a16d9438ae18">_impl</a></td></tr>
<tr class="memdesc:aea884943cf09b1544983a16d9438ae18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Untyped pointer to implementation.  <br /></td></tr>
<tr class="separator:aea884943cf09b1544983a16d9438ae18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_chimera_t_k_1_1_base.html">Base</a> class for register accessors abstractors independent of the UserType. </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00028">28</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5fc3bd8768619d4f4625842b82ecdf2f" name="a5fc3bd8768619d4f4625842b82ecdf2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc3bd8768619d4f4625842b82ecdf2f">&#9670;&#160;</a></span>TransferElementAbstractor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChimeraTK::TransferElementAbstractor::TransferElementAbstractor </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td>
          <td class="paramname"><em>impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> implementation. </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00031">31</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="abd8551b10b0f394763b5a250d1d5d53c" name="abd8551b10b0f394763b5a250d1d5d53c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8551b10b0f394763b5a250d1d5d53c">&#9670;&#160;</a></span>TransferElementAbstractor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChimeraTK::TransferElementAbstractor::TransferElementAbstractor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an uninitialised abstractor - just for late initialisation. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a90132a50a99c2bff143b4937ff242789" name="a90132a50a99c2bff143b4937ff242789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90132a50a99c2bff143b4937ff242789">&#9670;&#160;</a></span>dataValidity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_chimera_t_k.html#a9a7d226a45242c6825eb7a26235298df">DataValidity</a> ChimeraTK::TransferElementAbstractor::dataValidity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return current validity of the data. </p>
<p>Will always return <a class="el" href="namespace_chimera_t_k.html#a9a7d226a45242c6825eb7a26235298dfa444bcb3a3fcf8389296c49467f27e1d6">DataValidity::ok</a> if the backend does not support it </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00202">202</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="acc639d986bbab7f30b86c6f8f8596e57" name="acc639d986bbab7f30b86c6f8f8596e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc639d986bbab7f30b86c6f8f8596e57">&#9670;&#160;</a></span>getAccessModeFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1_access_mode_flags.html">AccessModeFlags</a> ChimeraTK::TransferElementAbstractor::getAccessModeFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the <a class="el" href="class_chimera_t_k_1_1_access_mode_flags.html" title="Set of AccessMode flags with additional functionality for an easier handling.">AccessModeFlags</a> for this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>. </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00051">51</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a5ed273e12e06d031eb130c7c27a63728" name="a5ed273e12e06d031eb130c7c27a63728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed273e12e06d031eb130c7c27a63728">&#9670;&#160;</a></span>getDescription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; ChimeraTK::TransferElementAbstractor::getDescription </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the description of this variable/register. </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00044">44</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a82e4e4f86c916307f345e99cf0a7915f" name="a82e4e4f86c916307f345e99cf0a7915f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e4e4f86c916307f345e99cf0a7915f">&#9670;&#160;</a></span>getHardwareAccessingElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt; &gt; ChimeraTK::TransferElementAbstractor::getHardwareAccessingElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the underlying TransferElements with actual hardware access. </p>
<p>If this transfer element is directly reading from / writing to the hardware, it will return a list just containing a shared pointer of itself.</p>
<p>Note: Avoid using this in application code, since it will break the abstraction! </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8cc_source.html#l00010">10</a> of file <a class="el" href="_transfer_element_abstractor_8cc_source.html">TransferElementAbstractor.cc</a>.</p>

</div>
</div>
<a id="a14ae997b6b9121229c466fba4a2e341d" name="a14ae997b6b9121229c466fba4a2e341d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ae997b6b9121229c466fba4a2e341d">&#9670;&#160;</a></span>getHighLevelImplElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt; &amp; ChimeraTK::TransferElementAbstractor::getHighLevelImplElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the highest level implementation <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>. </p>
<p>For TransferElements which are itself an implementation this will directly return a shared pointer to this. If this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> is a user frontend, the pointer to the internal implementation is returned.</p>
<p>Note: Avoid using this in application code, since it will break the abstraction! </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00145">145</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="afb4c01a7604516958f57d8ec67f4aa5e" name="afb4c01a7604516958f57d8ec67f4aa5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4c01a7604516958f57d8ec67f4aa5e">&#9670;&#160;</a></span>getId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1_transfer_element_i_d.html">TransferElementID</a> ChimeraTK::TransferElementAbstractor::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain unique ID for the actual implementation of this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>. </p>
<p>This means that e.g. two instances of <a class="el" href="class_chimera_t_k_1_1_scalar_register_accessor.html" title="Accessor class to read and write scalar registers transparently by using the accessor object like a v...">ScalarRegisterAccessor</a> created by the same call to <a class="el" href="class_chimera_t_k_1_1_device.html#a953db6616908b17380fb1ace248c5a77" title="Get a ScalarRegisterObject object for the given register.">Device::getScalarRegisterAccessor()</a> (e.g. by copying the accessor to another using NDRegisterAccessorBridge::replace()) will have the same ID, while two instances obtained by to difference calls to <a class="el" href="class_chimera_t_k_1_1_device.html#a953db6616908b17380fb1ace248c5a77" title="Get a ScalarRegisterObject object for the given register.">Device::getScalarRegisterAccessor()</a> will have a different ID even when accessing the very same register. </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00192">192</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a274009bf1b3a598699ff725778011768" name="a274009bf1b3a598699ff725778011768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274009bf1b3a598699ff725778011768">&#9670;&#160;</a></span>getInternalElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt; &gt; ChimeraTK::TransferElementAbstractor::getInternalElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the full list of TransferElements internally used by this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>. </p>
<p>The function is recursive, i.e. elements used by the elements returned by this function are also added to the list. It is guaranteed that the directly used elements are first in the list and the result from recursion is appended to the list.</p>
<p>Example: A decorator would return a list with its target <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> followed by the result of <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a274009bf1b3a598699ff725778011768" title="Obtain the full list of TransferElements internally used by this TransferElement.">getInternalElements()</a> called on its target <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>.</p>
<p>If this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> is not using any other element, it should return an empty vector. Thus those elements which return a list just containing themselves in <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a82e4e4f86c916307f345e99cf0a7915f" title="Obtain the underlying TransferElements with actual hardware access.">getHardwareAccessingElements()</a> will return an empty list here in <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a274009bf1b3a598699ff725778011768" title="Obtain the full list of TransferElements internally used by this TransferElement.">getInternalElements()</a>.</p>
<p>Note: Avoid using this in application code, since it will break the abstraction! </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8cc_source.html#l00016">16</a> of file <a class="el" href="_transfer_element_abstractor_8cc_source.html">TransferElementAbstractor.cc</a>.</p>

</div>
</div>
<a id="afcdf66927b87f55a333ec0fcdfe8873e" name="afcdf66927b87f55a333ec0fcdfe8873e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcdf66927b87f55a333ec0fcdfe8873e">&#9670;&#160;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; ChimeraTK::TransferElementAbstractor::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name that identifies the process variable. </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00037">37</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a8e8fdf8df3b0e5a41749d13698035648" name="a8e8fdf8df3b0e5a41749d13698035648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8fdf8df3b0e5a41749d13698035648">&#9670;&#160;</a></span>getReadAnyGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1_read_any_group.html">ReadAnyGroup</a> * ChimeraTK::TransferElementAbstractor::getReadAnyGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the <a class="el" href="class_chimera_t_k_1_1_read_any_group.html" title="Group several registers (= TransferElement) to allow waiting for an update of any of the registers.">ReadAnyGroup</a> this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> is part of, or nullptr if not in a <a class="el" href="class_chimera_t_k_1_1_read_any_group.html" title="Group several registers (= TransferElement) to allow waiting for an update of any of the registers.">ReadAnyGroup</a>. </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00224">224</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="afb6356a39bcb73ef14cfa3b609576def" name="afb6356a39bcb73ef14cfa3b609576def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6356a39bcb73ef14cfa3b609576def">&#9670;&#160;</a></span>getUnit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; ChimeraTK::TransferElementAbstractor::getUnit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the engineering unit. </p>
<p>If none was specified, it will default to "n./a." </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00041">41</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a484eb9101cf36e01d4d31d0acd1b597b" name="a484eb9101cf36e01d4d31d0acd1b597b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484eb9101cf36e01d4d31d0acd1b597b">&#9670;&#160;</a></span>getValueType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::type_info &amp; ChimeraTK::TransferElementAbstractor::getValueType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <code>std::type_info</code> for the value type of this transfer element. </p>
<p>This can be used to determine the type at runtime. </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00048">48</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a05416264bd9c68ac18d9ba5b476cc801" name="a05416264bd9c68ac18d9ba5b476cc801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05416264bd9c68ac18d9ba5b476cc801">&#9670;&#160;</a></span>getVersionNumber()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> ChimeraTK::TransferElementAbstractor::getVersionNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the version number that is associated with the last transfer (i.e. </p>
<p>last read or write). See <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation.">ChimeraTK::VersionNumber</a> for details. </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00083">83</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a3fc158c26e1523d3b1ef1f5a3bbfcc07" name="a3fc158c26e1523d3b1ef1f5a3bbfcc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc158c26e1523d3b1ef1f5a3bbfcc07">&#9670;&#160;</a></span>interrupt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChimeraTK::TransferElementAbstractor::interrupt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return from a blocking read immediately and throw boost::thread_interrupted. </p>
<p>This function can be used to shutdown a thread waiting on data to arrive, which might never happen because the sending part of the application is already shut down, or there is no new data at the moment.</p>
<p>This function can only be used for TransferElements with <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read.">AccessMode::wait_for_new_data</a>. Otherwise it will throw a <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured.">ChimeraTK::logic_error</a>.</p>
<p>Note that this function does not stop the sending thread. It just places a boost::thread_interrupted exception on the _TransferElement::_readQueue, so a waiting <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a66980fe7b7c0dc937361e71b1750767f" title="Read the data from the device.">read()</a> has something to receive and returns. If regular data is put into the queue just before the exception, this is received first. Hence it is not guaranteed that the read call that is supposed to be interrupted will actually throw an exception. But it is guaranteed that it returns immediately. Also it is guaranteed that eventually the boost::thread_interrupted exception will be received.</p>
<p>See <a class="el" href="spec__transfer_element.html#transferElement_B_8_6">Technical specification: TransferElement B.8.6</a> </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00221">221</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a4016da23732e91a38e484e8cf9808f67" name="a4016da23732e91a38e484e8cf9808f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4016da23732e91a38e484e8cf9808f67">&#9670;&#160;</a></span>isInitialised()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChimeraTK::TransferElementAbstractor::isInitialised </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return if the accessor is properly initialised. </p>
<p>It is initialised if it was constructed passing the pointer to an implementation (a <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html" title="N-dimensional register accessor.">NDRegisterAccessor</a>), it is not initialised if it was constructed only using the placeholder constructor without arguments. </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00152">152</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a4b6532a803d31c0bcd2f3c63b7610ab8" name="a4b6532a803d31c0bcd2f3c63b7610ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6532a803d31c0bcd2f3c63b7610ab8">&#9670;&#160;</a></span>isReadable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChimeraTK::TransferElementAbstractor::isReadable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if transfer element is readable. </p>
<p>It throws an acception if you try to read and <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a4b6532a803d31c0bcd2f3c63b7610ab8" title="Check if transfer element is readable.">isReadable()</a> is not true. </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00107">107</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="adb675e7a009887922e8975c92cb13435" name="adb675e7a009887922e8975c92cb13435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb675e7a009887922e8975c92cb13435">&#9670;&#160;</a></span>isReadOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChimeraTK::TransferElementAbstractor::isReadOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if transfer element is read only, i.e. </p>
<p>it is readable but not writeable. </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00102">102</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a6e81454408558284a43b35cf5528c490" name="a6e81454408558284a43b35cf5528c490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e81454408558284a43b35cf5528c490">&#9670;&#160;</a></span>isWriteable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChimeraTK::TransferElementAbstractor::isWriteable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if transfer element is writeable. </p>
<p>It throws an acception if you try to write and <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a6e81454408558284a43b35cf5528c490" title="Check if transfer element is writeable.">isWriteable()</a> is not true. </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00112">112</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a66980fe7b7c0dc937361e71b1750767f" name="a66980fe7b7c0dc937361e71b1750767f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66980fe7b7c0dc937361e71b1750767f">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChimeraTK::TransferElementAbstractor::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data from the device. </p>
<p>If <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read.">AccessMode::wait_for_new_data</a> was set, this function will block until new data has arrived. Otherwise it still might block for a short time until the data transfer was complete. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="accessor1_d_8cpp-example.html#a7">accessor1D.cpp</a>, <a class="el" href="accessor2_d_8cpp-example.html#a6">accessor2D.cpp</a>, <a class="el" href="accessor2_d_multiplexed_8cpp-example.html#a7">accessor2D_multiplexed.cpp</a>, and <a class="el" href="basic_8cpp-example.html#a6">basic.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00057">57</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a11934cb06f61290f398e22428b26a005" name="a11934cb06f61290f398e22428b26a005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11934cb06f61290f398e22428b26a005">&#9670;&#160;</a></span>readLatest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChimeraTK::TransferElementAbstractor::readLatest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the latest value, discarding any other update since the last read if present. </p>
<p>Otherwise this function is identical to <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#aa96628a4ab593aff6f21d06cac6661b8" title="Read the next value, if available in the input buffer.">readNonBlocking()</a>, i.e. it will never wait for new values and it will return whether a new value was available if <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read.">AccessMode::wait_for_new_data</a> is set. </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00077">77</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="aa96628a4ab593aff6f21d06cac6661b8" name="aa96628a4ab593aff6f21d06cac6661b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96628a4ab593aff6f21d06cac6661b8">&#9670;&#160;</a></span>readNonBlocking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChimeraTK::TransferElementAbstractor::readNonBlocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the next value, if available in the input buffer. </p>
<p>If <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read.">AccessMode::wait_for_new_data</a> was set, this function returns immediately and the return value indicated if a new value was available (<code>true</code>) or not (<code>false</code>).</p>
<p>If <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read.">AccessMode::wait_for_new_data</a> was not set, this function is identical to <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html#a66980fe7b7c0dc937361e71b1750767f" title="Read the data from the device.">read()</a>, which will still return quickly. Depending on the actual transfer implementation, the backend might need to transfer data to obtain the current value before returning. Also this function is not guaranteed to be lock free. The return value will be always true in this mode. </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00070">70</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="ae4a21c83adc1ea35f76989a98ef1213a" name="ae4a21c83adc1ea35f76989a98ef1213a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a21c83adc1ea35f76989a98ef1213a">&#9670;&#160;</a></span>replace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChimeraTK::TransferElementAbstractor::replace </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td>
          <td class="paramname"><em>newImpl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternative signature of relace() with the same functionality, used when a pointer to the implementation has been obtained directly (instead of a <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html" title="Base class for register accessors abstractors independent of the UserType.">TransferElementAbstractor</a>). </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00166">166</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="aa67bef82a23eb01b2e9f20de95ca0a75" name="aa67bef82a23eb01b2e9f20de95ca0a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67bef82a23eb01b2e9f20de95ca0a75">&#9670;&#160;</a></span>replace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChimeraTK::TransferElementAbstractor::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html">TransferElementAbstractor</a> &amp;&#160;</td>
          <td class="paramname"><em>newAccessor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a new accessor to this <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html" title="Base class for register accessors abstractors independent of the UserType.">TransferElementAbstractor</a>. </p>
<p>Since another <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html" title="Base class for register accessors abstractors independent of the UserType.">TransferElementAbstractor</a> is passed as argument, both <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html" title="Base class for register accessors abstractors independent of the UserType.">TransferElementAbstractor</a> will then point to the same accessor and thus are sharing the same buffer. To obtain a new copy of the accessor with a distinct buffer, the corresponding getXXRegisterAccessor() function of <a class="el" href="class_chimera_t_k_1_1_device.html" title="Class allows to read/write registers from device.">Device</a> must be called. </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00160">160</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="aa89c3e0968687c7cf798581cd989d20a" name="aa89c3e0968687c7cf798581cd989d20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89c3e0968687c7cf798581cd989d20a">&#9670;&#160;</a></span>replaceTransferElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChimeraTK::TransferElementAbstractor::replaceTransferElement </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newElement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for all underlying TransferElements which are considered identical (see mayReplaceOther()) with the given <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>. </p>
<p>These TransferElements are then replaced with the new element. If no underlying element matches the new element, this function has no effect. </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8cc_source.html#l00024">24</a> of file <a class="el" href="_transfer_element_abstractor_8cc_source.html">TransferElementAbstractor.cc</a>.</p>

</div>
</div>
<a id="ad1faf0fed03eb94768e3127b0eb067fb" name="ad1faf0fed03eb94768e3127b0eb067fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1faf0fed03eb94768e3127b0eb067fb">&#9670;&#160;</a></span>setDataValidity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ChimeraTK::TransferElementAbstractor::setDataValidity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_chimera_t_k.html#a9a7d226a45242c6825eb7a26235298df">DataValidity</a>&#160;</td>
          <td class="paramname"><em>valid</em> = <code><a class="el" href="namespace_chimera_t_k.html#a9a7d226a45242c6825eb7a26235298dfa444bcb3a3fcf8389296c49467f27e1d6">DataValidity::ok</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current DataValidity for this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>. </p>
<p>Will do nothing if the backend does not support it </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00197">197</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a781f771e098890bc458ea65e24cea376" name="a781f771e098890bc458ea65e24cea376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781f771e098890bc458ea65e24cea376">&#9670;&#160;</a></span>setPersistentDataStorage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ChimeraTK::TransferElementAbstractor::setPersistentDataStorage </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; ChimeraTK::PersistentDataStorage &gt;&#160;</td>
          <td class="paramname"><em>storage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associate a persistent data storage object to be updated on each write operation of this ProcessArray. </p>
<p>If no persistent data storage as associated previously, the value from the persistent storage is read and send to the receiver.</p>
<p>Note: A call to this function will be ignored, if the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> does not support persistent data storage (e.g. read-only variables or device registers) </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>TODO does this make sense? </dd></dl>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8cc_source.html#l00037">37</a> of file <a class="el" href="_transfer_element_abstractor_8cc_source.html">TransferElementAbstractor.cc</a>.</p>

</div>
</div>
<a id="a281b905219e719a1a0cdbd9d8d42d1dd" name="a281b905219e719a1a0cdbd9d8d42d1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281b905219e719a1a0cdbd9d8d42d1dd">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChimeraTK::TransferElementAbstractor::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a>&#160;</td>
          <td class="paramname"><em>versionNumber</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the data to device. </p>
<p>The return value is true, old data was lost on the write transfer (e.g. due to an buffer overflow). In case of an unbuffered write transfer, the return value will always be false. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="accessor1_d_8cpp-example.html#a8">accessor1D.cpp</a>, <a class="el" href="accessor2_d_8cpp-example.html#a9">accessor2D.cpp</a>, and <a class="el" href="basic_8cpp-example.html#a7">basic.cpp</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00089">89</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<a id="a53668fb61c4310fa8f1a11d8e414cbc8" name="a53668fb61c4310fa8f1a11d8e414cbc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53668fb61c4310fa8f1a11d8e414cbc8">&#9670;&#160;</a></span>writeDestructively()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ChimeraTK::TransferElementAbstractor::writeDestructively </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a>&#160;</td>
          <td class="paramname"><em>versionNumber</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just like <a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7aefb2a684e4afb7d55e6147fbe5a332ee">write()</a>, but allows the implementation to destroy the content of the user buffer in the process. </p>
<p>This is an optional optimisation, hence there is a default implementation which just calls the normal doWriteTransfer(). In any case, the application must expect the user buffer of the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> to contain undefined data after calling this function. </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00233">233</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aea884943cf09b1544983a16d9438ae18" name="aea884943cf09b1544983a16d9438ae18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea884943cf09b1544983a16d9438ae18">&#9670;&#160;</a></span>_impl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a>&gt; ChimeraTK::TransferElementAbstractor::_impl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Untyped pointer to implementation. </p>

<p class="definition">Definition at line <a class="el" href="_transfer_element_abstractor_8h_source.html#l00228">228</a> of file <a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/scratch/dragon/sources/ChimeraTK-DeviceAccess/include/<a class="el" href="_transfer_element_abstractor_8h_source.html">TransferElementAbstractor.h</a></li>
<li>/scratch/dragon/sources/ChimeraTK-DeviceAccess/src/<a class="el" href="_transfer_element_abstractor_8cc_source.html">TransferElementAbstractor.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_chimera_t_k.html">ChimeraTK</a></li><li class="navelem"><a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html">TransferElementAbstractor</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
