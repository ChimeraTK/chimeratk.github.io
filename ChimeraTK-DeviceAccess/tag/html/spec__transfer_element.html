<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ChimeraTK-DeviceAccess: Technical specification: TransferElement V1.2</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ChimeraTK_Logo_whitebg.png"/></td>
  <td id="projectalign">
   <div id="projectname">ChimeraTK-DeviceAccess<span id="projectnumber">&#160;03.25.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('spec__transfer_element.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Technical specification: TransferElement V1.2</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><blockquote class="doxtable">
<p>&zwj;<b>NOTICE FOR FUTURE RELEASES: AVOID CHANGING THE NUMBERING!</b> The tests refer to the sections, incl.</p>
<p>links and unlinked references from tests or other parts of the specification. These break, or even worse become wrong, when they are not changed consistenty! </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md5"></a>
Introduction</h2>
<p>This document describes the behaviour of the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> base class, the <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html" title="N-dimensional register accessor.">NDRegisterAccessor</a> base class, as well as requirements for all implementations (backends and decorators). The behaviour has been defined such that consistent behaviour with other libraries in the framework is ensured, namely ApplicationCore with the specifications for exception handling, initial value propagation and propagation of the data validity flag.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
A. Definitions</h2>
<ul>
<li>1. A <em>process variable</em> is the logical entity which is accessed through the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>. Outside this document, it is sometimes also called register.<ul>
<li>1.1 A process variable can be read-only, write-only or read-write (bidirectional).</li>
<li>1.2 A process variable has a data type.</li>
<li>1.3 A process variable has a fixed <em>number of elements</em> and a <em>number of channels</em>.<ul>
<li>1.3.1 For scalars, both the number of elements and channels are 1.</li>
<li>1.3.2 For 1D arrays, the number of channels is 1.</li>
</ul>
</li>
</ul>
</li>
<li>2. A <em>device</em> is the logical entity which owns the <em>process variable</em>. The device can be a piece of hardware, another application or even the current application.<ul>
<li>2.1 The first two cases (piece of hardware and another application) are considered identical, since just different <em>backends</em> are used for the communication.</li>
<li>2.2 The third case (current application) is when using the ChimeraTK::ControlSystemAdapter::ProcessArray e.g. in ApplicationCore.</li>
<li>2.3 The application-side behavior of all three cases is identical. The requirements for the implementation are slightly different in some aspects. This will be mentioned where applicable.</li>
</ul>
</li>
<li>3. A <em>transfer</em> is the exchange of data between the application and the device, using a transfer protocol which determines the technical implementation. The protocol used for the transfer is determined by the backend and hence all details about the protocol are abstracted and not visible by the application.</li>
<li>4. An <em>operation</em> is the action taken by the application to read or write data from or to a device. An operation is related to a transfer, yet it is to be distinguished. The transfer can e.g. be initiated by the device, while the operation is always initiated by the application.</li>
<li>5.<a class="anchor" id="transferElement_A_5"></a>The <em>application buffer</em> (sometimes also called user buffer outside this document) is referring to the buffer containing the data and meta data, which is accessible to the application.<ul>
<li>5.1 It can be accessed through the following (non-virtual) functions:<ul>
<li><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#abd318c2ad0a1690fb18a61fe8d91f487" title="Get or set register accessor&#39;s buffer content (1D version).">NDRegisterAccessor::accessData()</a> / <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#a891f298ac5c1a11178e50801c4563141" title="Get or set register accessor&#39;s channel vector.">NDRegisterAccessor::accessChannel()</a> - gives access to <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#ab3e9f790076370e901fd8c6079ed6770" title="Buffer of converted data elements.">NDRegisterAccessor::buffer_2D</a></li>
<li><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a69298f31fe4a42e779bca3669d06c2bd" title="Returns the version number that is associated with the last transfer (i.e.">TransferElement::getVersionNumber()</a> - returns content of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a9ad34f0c2eaec6be3dc385f1c4acef46" title="The version number of the last successful transfer.">TransferElement::_versionNumber</a></li>
<li><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a739e4e90911c3af3fa9aef9c56b08cda" title="Return current validity of the data.">TransferElement::dataValidity()</a> - returns content of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a39c613419eebb2f29590fecded7a96d0" title="The validity of the data in the application buffer.">TransferElement::_dataValidity</a></li>
</ul>
</li>
<li>5.2 If not stated otherwise, the term <em>application buffer</em> refers to <b>all</b> components of the buffer.</li>
<li>5.3 The content of the buffer is filled with data from the device in read operations, and transferred to the device in write operations.</li>
<li>5.4 The content of the buffer can always be modified by the application. (*)</li>
<li>5.5 <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#ab3e9f790076370e901fd8c6079ed6770" title="Buffer of converted data elements.">NDRegisterAccessor::buffer_2D</a> is referred to as <em>data buffer</em>, while <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a9ad34f0c2eaec6be3dc385f1c4acef46" title="The version number of the last successful transfer.">TransferElement::_versionNumber</a> and <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a39c613419eebb2f29590fecded7a96d0" title="The validity of the data in the application buffer.">TransferElement::_dataValidity</a> form the <em>meta data buffer</em></li>
</ul>
</li>
<li>6. Placeholders are used to summarise various function names:<ul>
<li>6.1 xxxYyy(), public, operations called by the application (through the TransfeElementAbstractor)<ul>
<li>void <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa21ae3855a6df0e877865702df066f5e" title="Read the data from the device.">TransferElement::read()</a></li>
<li>bool <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a0e5dce57ab971b6fc68bc13fbd00401c" title="Read the next value, if available in the input buffer.">TransferElement::readNonBlocking()</a></li>
<li>bool <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a9488e50bea018025dd4b061afdf2f52b" title="Read the latest value, discarding any other update since the last read if present.">TransferElement::readLatest()</a></li>
<li>bool <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ae9a9be48fa8f5cab72e62ce20d99004b" title="Write the data to device.">TransferElement::write</a>(<a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation.">VersionNumber</a> versionNumber = {})</li>
<li>bool <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a91e44b68014588b44adea0d17ec45599" title="Just like write(), but allows the implementation to destroy the content of the user buffer in the pro...">TransferElement::writeDestructively</a>(<a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation.">VersionNumber</a> versionNumber = {})</li>
</ul>
</li>
<li>6.2 preXxx(), public<ul>
<li>void <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a3b9d8f76450952744a6a046de7b4eb16" title="Perform any pre-read tasks if necessary.">TransferElement::preRead(TransferType type)</a></li>
<li>void <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa8dbf971f07658c489d452016244e1a5" title="Transfer the data from the user buffer into the device send buffer, while converting the data from th...">TransferElement::preWrite(TransferType type, VersionNumber versionNumber)</a></li>
</ul>
</li>
<li>6.3 doPreXxx(), protected virtual<ul>
<li>void <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a60d3b43f03bed1cf27c57fd7e0c76127" title="Backend specific implementation of preRead().">TransferElement::doPreRead(TransferType type)</a></li>
<li>void <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa6ae99999ae6548d80d9f744e93f03bd" title="Backend specific implementation of preWrite().">TransferElement::doPreWrite(TransferType type, VersionNumber versionNumber)</a></li>
</ul>
</li>
<li>6.4 xxxTransferYyy(), public<ul>
<li>void <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#adaf41bf7340270e223afc8ed96f46b77" title="Read the data from the device but do not fill it into the user buffer of this TransferElement.">TransferElement::readTransfer()</a></li>
<li>bool <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ac53f4e5fb0474ea69ab4ae2f6348cef0" title="Read the data from the device but do not fill it into the user buffer of this TransferElement.">TransferElement::readTransferNonBlocking()</a></li>
<li>bool <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab472541c0dd3171f8bf34a8c7e4600ff" title="Write the data to the device.">TransferElement::writeTransfer(VersionNumber versionNumber)</a></li>
<li>bool <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a04427c0c30fd937a5c85a6bb60120a9e" title="Write the data to the device.">TransferElement::writeTransferDestructively(VersionNumber versionNumber)</a></li>
</ul>
</li>
<li>6.5 doXxxTransferYyy(), protected<ul>
<li>void TransferElement::doReadTransferSynchonously(), pure virtual (*)</li>
<li>bool <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aae3498d969f1eff074cb2a431a3ad687" title="Implementation version of writeTransfer().">TransferElement::doWriteTransfer(VersionNumber versionNumber)</a>, pure virtual</li>
<li>bool <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a98f467545b6682f18cec6b113c5898cc" title="Implementation version of writeTransferDestructively().">TransferElement::doWriteTransferDestructively(VersionNumber versionNumber)</a>, virtual</li>
</ul>
</li>
<li>6.6 postXxx(), public<ul>
<li>void <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aebd5de52d8f625ea84ec0b17224c316c" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">TransferElement::postRead(TransferType type, bool updateDataBuffer)</a></li>
<li>void <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a79fface1764b83bf0f8535616dc08d02" title="Perform any post-write clean-ups if necessary.">TransferElement::postWrite(TransferType type, VersionNumber versionNumber)</a></li>
</ul>
</li>
<li>6.7 doPostXxx(), protected virtual<ul>
<li>void <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a650d977e62e54324d6fc1b281feb0ba7" title="Backend specific implementation of postRead().">TransferElement::doPostRead(TransferType type, bool updateDataBuffer)</a></li>
<li>void <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a7c0a6bc5c1779ce47afe7871573ef2a1" title="Backend specific implementation of postWrite().">TransferElement::doPostWrite(TransferType type, VersionNumber versionNumber)</a></li>
</ul>
</li>
</ul>
</li>
<li>7. Virtual and non-virtual functions<ul>
<li>7.1 The non-virtual functions preXxx(), xxxTransferYyy(), and postXxx() implement common, decorating functionality like exception handling in the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> base class</li>
<li>7.2 They internally call their virtual counterparts which start with 'do'</li>
<li>7.3 The virtual do-functions are the actual implementations of the transfer or pre/post action, which are specific for each backend, decorator etc.</li>
</ul>
</li>
<li>8. Queues<ul>
<li><a class="anchor" id="transferElement_A_8_1"></a>8.1 The <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab824c85c63163e76ccda588ef4768f68" title="The queue for asynchronous read transfers.">TransferElement::_readQueue</a> is a cppext::future_queue of type 'void' which exists in each transfer element.</li>
<li><a class="anchor" id="transferElement_A_8_2"></a><a class="anchor" id="transferElement_data_transport_queue"></a>8.2 For transfer elements with <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read.">AccessMode::wait_for_new_data</a> it usually is a deferred continuation queue of another future_queue which is transporting the data, called <em>implementation-specific data transport queue</em> throughout this document. The data type of this queue is implementation dependent.</li>
<li><a class="anchor" id="transferElement_A_8_3"></a>8.3 Common functionality like exception handling and waiting for new data is implemented on <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab824c85c63163e76ccda588ef4768f68" title="The queue for asynchronous read transfers.">TransferElement::_readQueue</a>.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md7"></a>
(*) Comments</h3>
<ul>
<li>5.4 The buffer is accessed by the read/write operatons and must not be changed at this time. As transfer elements are not thread safe (B.1) this means the application will either perform an operation or otherwise change the buffer ad libitum.</li>
<li>6.5 doReadTransferSynchonously() is currently called doReadTransfer(). This should be renamed.</li>
</ul>
<h2><a class="anchor" id="autotoc_md8"></a>
B. Behavioural specification</h2>
<ul>
<li>1. TransferElements are not thread safe</li>
<li>2. Data types of the application data buffer:<ul>
<li>2.1 The following data types are supported for the application data buffer:<ul>
<li>int8_t</li>
<li>uint8_t</li>
<li>int16_t</li>
<li>uint16_t</li>
<li>int32_t</li>
<li>uint32_t</li>
<li>int64_t</li>
<li>uint64_t</li>
<li>float</li>
<li>double</li>
<li>std::string</li>
<li><a class="el" href="class_chimera_t_k_1_1_boolean.html" title="Wrapper Class to avoid vector&lt;bool&gt; problems.">ChimeraTK::Boolean</a></li>
<li><a class="el" href="class_chimera_t_k_1_1_void.html" title="Wrapper Class for void.">ChimeraTK::Void</a></li>
</ul>
</li>
<li>2.2 Applications select a data type for the buffer via the UserType template argument of Device::getZzzRegisterAccessor() resp. <a class="el" href="class_chimera_t_k_1_1_device_backend.html#a85a134106068b02a89cbfa9a4559ccfc" title="Get a NDRegisterAccessor object from the register name.">DeviceBackend::getRegisterAccessor()</a>.</li>
<li>2.3 If needed, the register value is converted between the actual register's data type and the application-selected UserType.<ul>
<li>2.3.1 Reading from an actual void register into a UserType which is not <a class="el" href="class_chimera_t_k_1_1_void.html" title="Wrapper Class for void.">ChimeraTK::Void</a> fills the user buffer with 0. The user buffer has 1 channel with 1 element.</li>
<li>2.3.2 Writing from a user buffer with <a class="el" href="class_chimera_t_k_1_1_void.html" title="Wrapper Class for void.">ChimeraTK::Void</a> to an actual non-void value writes 0 to the register. The user buffer matches the register's dimension.</li>
</ul>
</li>
<li>2.4 In read operations, values outside the possible range of the UserType are moved to the nearest possible value (rounding and clamping).<ul>
<li>2.4.1 The data is marked with <a class="el" href="namespace_chimera_t_k.html#a9a7d226a45242c6825eb7a26235298dfac4ef1e7ec5c765839c8acdd9968542b2" title="The data is considered valid.">DataValidity::faulty</a> in case of an overflow/underflow.</li>
</ul>
</li>
<li>2.5 In write operations, values outside the possible range of the actual register's data type are moved to the nearest possible value (rounding and clamping).<ul>
<li><a class="anchor" id="transferElement_B_2_5_1"></a>2.5.1 If the transfer protocol supports data validity flags, the data is flagged with <a class="el" href="namespace_chimera_t_k.html#a9a7d226a45242c6825eb7a26235298dfac4ef1e7ec5c765839c8acdd9968542b2" title="The data is considered valid.">DataValidity::faulty</a> in case of an overflow/underflow. <a class="el" href="spec__transfer_element.html#transferElement_comment_B_2_5_1">(*)</a></li>
</ul>
</li>
<li>2.6 All values can be converted into std::string, hence it is always possible to obtain an accessor with std::string as UserType.</li>
<li>2.7 After construction, the data buffer is initialised with default-constructed values (i.e. 0 resp. empty string).</li>
</ul>
</li>
<li>3. Modes of transfers<ul>
<li>3.1 Read operations:<ul>
<li>3.1.1 The flag <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read.">AccessMode::wait_for_new_data</a> determines whether the transfer is initiated by the device side (flag is set) or not.</li>
<li>3.1.2 If <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read.">AccessMode::wait_for_new_data</a> is not set, read operations<ul>
<li><a class="anchor" id="transferElement_B_3_1_2_1"></a>3.1.2.1 obtain the <em>current</em> value of the process variable (if possible/applicable by synchronously communicating with the device) [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_3_1_2_1">U</a>],</li>
<li>3.1.2.2 have no information whether the value has changed,</li>
<li>3.1.2.3 behave identical whether <a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7aecae13117d6f0584c25a9da6c8f8415e">read()</a>, <a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7aafcf399c9a4d4e33eda6ff5e3b011540">readNonBlocking()</a> or <a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7a168b97c08a29d6cd39c5aeeb3e6cc842">readLatest()</a> is called,</li>
<li><a class="anchor" id="transferElement_B_3_1_2_4"></a>3.1.2.4 <a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7aafcf399c9a4d4e33eda6ff5e3b011540">readNonBlocking()</a> and <a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7a168b97c08a29d6cd39c5aeeb3e6cc842">readLatest()</a> always return true. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_3_1_2_4">T</a>]</li>
</ul>
</li>
<li>3.1.3 If <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read.">AccessMode::wait_for_new_data</a> is set<ul>
<li><a class="anchor" id="transferElement_B_3_1_3_1"></a>3.1.3.1 <a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7aecae13117d6f0584c25a9da6c8f8415e">read()</a> blocks until new data has arrived, [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_3_1_3_1">T</a>]</li>
<li><a class="anchor" id="transferElement_B_3_1_3_2"></a>3.1.3.2 <a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7aafcf399c9a4d4e33eda6ff5e3b011540">readNonBlocking()</a> does not block and instead returns whether new data has arrived or not, [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_3_1_3_2">T</a>]</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_3_1_4"></a>3.1.4 <a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7a168b97c08a29d6cd39c5aeeb3e6cc842">readLatest()</a> is merely a convenience function which calls <a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7aafcf399c9a4d4e33eda6ff5e3b011540">readNonBlocking()</a> until no more new data is available. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_3_1_4">T</a>]</li>
</ul>
</li>
<li>3.2 Write operations<ul>
<li>3.2.1 do not distingish on which end the transfer is initiated. The API allows for application-initiated transfers and is compatible with device-initiated transfers as well.<ul>
<li><a class="anchor" id="transferElement_B_3_2_1_2"></a>3.2.1.2 It is guaranteed that the application buffer is still intact after calling <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ae9a9be48fa8f5cab72e62ce20d99004b" title="Write the data to device.">TransferElement::write()</a>. [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_3_2_1_2">U</a>]</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_3_2_2"></a>3.2.2 can optionally be "destructively", which allows the implementation to destroy content of the application buffer in the process. [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_3_2_2">U</a>]<ul>
<li>3.2.2.1 Applications can allow this optimisation by using <a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7abc219b057095a6e31adf97545d6b6ea6">writeDestructively()</a> instead of <a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7aefb2a684e4afb7d55e6147fbe5a332ee">write()</a>.</li>
<li><a class="anchor" id="transferElement_B_3_2_2_2"></a>3.2.2.2 Applications are not allowed to use the content of the application buffer after <a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7abc219b057095a6e31adf97545d6b6ea6">writeDestructively()</a>.<a class="el" href="spec__transfer_element.html#transferElement_comment_B_3_2_2_2">(*)</a></li>
</ul>
</li>
<li>3.2.3 return whether previous data has been lost, as reported by writeTransfer()/writeTransferDestructively() (c.f. <a class="el" href="spec__transfer_element.html#transferElement_B_7_2">7.2</a>).</li>
</ul>
</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_4"></a>4. Stages of an operation initiated by calling the public high level functions xxxYyy() (see. A.6.1) [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_4_order">T</a> (order of the stages)]<ul>
<li><a class="anchor" id="transferElement_B_4_1"></a>4.1 preXxx(): calls doPreXxx() of the implementation to allow preparatory work before the actual transfer. doPreXxx() can be empty if nothing is to be done (*) [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_4_1">T</a>]</li>
<li>4.2 xxxTransferYyy():<ul>
<li><a class="anchor" id="transferElement_B_4_2_1"></a>4.2.1 readTransfer() [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_4_2_1">T</a>]<ul>
<li>If wait_for_new_data is set, it waits until new data has been received and returns</li>
<li>If wait_for_new_data is not set, it calls doReadTransferSynchrously()</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_4_2_2"></a>4.2.2 readTransferNonBlocking() [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_4_2_2">T</a>]<ul>
<li>If wait_for_new_data is set, it returns immediately with the information whether new data has been received</li>
<li>If wait_for_new_data is not set, it calls doReadTransferSynchrously() and returns true</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_4_2_3"></a>4.2.3 writeTransferYyy() calls the corresonding doWriteTransferYyy() [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_4_2_3">T</a>]</li>
<li><a class="anchor" id="transferElement_B_4_2_4"></a>4.2.4 Transfer implementations do not change the application buffer [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_4_2_4">U</a>]</li>
<li><a class="anchor" id="transferElement_B_4_2_5"></a>4.2.5 xxxTransferYyy() can be skipped between preXxx() and postXxx(), even if preXxx() has not thrown an exception. In this case, postXxx() must be called with the updateDataBuffer set to false. The result of such operation is no observable change, in particular the application buffer must remain unaltered. See <a class="el" href="spec__transfer_element.html#transferElement_B_12_10_2_3">B.12.10.2.3</a>.</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_4_3"></a>4.3 postXxx(): calls doPostXxx() of the implementation to allow follow-up work after the actual transfer. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_4_3">T</a>]<ul>
<li>4.3.1 In read transfers, doPostRead() is the only place where the application buffer may be changed (*).</li>
<li><a class="anchor" id="transferElement_B_4_3_2"></a>4.3.2 In write transfers, postWrite() updates the version number of the application buffer <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a9ad34f0c2eaec6be3dc385f1c4acef46" title="The version number of the last successful transfer.">TransferElement::_versionNumber</a> to the version number provided to the <a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7aefb2a684e4afb7d55e6147fbe5a332ee">write()</a> call, if no exception is (re-)thrown in doPostWrite() (cf. <a class="el" href="spec__transfer_element.html#transferElement_B_11_3">B.11.3</a>). [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_4_3_2">T</a>]</li>
</ul>
</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_5"></a>5. preXxx() and postXxx(), resp. doPreXxx() and doPostXxx(), are always called in pairs. (*)<ul>
<li><a class="anchor" id="transferElement_B_5_1"></a>5.1 This holds even if exceptions (both <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured.">ChimeraTK::logic_error</a> and <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">ChimeraTK::runtime_error</a>) are thrown (see 6). <a class="el" href="spec__transfer_element.html#transferElement_comment_B_5_1">(*)</a> [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_5_1">T</a>]</li>
<li><a class="anchor" id="transferElement_B_5_2"></a>5.2 The implementations of preXxx() and postXxx() ignore duplicate calls, such that a call to doPreXxx() is never followed by another call to doPreXxx() before doPostXxx() has been called, and vice versa. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_5_2">T</a>]</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_6"></a>6. Exceptions thrown in doPreXxx(), doXxxTransferYyy() or received on the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab824c85c63163e76ccda588ef4768f68" title="The queue for asynchronous read transfers.">TransferElement::_readQueue</a> (see <a class="el" href="spec__transfer_element.html#transferElement_A_8_1">A.8.1</a>) are caught and delayed until postXxx() by the framework. This ensures that preXxx() and postXxx() are always called in pairs<ul>
<li><a class="anchor" id="transferElement_B_6_1"></a>6.1 If in preXxx() an exception is thrown, the corresponding xxxTransferYyy() is not called, instead directly postXxx() is called. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_6_1">T</a>]</li>
<li><a class="anchor" id="transferElement_B_6_2"></a>6.2 To ensure <a class="el" href="spec__transfer_element.html#transferElement_B_6_1">6.1</a> is guaranteed with decorators, the exception has to be caught and stored in the outermost decorator, i.e. in the public xxxYyy() which delegate to the transfers. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_6_2">T</a>]</li>
<li><a class="anchor" id="transferElement_B_6_3"></a>6.3 To ensure that the ApplicationCore ExeptionHandlingDecorator works in combination with other decorators, each decorator has to pass the stored exception to its target, and it has to be re-thrown in the doPostRead() of the layer where the exception originated (see <a class="el" href="spec__transfer_element.html#transferElement_C_2">C.2</a>)</li>
<li><a class="anchor" id="transferElement_B_6_4"></a>6.4 When an exception is finally thrown by a <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>, the application buffer must still be unchanged. [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_6_4">U</a>]</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_7"></a>7. Return values of xxxTransferYyy():<ul>
<li>7.1 readTransferNonBlocking() returns whether new data has been received (see 4.2.2)</li>
<li><a class="anchor" id="transferElement_B_7_2"></a>7.2 writeTransfer() and writeTransferDestructively() return whether data has been lost. If it returns true, previous data was rejected in the process of the transfer. It is always guaranteed that the data of the current transfer is not lost. <a class="el" href="spec__transfer_element.html#transferElement_comment_B_7_2">(*)</a> [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_7_2">T</a>, <a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_7_2">U</a>]</li>
<li><a class="anchor" id="transferElement_B_7_3"></a>7.3 For read operations, the return value is passed on to postRead() (via updateDataBuffer), to allow the doPostXxx() implementations to decide the right actions. In case of readTransfer(), updateDataBuffer is set to true. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_7_3">T</a>]</li>
<li><a class="anchor" id="transferElement_B_7_4"></a>7.4 In case of an exception in either preRead() or readTransferYyy(), postRead() is called with updateDataBuffer = false because there was no successful transfer. <a class="el" href="spec__transfer_element.html#transferElement_comment_B_7_4">(*)</a> [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_7_4">T</a>]</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_8"></a>8. Read operations with <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read.">AccessMode::wait_for_new_data</a>:<ul>
<li>8.1 Since the transfer is initiated by the device side in this case, the transfer is asynchronous to the read operation.</li>
<li><a class="anchor" id="transferElement_B_8_2"></a>8.2 The backend fills any received values into the <a class="el" href="spec__transfer_element.html#transferElement_A_8_2">implementation-specific data transport queue</a>, from which the readTransfer()/readTransferNonBlocking() operations will obtain the value (via the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab824c85c63163e76ccda588ef4768f68" title="The queue for asynchronous read transfers.">TransferElement::_readQueue</a> continuation). [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_8_2">T</a>, <a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_8_2">U</a>]<ul>
<li><a class="anchor" id="transferElement_B_8_2_1"></a>8.2.1 If the queue is full, the last written value will be overwritten. [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_8_2_1">U</a> (STILL INCOMPLETE)]</li>
<li><a class="anchor" id="transferElement_B_8_2_2"></a>8.2.2 The backend may fill a ChimeraTK::detail::DiscardValueException to the queue, which has the same effect on the application side as if no entry was filled to the queue. (*) [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_8_2_2">T</a>]</li>
<li>8.2.3 The continuation of the <a class="el" href="spec__transfer_element.html#transferElement_A_8_2">implementation-specific data transport queue</a> stores the value so it is available in doPostRead(), where it is filled into the application buffer.</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_8_3"></a>8.3 Runtime errors like broken connections are reported by the backend by pushing <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">ChimeraTK::runtime_error</a> exceptions into the queue. The exception will then be obtained by the read operation in place of a value. [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_8_3">U</a> (first sentence), <a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_8_3">T</a> (second sentence)]</li>
<li><a class="anchor" id="transferElement_B_8_4"></a>8.4 The backend ensures consistency of the value with the device, even if data loss may occur on the transport layer. If necessary, a heartbeat mechanism is implemented to correct any inconsistencies at regular intervals. [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_8_4">U</a>]</li>
<li><a class="anchor" id="transferElement_B_8_5"></a>8.5 For transfer elements which are created before the device has successfully been opened and <a class="el" href="class_chimera_t_k_1_1_device.html#ad7c7d319aa029ecdb9a1e5aae5e667af" title="Activate asyncronous read for all transfer elements where AccessMode::wait_for_new_data is set.">Device::activateAsyncRead()</a> has been called (or after the device has seen an exception, see 9.) the backend makes sure that no data is filled into the <a class="el" href="spec__transfer_element.html#transferElement_A_8_2">implementation-specific data transport queue</a> until the device has successfully been opened and <a class="el" href="class_chimera_t_k_1_1_device.html#ad7c7d319aa029ecdb9a1e5aae5e667af" title="Activate asyncronous read for all transfer elements where AccessMode::wait_for_new_data is set.">Device::activateAsyncRead()</a> is called (*). Also no runtime_errors are sent. We call this <em>asyncronous read is not activated</em>. [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_8_5">Broken/insensitive U</a>].<ul>
<li><a class="anchor" id="transferElement_B_8_5_1"></a>8.5.1 When <a class="el" href="class_chimera_t_k_1_1_device.html#ad7c7d319aa029ecdb9a1e5aae5e667af" title="Activate asyncronous read for all transfer elements where AccessMode::wait_for_new_data is set.">Device::activateAsyncRead()</a> is called, the backend activates asyncronous read for all its transfer elements where <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read.">AccessMode::wait_for_new_data</a> is set (*) [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_8_5_1">U</a>].<ul>
<li><a class="anchor" id="transferElement_B_8_5_1_1"></a>8.5.1.1 Each backend is responsible for activating asynchronous reads only on those TransferElements which it created. (cf. <a class="el" href="spec__transfer_element.html#transferElement_B_9_2_1">9.2.1</a>)</li>
<li>8.5.1.2 Meta-backends like the <a class="el" href="class_chimera_t_k_1_1_logical_name_mapping_backend.html" title="Backend to map logical register names onto real hardware registers.">LogicalNameMappingBackend</a> delegate <a class="el" href="class_chimera_t_k_1_1_device.html#ad7c7d319aa029ecdb9a1e5aae5e667af" title="Activate asyncronous read for all transfer elements where AccessMode::wait_for_new_data is set.">Device::activateAsyncRead()</a> to all of their target backends, as they also delegate the creation of the TransferElements to their targets.</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_8_5_2"></a>8.5.2 In case the device does not send an initial value after the subscription, the accessor implementation must get an initial value synchronously and treat it as if it would have been received, i.e. push it to the queue. This must happen after the actual asynchronous sending has been turned on to make sure no update is missed. (*) [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_8_5_2">U</a>]</li>
<li><a class="anchor" id="transferElement_B_8_5_3"></a>8.5.3 If a transfer element is created while the device is opened, functional and <a class="el" href="class_chimera_t_k_1_1_device.html#ad7c7d319aa029ecdb9a1e5aae5e667af" title="Activate asyncronous read for all transfer elements where AccessMode::wait_for_new_data is set.">Device::activateAsyncRead()</a> has been called, the asynchronous read is activated immediately (incl. sending of the initial value). This ensures that either all or none of the transfer elements are receiving asyncronously send data. [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_8_5_3">Needs to be changed, most probably testing the wrong thing. U</a>]</li>
<li><a class="anchor" id="transferElement_B_8_5_4"></a>8.5.4 A <a class="el" href="class_chimera_t_k_1_1_device.html#ad7c7d319aa029ecdb9a1e5aae5e667af" title="Activate asyncronous read for all transfer elements where AccessMode::wait_for_new_data is set.">Device::activateAsyncRead()</a> call has no effect if<ul>
<li>8.5.4.1 the device is not opened</li>
<li>8.5.4.2 the device has an error</li>
<li><a class="anchor" id="transferElement_B_8_5_4_3"></a>8.5.4.3 asynchronous read is already active [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_8_5_4_3">U</a>]</li>
</ul>
</li>
<li>8.5.5 <a class="el" href="class_chimera_t_k_1_1_device.html#ad7c7d319aa029ecdb9a1e5aae5e667af" title="Activate asyncronous read for all transfer elements where AccessMode::wait_for_new_data is set.">Device::activateAsyncRead()</a> does not throw any exceptions.</li>
<li>8.5.6 When <a class="el" href="class_chimera_t_k_1_1_device.html#ad7c7d319aa029ecdb9a1e5aae5e667af" title="Activate asyncronous read for all transfer elements where AccessMode::wait_for_new_data is set.">Device::activateAsyncRead()</a> returns, it is not guaranteed that all initial values have been received already.</li>
<li>8.5.7 <a class="el" href="class_chimera_t_k_1_1_device.html#ad7c7d319aa029ecdb9a1e5aae5e667af" title="Activate asyncronous read for all transfer elements where AccessMode::wait_for_new_data is set.">Device::activateAsyncRead()</a> is thread safe against other calls of activateAsyncRead(), the creation/destuction of accessors, read/write operations and calls of <a class="el" href="class_chimera_t_k_1_1_device.html#a41fb30e128b2c697296218725143e687" title="Set the device into an exception state.">Device::setException()</a>.</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_8_6"></a>8.6 Blocking <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa21ae3855a6df0e877865702df066f5e" title="Read the data from the device.">TransferElement::read()</a> calls can be interrupted by the application via <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#af92b78c177bc98923a78a0d4faaf9e05" title="Return from a blocking read immediately and throw boost::thread_interrupted.">TransferElement::interrupt()</a>.<ul>
<li><a class="anchor" id="transferElement_B_8_6_1"></a>8.6.1 <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#af92b78c177bc98923a78a0d4faaf9e05" title="Return from a blocking read immediately and throw boost::thread_interrupted.">TransferElement::interrupt()</a> places a boost::thread_interrupted exception into the <a class="el" href="spec__transfer_element.html#transferElement_A_8_2">implementation-specific data transport queue</a>. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_8_6_1">T</a>]</li>
<li><a class="anchor" id="transferElement_B_8_6_2"></a>8.6.2 This casues any read operation to complete immediately and throw the boost::thread_interrupted exception, after any unread data on the queue before the exception has been read normally. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_8_6_2">T</a>]</li>
<li><a class="anchor" id="transferElement_B_8_6_3"></a>8.6.3 The operation receiving the boost::thread_interrupted exception will also obey <a class="el" href="spec__transfer_element.html#transferElement_B_5">5</a>, i.e. postRead() is still called. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_8_6_3">T</a>]</li>
<li><a class="anchor" id="transferElement_B_8_6_4"></a>8.6.4 Calling <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#af92b78c177bc98923a78a0d4faaf9e05" title="Return from a blocking read immediately and throw boost::thread_interrupted.">TransferElement::interrupt()</a> does not disturb the subsequent operation of the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_8_6_4">T</a>]</li>
<li><a class="anchor" id="transferElement_B_8_6_5"></a>8.6.5 (removed)</li>
<li><a class="anchor" id="transferElement_B_8_6_6"></a>8.6.6 <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#af92b78c177bc98923a78a0d4faaf9e05" title="Return from a blocking read immediately and throw boost::thread_interrupted.">TransferElement::interrupt()</a> is a virtual function which has to be implemented by all <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> implementations <a class="el" href="spec__transfer_element.html#transferElement_comment_B_8_6_6">(*)</a>. [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_8_6_6">U</a> (via high-level test)]<ul>
<li><a class="anchor" id="transferElement_B_8_6_6_1"></a>8.6.6.1 Full implementations must implement it by calling <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a7dc6f496a4965a7e81b0c36463ac9ce9" title="Implementation of interrupt()">TransferElement::interrupt_impl()</a> with the <a class="el" href="spec__transfer_element.html#transferElement_A_8_2">implementation-specific data transport queue</a> as argument. <a class="el" href="spec__transfer_element.html#transferElement_comment_B_8_6_6_1">(*)</a></li>
<li><a class="anchor" id="transferElement_B_8_6_6_2"></a>8.6.6.2 Decorator-like implementations must delegate the call to their target.<a class="el" href="spec__transfer_element.html#transferElement_comment_B_8_6_6_2">(*)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_9"></a>9. If one transfer element of a device has seen a <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">ChimeraTK::runtime_error</a> <a class="el" href="spec__transfer_element.html#transferElement_comment_B_9a">(*)</a>, all other transfer elements of the same device must also be aware of this. <a class="el" href="spec__transfer_element.html#transferElement_comment_B_9b">(*)</a><ul>
<li><a class="anchor" id="transferElement_B_9_1"></a>9.1 The transfer element which detects the <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">ChimeraTK::runtime_error</a> reports it to its <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aee95f5dfccb41075150d0a7d00f5e494" title="The backend to which the runtime_errors are reported via DeviceBackend::setException().">TransferElement::_exceptionBackend</a> by calling <a class="el" href="class_chimera_t_k_1_1_device_backend.html#ab3d996241286ea3b233e3ea59824b670" title="Set the backend into an exception state.">DeviceBackend::setException()</a> <a class="el" href="spec__transfer_element.html#transferElement_comment_B_9_1">(*)</a> (see <a class="el" href="spec__transfer_element.html#transferElement_B_9_2">9.2</a>) [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_9_1">U</a>]<ul>
<li><a class="anchor" id="transferElement_B_9_1_1"></a>9.1.1 <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aee95f5dfccb41075150d0a7d00f5e494" title="The backend to which the runtime_errors are reported via DeviceBackend::setException().">TransferElement::_exceptionBackend</a> is set when the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> is created by a backend by calling <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a23782060d06fa418950b74f8b10d4ec8" title="Set the backend to which the exception has to be reported.">TransferElement::setExceptionBackend()</a>.</li>
<li><a class="anchor" id="transferElement_B_9_1_2"></a>9.1.2 Meta-backends like the <a class="el" href="class_chimera_t_k_1_1_logical_name_mapping_backend.html" title="Backend to map logical register names onto real hardware registers.">LogicalNameMappingBackend</a> replace the exceptionBackend so the exception reporting is re-directed to the meta-backend.</li>
<li><a class="anchor" id="transferElement_B_9_1_3"></a>9.1.3 <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a23782060d06fa418950b74f8b10d4ec8" title="Set the backend to which the exception has to be reported.">TransferElement::setExceptionBackend()</a> is virtual. Decorator-like TransferElements overload it so all target elements also get the correct exception backend.</li>
<li><a class="anchor" id="transferElement_B_9_1_4"></a>9.1.4 Decorators set their <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aee95f5dfccb41075150d0a7d00f5e494" title="The backend to which the runtime_errors are reported via DeviceBackend::setException().">TransferElement::_exceptionBackend</a> in the constructor to their target's _exceptionBackend. <a class="el" href="spec__transfer_element.html#transferElement_comment_B_9_1_4">(*)</a></li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_9_2"></a>9.2 <a class="el" href="class_chimera_t_k_1_1_device_backend.html#ab3d996241286ea3b233e3ea59824b670" title="Set the backend into an exception state.">DeviceBackend::setException()</a> triggers the actions described in <a class="el" href="spec__transfer_element.html#transferElement_B_9_3">9.3</a>, <a class="el" href="spec__transfer_element.html#transferElement_B_9_4">9.4</a> and <a class="el" href="spec__transfer_element.html#transferElement_B_9_5">9.5</a> <a class="el" href="spec__transfer_element.html#transferElement_comment_B_9_2">(*)</a><ul>
<li><a class="anchor" id="transferElement_B_9_2_1"></a>9.2.1 Like for the activation of the asynchronous read (cf. <a class="el" href="spec__transfer_element.html#transferElement_B_8_5_1_1">8.5.1.1</a>), each backend is only responsible for taking the actions in <a class="el" href="class_chimera_t_k_1_1_device_backend.html#ab3d996241286ea3b233e3ea59824b670" title="Set the backend into an exception state.">DeviceBackend::setException()</a> for those TransferElements it created. Meta-backends like the <a class="el" href="class_chimera_t_k_1_1_logical_name_mapping_backend.html" title="Backend to map logical register names onto real hardware registers.">LogicalNameMappingBackend</a> delegate this call to all of their target backends, as they also delegated the creation.</li>
<li><a class="anchor" id="transferElement_B_9_2_2"></a>9.2.2 Further calls to <a class="el" href="class_chimera_t_k_1_1_device_backend.html#ab3d996241286ea3b233e3ea59824b670" title="Set the backend into an exception state.">DeviceBackend::setException()</a> have no effect until <a class="el" href="class_chimera_t_k_1_1_device.html#a0a86afbebd076b8bc1d7bc6fe87db89d" title="Re-open the device after previously closeing it by calling close(), or when it was constructed with a...">Device::open()</a> has successfully been called. [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_9_2_2">U</a>]</li>
<li><a class="anchor" id="transferElement_B_9_2_3"></a>9.2.3 Application code can call <a class="el" href="class_chimera_t_k_1_1_device.html#a41fb30e128b2c697296218725143e687" title="Set the device into an exception state.">Device::setException()</a> to trigger the exception state <a class="el" href="spec__transfer_element.html#transferElement_comment_B_9_2_3">(*)</a></li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_9_3"></a>9.3 TransferElements with wait_for_new_data flag<ul>
<li><a class="anchor" id="transferElement_B_9_3_1"></a>9.3.1 Each transfer element deactivates asynchronous reads so no further data is pushed into the <a class="el" href="spec__transfer_element.html#transferElement_A_8_2">implementation-specific data transport queue</a> until open() has been called successfully in the backend (*) and <a class="el" href="class_chimera_t_k_1_1_device.html#ad7c7d319aa029ecdb9a1e5aae5e667af" title="Activate asyncronous read for all transfer elements where AccessMode::wait_for_new_data is set.">Device::activateAsyncRead()</a> has been called [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_9_3_1">U</a>]</li>
<li><a class="anchor" id="transferElement_B_9_3_2"></a>9.3.2 Exactly one <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">ChimeraTK::runtime_error</a> is pushed into the queue of <em>each</em> transfer elements of the backend with wait_for_new_data (*). This must happen after 9.3.1. to avoid race conditions. [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_9_3_2">U</a>]</li>
<li>9.3.3 The first data on the queue after the exception is the initial value sent when calling <a class="el" href="class_chimera_t_k_1_1_device.html#ad7c7d319aa029ecdb9a1e5aae5e667af" title="Activate asyncronous read for all transfer elements where AccessMode::wait_for_new_data is set.">Device::activateAsyncRead()</a> (see 8.5.2).</li>
<li>9.3.4 The backend makes sure 9.3.2 is finished for each <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> before a call to <a class="el" href="class_chimera_t_k_1_1_device.html#ad7c7d319aa029ecdb9a1e5aae5e667af" title="Activate asyncronous read for all transfer elements where AccessMode::wait_for_new_data is set.">Device::activateAsyncRead()</a> re-activates its asynchronous transfer again (*).</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_9_4"></a>9.4 TransferElements without wait_for_new_data<ul>
<li><a class="anchor" id="transferElement_B_9_4_1"></a>9.4.1 Each call to doReadTransferSynchonously() throws a ChimeraTK::runtime error until open() has been called successfully. [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_9_4_1">U</a>]</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_9_5"></a>9.5 Write operations throw a ChimeraTK::runtime error in doWriteTransferYyy() until open() has been called successfully. [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_9_5">U</a>]</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_10"></a>10. Removed. Became part of 9.</li>
<li>11. A <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation.">VersionNumber</a> object is attached to each data transfer.<ul>
<li>11.1 <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation.">VersionNumber</a> objects<ul>
<li>11.1.1 can be stricly ordered by their time of creation within the application (process lifetime) using the C++ comparison operators (&lt;, ==, &gt; etc.),</li>
<li>11.1.2 additionaly contain a std::chrono::system_clock timestamp which allows to weakly order the objects even across applications/processes,</li>
<li>11.1.3 are copyable, and</li>
<li>11.1.4 can be initiallised with a {nullptr} which yields a special instance that sorts before all normal instances. All {nullptr} constructed objects are equal (==).</li>
<li>11.1.5 The default constructor creates a new <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation.">VersionNumber</a> which is larger than all previously created VersionNumbers in a thread safe way.</li>
</ul>
</li>
<li>11.2 <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation.">VersionNumber</a> objects are used<ul>
<li><a class="anchor" id="transferElement_B_11_2_1"></a>11.2.1 to determine which data is older <a class="el" href="spec__transfer_element.html#transferElement_comment_B_11_2_1">(*)</a>, as needed e.g. by bidirectional process variable implementations [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_11_2_1">U</a>], and</li>
<li><a class="anchor" id="transferElement_B_11_2_2"></a>11.2.2 to build a consistent data set from multiple TransferElements (see <a class="el" href="class_chimera_t_k_1_1_data_consistency_group.html" title="Group several registers (= TransferElement) which ensures data consistency across multiple variables ...">DataConsistencyGroup</a>). This requires the data sources (e.g. backend implementations) to attach the same <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation.">VersionNumber</a> to different TransferElements if the data is consistent. [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_11_2_2">U</a> (STILL INCOMPLETE)]</li>
<li>11.2.3 From the previous two points it follows that backend implementations must create a new <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation.">VersionNumber</a> for all data that is received or read, or associcate a known version number according to <a class="el" href="spec__transfer_element.html#transferElement_B_11_2_2">11.2.2</a></li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_11_3"></a>11.3 The <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation.">VersionNumber</a> of the last successfully written/read data of a <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> can be obtained through <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a69298f31fe4a42e779bca3669d06c2bd" title="Returns the version number that is associated with the last transfer (i.e.">TransferElement::getVersionNumber()</a> (cf. <a class="el" href="spec__transfer_element.html#transferElement_B_4_3_2">B.4.3.2</a>). [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_11_3">T</a>]</li>
<li>11.4 The <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation.">VersionNumber</a> for a transfer is given as an optional argument to <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ae9a9be48fa8f5cab72e62ce20d99004b" title="Write the data to device.">TransferElement::write()</a> resp. <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a91e44b68014588b44adea0d17ec45599" title="Just like write(), but allows the implementation to destroy the content of the user buffer in the pro...">TransferElement::writeDestructively()</a>. If the argument is missing, a new <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation.">VersionNumber</a> is generated.<ul>
<li><a class="anchor" id="transferElement_B_11_4_1"></a>11.4.1 The <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation.">VersionNumber</a> passed to the write call must be greater or equal to the one returned by <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a69298f31fe4a42e779bca3669d06c2bd" title="Returns the version number that is associated with the last transfer (i.e.">TransferElement::getVersionNumber()</a> of the same <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>, otherwise a <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured.">ChimeraTK::logic_error</a> is thrown by the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> base class. Write calls on different instances of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> (say <code>a</code> and <code>b</code>) do not need to follow this rule, i.e. <code>a-&gt;<a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7aefb2a684e4afb7d55e6147fbe5a332ee">write(v1)</a>; b-&gt;<a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7aefb2a684e4afb7d55e6147fbe5a332ee">write(v2)</a>;</code> is allowed even if <code>v2 &lt; v1</code> <a class="el" href="spec__transfer_element.html#transferElement_comment_B_11_4_1">(*)</a>. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_11_4_1">T</a>]</li>
<li><a class="anchor" id="transferElement_B_11_4_2"></a>11.4.2 The <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation.">VersionNumber</a> is passed on to the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> implementation via the calls <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa6ae99999ae6548d80d9f744e93f03bd" title="Backend specific implementation of preWrite().">TransferElement::doPreWrite()</a>, <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aae3498d969f1eff074cb2a431a3ad687" title="Implementation version of writeTransfer().">TransferElement::doWriteTransfer()</a> resp. <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a98f467545b6682f18cec6b113c5898cc" title="Implementation version of writeTransferDestructively().">TransferElement::doWriteTransferDestructively()</a> and <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a7c0a6bc5c1779ce47afe7871573ef2a1" title="Backend specific implementation of postWrite().">TransferElement::doPostWrite()</a>, after the precondition 11.4.1 has been checked. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_11_4_2">T</a>]</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_11_5"></a>11.5 If a transfer was not successful (exception has been thrown), the <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation.">VersionNumber</a> returned by <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a69298f31fe4a42e779bca3669d06c2bd" title="Returns the version number that is associated with the last transfer (i.e.">TransferElement::getVersionNumber()</a> does not change (cf. <a class="el" href="spec__transfer_element.html#transferElement_B_6_4">B.6.4</a>). [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_11_5">T</a>]</li>
<li><a class="anchor" id="transferElement_B_11_6"></a>11.6 Before the first successful transfer, <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a69298f31fe4a42e779bca3669d06c2bd" title="Returns the version number that is associated with the last transfer (i.e.">TransferElement::getVersionNumber()</a> always returns the {nullptr} constructed <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation.">VersionNumber</a>. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_11_6">T</a>, <a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_11_6">U</a>]</li>
<li><a class="anchor" id="transferElement_B_11_7"></a>11.7 <em>To be decided if we only allow 11.7.2:</em> Bi-directional variables<ul>
<li><a class="anchor" id="transferElement_B_11_7_1"></a>11.7.1 <em>either</em> do not guarantee that consecutive calls to <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a69298f31fe4a42e779bca3669d06c2bd" title="Returns the version number that is associated with the last transfer (i.e.">TransferElement::getVersionNumber()</a> always return a <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation.">VersionNumber</a> that is equal or greater than the one from the previous call <a class="el" href="spec__transfer_element.html#transferElement_comment_B_11_7_1">(*)</a></li>
<li><a class="anchor" id="transferElement_B_11_7_2"></a>11.7.2 <em>or</em> discard values with lower version numbers <a class="el" href="spec__transfer_element.html#transferElement_comment_B_11_7_2">(*)</a></li>
</ul>
</li>
</ul>
</li>
<li>12. <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group.">TransferGroup</a> and merging transfers:<ul>
<li>12.1 TransferElements which are put into the same <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group.">TransferGroup</a> can optionally merge their data transfer to optimise for speed and to offer a best-effort data consistency.<ul>
<li>12.1.1 TransferGroups do not enforce data consistency, since merging transfers is optional.<ul>
<li>12.1.1.1 If a merge happens and consistency of the data can be guaranteed in a read operation, the <a class="el" href="class_chimera_t_k_1_1_version_number.html" title="Class for generating and holding version numbers without exposing a numeric representation.">VersionNumber</a> of the corresponding TransferElements is set to the same value.</li>
</ul>
</li>
<li>12.1.2 Structure of TransferElements in TransferGroups:<ul>
<li><a class="anchor" id="transferElement_B_12_1_2_1"></a>12.1.2.1 A <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>, which is directly added to the <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group.">TransferGroup</a>, is called <em>high-level element</em>.</li>
<li><a class="anchor" id="transferElement_B_12_1_2_2"></a>12.1.2.2 Decorator-like implementations use one or more <em>low-level elements</em> which perform the actual register access. All low-level elements of one <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> are returned by <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ac69c35862286b6a67cd5a11536c8a408" title="Obtain the underlying TransferElements with actual hardware access.">TransferElement::getHardwareAccessingElements()</a>.</li>
<li>12.1.2.3 Low-level elements are not decorator-like, since they directly access the device.</li>
<li>12.1.2.4 There can be any number of decorator-like intermediate elements. The sum of all elements on all levels of one high-level element including the low-level elements but excluding the high-level element itself is called <em>internal elements</em>. All internal elements of one <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> are returned by <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a4a511b856a6d966647f3ed38feca55cc" title="Obtain the full list of TransferElements internally used by this TransferElement.">TransferElement::getInternalElements()</a>.</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_12_1_3"></a>12.1.3 After a <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> is added to a <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group.">TransferGroup</a>, <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a791a4902b649e859fbadea20cc90ede2" title="Search for all underlying TransferElements which are considered identical (see sameRegister()) with t...">TransferElement::replaceTransferElement()</a> is called for each element in the group, passing each internal element in the group as a replacement. [<a class="el" href="test_transfer_group_8cpp.html#testTransferElement_B_12_1_3">T</a>]<ul>
<li><a class="anchor" id="transferElement_B_12_1_3_1"></a>12.1.3.1 If an element that is already in the list of internal elements is passed to <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a791a4902b649e859fbadea20cc90ede2" title="Search for all underlying TransferElements which are considered identical (see sameRegister()) with t...">TransferElement::replaceTransferElement()</a>, it does not change the internal elements. [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_12_1_3_1">U</a>]</li>
</ul>
</li>
<li>12.1.4 <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a791a4902b649e859fbadea20cc90ede2" title="Search for all underlying TransferElements which are considered identical (see sameRegister()) with t...">TransferElement::replaceTransferElement()</a> uses the given replacement <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> for an optimisation, if possible. Depending on the protocol, this can mean:<ul>
<li><a class="anchor" id="transferElement_B_12_1_4_1"></a>12.1.4.1 An internal element is replaced 1:1 by the replacement, because it transfers the same data (cf. <a class="el" href="spec__transfer_element.html#transferElement_B_12_1_5">12.1.5</a>). This is a common case for decorator-like implementations.<ul>
<li><a class="anchor" id="transferElement_B_12_1_4_1_1"></a>12.1.4.1.1 A copy decorator must be placed around the replacement TrasferElement to avoid that the multiple users of the lower-level TransferElements are swapping out the data before it is seen by all users.</li>
<li>12.1.4.1.2 The use of a copy decorator is not required, if it is guaranteed that no such conflict may happen. This can only be the case if the replacement <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> is never used as a stand-alone <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>.</li>
</ul>
</li>
<li>12.1.4.2 The given replacement can be extended such that the data of an internal element is included in the transfer; then the internal element can be replaced by the now-extended replacement.</li>
<li>12.1.4.3 If such replacement takes place, the behaviour visible to the application of the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> does not change (exception: VersionNumbers in read opertions can reveal now-consistent data, see 12.1.1).</li>
<li>12.1.4.4 If no such optimisation is possible, the function simply does nothing.</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_12_1_5"></a>12.1.5 <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#acfe89e1cf7c5d45797fd062b9faaea6a" title="Check whether the TransferElement can be used in places where the TransferElement &quot;other&quot; is currentl...">TransferElement::mayReplaceOther()</a> returns true, if the given <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> behaves identical to the one it is called on in every aspect, i.e. it accesses the same data on the same device, has the same UserType and the same <a class="el" href="class_chimera_t_k_1_1_access_mode_flags.html" title="Set of AccessMode flags with additional functionality for an easier handling.">AccessModeFlags</a>, and (if applicable) uses the same data transformations (like fixed point conversion). It returns false otherwise. This is used by implementations of <a class="el" href="spec__transfer_element.html#transferElement_B_12_1_4_1">12.1.4.1</a>.<ul>
<li>-<a class="anchor" id="transferElement_B_12_1_5_1"></a>12.1.5.1 If the element that is passed to <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#acfe89e1cf7c5d45797fd062b9faaea6a" title="Check whether the TransferElement can be used in places where the TransferElement &quot;other&quot; is currentl...">TransferElement::mayReplaceOther()</a> is identical to the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> is is passed to, <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#acfe89e1cf7c5d45797fd062b9faaea6a" title="Check whether the TransferElement can be used in places where the TransferElement &quot;other&quot; is currentl...">TransferElement::mayReplaceOther()</a> returns <code>false</code>. <a class="el" href="spec__transfer_element.html#transferElement_comment_B_12_1_5_1">(*)</a> [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_B_12_1_5_1">U</a>]</li>
</ul>
</li>
</ul>
</li>
<li>12.2 Adding TransferElements which cannot merge their transfers to the same <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group.">TransferGroup</a> is always allowed.</li>
<li><a class="anchor" id="transferElement_B_12_3"></a>12.3 If TransferElements have been added to a <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group.">TransferGroup</a>, individual read/write operations of the TransferElements are no longer allowed and will throw a <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured.">ChimeraTK::logic_error</a>. Read/write operations are then only possible through the <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group.">TransferGroup</a>. [<a class="el" href="test_transfer_group_8cpp.html#testTransferElement_B_12_3">T</a>]</li>
<li><a class="anchor" id="transferElement_B_12_4"></a>12.4 A <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group.">TransferGroup</a> is becomes read-only (cf. <a class="el" href="class_chimera_t_k_1_1_transfer_group.html#a3e2a181be4626c14587c6d302f0c90eb" title="Check if transfer group is read-only.">TransferGroup::isReadOnly()</a>), if at least one of the member TransferElements is read-only. [<a class="el" href="test_transfer_group_8cpp.html#testTransferElement_B_12_4">T</a>]</li>
<li><a class="anchor" id="transferElement_B_12_5"></a>12.5 Adding the same <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> twice is not allowed (<a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured.">logic_error</a>). [<a class="el" href="test_transfer_group_8cpp.html#testTransferElement_B_12_5">T</a>]</li>
<li><a class="anchor" id="transferElement_B_12_6"></a>12.6 Adding one <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> to two different TransferGroups is not allowed (<a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured.">logic_error</a>). [<a class="el" href="test_transfer_group_8cpp.html#testTransferElement_B_12_6">T</a>]</li>
<li><a class="anchor" id="transferElement_B_12_7"></a>12.7 Adding TransferElements with <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read.">AccessMode::wait_for_new_data</a> is not allowed (<a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured.">logic_error</a>). [<a class="el" href="test_transfer_group_8cpp.html#testTransferElement_B_12_7">T</a>]</li>
<li><a class="anchor" id="transferElement_B_12_8"></a>12.8 Adding a copy of the a <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> which is already in the group (returned by two different calls to Device::getZzzRegisterAccessor() resp. <a class="el" href="class_chimera_t_k_1_1_device_backend.html#a85a134106068b02a89cbfa9a4559ccfc" title="Get a NDRegisterAccessor object from the register name.">DeviceBackend::getRegisterAccessor()</a> with the same arguments) will replace one of the identical <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> with a decorator which copies the data from the other. [<a class="el" href="test_transfer_group_8cpp.html#testTransferElement_B_12_8">T</a>]<ul>
<li>12.8.1 This avoids an unnecessary transfer of identical data.</li>
<li><a class="anchor" id="transferElement_B_12_8_2"></a>12.8.2 This is only possible, if the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> is added by passing a <a class="el" href="class_chimera_t_k_1_1_transfer_element_abstractor.html" title="Base class for register accessors abstractors independent of the UserType.">TransferElementAbstractor</a> to <a class="el" href="class_chimera_t_k_1_1_transfer_group.html#a105197b54833784c119bc3f445ae8a91" title="Add a register accessor to the group.">TransferGroup::addAccessor()</a>. <a class="el" href="spec__transfer_element.html#transferElement_comment_B_12_8_2">(*)</a></li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_12_9"></a>12.9 Operations executed via <a class="el" href="class_chimera_t_k_1_1_transfer_group.html#af8df339d4a0700087e48d57223231d88" title="Trigger read transfer for all accessors in the group.">TransferGroup::read()</a> and <a class="el" href="class_chimera_t_k_1_1_transfer_group.html#a86287fe11f64206207e0d868ed83c3db" title="Trigger write transfer for all accessors in the group.">TransferGroup::write()</a>: [<a class="el" href="test_transfer_group_8cpp.html#testTransferElement_B_12_9">T</a> (with sub-points)]<ul>
<li><a class="anchor" id="transferElement_B_12_9_1"></a>12.9.1 first call preXxx() on all high-level elements (cf. <a class="el" href="spec__transfer_element.html#transferElement_B_12_1_2_1">12.1.2.1</a>),</li>
<li><a class="anchor" id="transferElement_B_12_9_2"></a>12.9.2 next call the corresponding xxxTransferYyy() on all low-level elements (cf. <a class="el" href="spec__transfer_element.html#transferElement_B_12_1_2_2">12.1.2.2</a>), and</li>
<li><a class="anchor" id="transferElement_B_12_9_3"></a>12.9.3 finally call postXxx() on all high-level elements.</li>
</ul>
</li>
<li>12.10 The <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group.">TransferGroup</a> implements a similar exception handling in <a class="el" href="class_chimera_t_k_1_1_transfer_group.html#af8df339d4a0700087e48d57223231d88" title="Trigger read transfer for all accessors in the group.">TransferGroup::read()</a> and <a class="el" href="class_chimera_t_k_1_1_transfer_group.html#a86287fe11f64206207e0d868ed83c3db" title="Trigger write transfer for all accessors in the group.">TransferGroup::write()</a> as their <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> counterparts. This especially means:<ul>
<li><a class="anchor" id="transferElement_B_12_10_1"></a>12.10.1 (removed)</li>
<li><a class="anchor" id="transferElement_B_12_10_2"></a>12.10.2 If <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">ChimeraTK::runtime_error</a> exceptions occur during preXxx()<ul>
<li><a class="anchor" id="transferElement_B_12_10_2_1"></a>12.10.2.1 still all preXxx() are executed.</li>
<li><a class="anchor" id="transferElement_B_12_10_2_2"></a>12.10.2.2 the whole transfer phase is skipped.</li>
<li><a class="anchor" id="transferElement_B_12_10_2_3"></a>12.10.2.3 This implies that TransferElements in TransferGroups must expect that the transfer is not executed, even if preXxx() has not thrown an exception. See <a class="el" href="spec__transfer_element.html#transferElement_B_4_2_5">B.4.2.5</a>.</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_12_10_3"></a>12.10.3 <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">ChimeraTK::runtime_error</a> exceptions thrown by the low-level elements are propagated to the corresponding high-level elements so they are seen by their postXxx() functions (c.f. <a class="el" href="spec__transfer_element.html#transferElement_B_6_3">6.3</a>) [<a class="el" href="test_transfer_group_8cpp.html#testTransferElement_B_12_10_3">INCOMPLETE T</a>]</li>
<li><a class="anchor" id="transferElement_B_12_10_4"></a>12.10.4 postXxx() is called for all high level elements, even if some postXxx() throw exceptions (c.f. <a class="el" href="spec__transfer_element.html#transferElement_B_5">5</a>). [<a class="el" href="test_transfer_group_8cpp.html#testTransferElement_B_12_10_4">T</a>]</li>
<li><a class="anchor" id="transferElement_B_12_10_5"></a>12.10.5 The first exception that has been caught in <a class="el" href="spec__transfer_element.html#transferElement_B_12_9_1">12.9.1</a>, <a class="el" href="spec__transfer_element.html#transferElement_B_12_9_2">12.9.2</a> or <a class="el" href="spec__transfer_element.html#transferElement_B_12_9_3">12.9.3</a> is re-thrown. [<a class="el" href="test_transfer_group_8cpp.html#testTransferElement_B_12_10_5">INCOMPLETE T</a>]</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_12_11"></a>12.11 If a <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">ChimeraTK::runtime_error</a> is thrown, the content of the application buffers of all elements is not changed. (c.f. <a class="el" href="spec__transfer_element.html#transferElement_B_6_4">6.4</a>)<ul>
<li><a class="anchor" id="transferElement_B_12_11_1"></a>12.11.1 The <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group.">TransferGroup</a> calls postRead() of all elements with <code>updateDataBuffer = false</code>, if any element has thrown a <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">ChimeraTK::runtime_error</a>. [<a class="el" href="test_transfer_group_8cpp.html#testTransferElement_B_12_11_1">T</a>]</li>
</ul>
</li>
<li>12.12 The <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group.">TransferGroup</a> calls postRead() on copy decorators first (see <a class="el" href="spec__transfer_element.html#transferElement_B_12_1_4_1_1">12.1.4.1.1</a> and <a class="el" href="spec__transfer_element.html#transferElement_B_12_8">12.8</a>).</li>
</ul>
</li>
<li>13. <a class="el" href="class_chimera_t_k_1_1_read_any_group.html" title="Group several registers (= TransferElement) to allow waiting for an update of any of the registers.">ReadAnyGroup</a> [TODO]</li>
<li>14. <a class="el" href="class_chimera_t_k_1_1_data_consistency_group.html" title="Group several registers (= TransferElement) which ensures data consistency across multiple variables ...">DataConsistencyGroup</a> [TODO]</li>
<li>15. <a class="el" href="class_chimera_t_k_1_1_access_mode_flags.html" title="Set of AccessMode flags with additional functionality for an easier handling.">AccessModeFlags</a><ul>
<li>15.1 The <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> has a protected object <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a35e5595381e62b6f86d524761c3be44b" title="The access mode flags for this transfer element.">TransferElement::_accessModeFlags</a>.</li>
<li><a class="anchor" id="transferElement_B_15_2"></a>15.2 It can be read via <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a8f56d7bf9861f32b695d863a646d7dc8" title="Return the AccessModeFlags for this TransferElement.">TransferElement::getAccessModeFlags()</a>. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_15_2">T</a>]</li>
<li><a class="anchor" id="transferElement_B_15_3"></a>15.3 It is set through a constructor argument of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_15_3">T</a>]<ul>
<li><a class="anchor" id="transferElement_B_15_3_1"></a>15.3.1 The constructor argument does not have a default value. It must be set correctly by the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> implementation in their constructor. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_15_3_1">T</a>]</li>
</ul>
</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_B_16"></a>16. This section will be moved from <a class="el" href="spec__transfer_element.html#transferElement_C_2">C.2</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md9"></a>
(*) Comments</h3>
<ul>
<li><a class="anchor" id="transferElement_comment_B_2_5_1"></a> <a class="el" href="spec__transfer_element.html#transferElement_B_2_5_1">2.5.1</a> Backends which don't support data validity flags (like the PCIe backend) just get the clampled value. The DOOCS backend however, which supports data validity, sets the outgoing data to invalid in addition.</li>
<li><a class="anchor" id="transferElement_comment_B_3_2_2_2"></a><a class="el" href="spec__transfer_element.html#transferElement_B_3_2_2_2">3.2.2.2</a> The optimisation is still optional, backends are allowed to not make use of it. In this case, the content of the application buffer will be intact after <a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7abc219b057095a6e31adf97545d6b6ea6">writeDestructively()</a>. Applications still are not allowed to use the content of the application buffer after <a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7abc219b057095a6e31adf97545d6b6ea6">writeDestructively()</a>.</li>
<li>4.1 preXxx() is part of the operation, not of the actual transfer. In case of reads with <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read.">AccessMode::wait_for_new_data</a> the transfer is asynchronously initiated by the device and not connected to the operation. Hence backend implementations usually have an empty doPreWrite(), but decorator-like implementations still can use it to execute preparatory tasks.</li>
<li>4.3.1 In write operations the buffer might be swapped out in doPreWrite() and swapped back in doPostWrite() to restore it for non-destructive write operations to avoid copying of large arrays.</li>
<li>5. Reason: It might be that the user buffer has to be swapped out during the transfer (while taking away the ownership of the calling code), and this must be restored in the postXxx action.</li>
<li><a class="anchor" id="transferElement_comment_B_5_1"></a><a class="el" href="spec__transfer_element.html#transferElement_B_5_1">5.1</a> The boost::thread_interrupted exception, which is thrown internally as described in <a class="el" href="spec__transfer_element.html#transferElement_B_8_6">8.6</a>, is treated equally.</li>
<li><a class="anchor" id="transferElement_comment_B_7_2"></a><a class="el" href="spec__transfer_element.html#transferElement_B_7_2">7.2</a> Usually, writes are implemented as synchronous transfers, in which case no previous data can be lost. In case of asynchronous write transfers (as e.g. implemented in the ControlSystemAdapter's ProcessArray), the implementation must ensure the specified behaviour e.g. by using cppext::future_queue::push_overwrite() or a similar functionality. Please keep in mind that the return value of cppext::future_queue::push_overwrite() does not guarantee which data is lost <em>only</em> if concurrent push_overwrite() calls are executed in a multi-producer environment. TransferElements are not thread safe anyway, hence push_overwrite() will always overwrite old data in this context.</li>
<li><a class="anchor" id="transferElement_comment_B_7_4"></a><a class="el" href="spec__transfer_element.html#transferElement_B_7_4">7.4</a> This is required by the ApplicationCore::ExceptionHandlingDecorator. It suppresses the exception, but decorators around it must not change their data buffer (c.f. <a class="el" href="spec__transfer_element.html#transferElement_E_6_1_1">E.6.1.1</a>).</li>
<li>8.2.2 This allows to discard values inside a continuation of a cppext::future_queue. It is used e.g. by the ControlSystemAdapter's BidirectionalProcessArray. [TBD: It could be replaced by a feature of the cppext::future_queue allowing to reject values in continuations...]</li>
<li>8.5 <a class="el" href="class_chimera_t_k_1_1_device.html#a0a86afbebd076b8bc1d7bc6fe87db89d" title="Re-open the device after previously closeing it by calling close(), or when it was constructed with a...">Device::open()</a> does not automatically activate the asyncronous sending because the device might need some initalisation setting to produce valid data (for example setting the correct ADC range). By delaing the activation of asyncronous reads the application has the possibility to do the initialisation before the first data is being send, and can avoid invalid initial values on the process variables.</li>
<li>8.5.1 Conceptually activating an asyncronous read is like subscribing a variable, and deactivating it is like unsubscribing a variable in a publish-subscribe pattern. The actual implementation depends on the details of the protocols.</li>
<li>8.5.2 As the asynchonous mechanism and a synchronous read are two idependent channels there are potential race condition, depending on the exact protocol. The backend has to avoid this if possible. If it cannot be avoided, the implementation must make sure that the last value in the queue is the newest value, and this is not dopped or missed, even if the values before are not in order or send twice.</li>
<li><a class="anchor" id="transferElement_comment_B_8_6_6"></a><a class="el" href="spec__transfer_element.html#transferElement_B_8_6_6">8.6.6</a> The current default implementation in the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> base class is always throwing a <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured.">ChimeraTK::logic_error</a> to inform the programmer that the function has to be overridden for all implementations with wait_for_new_data.</li>
<li><a class="anchor" id="transferElement_comment_B_8_6_6_1"></a><a class="el" href="spec__transfer_element.html#transferElement_B_8_6_6_1">8.6.6.1</a> This requirement is merely a work-around for not knowing the type of the <a class="el" href="spec__transfer_element.html#transferElement_data_transport_queue">implementation-specific data transport queue</a> in the TransferElement/NDRegisterAccessor base classes. It is planned to change this, in which case interrupt() may be implemented in one of the base classes. Hence, no additional, backend-specific code may be placed in the implementation now.</li>
<li><a class="anchor" id="transferElement_comment_B_8_6_6_2"></a><a class="el" href="spec__transfer_element.html#transferElement_B_8_6_6_2">8.6.6.2</a> This is already implemented in the <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html" title="Base class for decorators of the NDRegisterAccessor.">NDRegisterAccessorDecorator</a> base class.</li>
<li><a class="anchor" id="transferElement_comment_B_9a"></a><a class="el" href="spec__transfer_element.html#transferElement_B_9">9.</a> The <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">ChimeraTK::runtime_error</a> is the only exception that conceptually is recoverable. This is done by calling <a class="el" href="class_chimera_t_k_1_1_device_backend.html#a9da6866e3f0b481e1fcc13985382f5f9" title="Open the device.">DeviceBackend::open()</a>. Other exceptions are not recoverable by the running application:<ul>
<li><a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured.">ChimeraTK::logic_error</a> is a programming or configuration mistake.</li>
<li>The boost::thread_interrupted is thrown when <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#af92b78c177bc98923a78a0d4faaf9e05" title="Return from a blocking read immediately and throw boost::thread_interrupted.">TransferElement::interrupt()</a> is called. It means that a blocking <a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7aecae13117d6f0584c25a9da6c8f8415e">read()</a> has been interrupted on request. It is not an error and hence there is nothing to recover.</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_comment_B_9b"></a><a class="el" href="spec__transfer_element.html#transferElement_B_9">9.</a> It does not matter if the exception occured in an asynchronous or synchronous read, or in a write operation.</li>
<li><a class="anchor" id="transferElement_comment_B_9_1"></a><a class="el" href="spec__transfer_element.html#transferElement_B_9_1">9.1</a> It depends on the implementation whether the backend already has done 9.3 and 9.4 when the transfer elements first sees the exeption and then reports it back again via <a class="el" href="class_chimera_t_k_1_1_device_backend.html#ab3d996241286ea3b233e3ea59824b670" title="Set the backend into an exception state.">DeviceBackend::setException()</a>, or if it only happend in that function. The important part is that meta-backends and the user application can trigger this situation (see <a class="el" href="spec__transfer_element.html#transferElement_B_9_2_1">9.2.1</a> and <a class="el" href="spec__transfer_element.html#transferElement_B_9_2_3">9.2.3</a>)</li>
<li><a class="anchor" id="transferElement_comment_B_9_1_4"></a><a class="el" href="spec__transfer_element.html#transferElement_B_9_1_4">9.1.4</a> This functionality is already implemented in the <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html" title="Base class for decorators of the NDRegisterAccessor.">NDRegisterAccessorDecorator</a> base class. It does not apply for decorator-like TransferElements which are created by meta-backends. They have to set their own and their target's _exceptionBackend to the meta-backend (c.f. <a class="el" href="spec__transfer_element.html#transferElement_B_9_1_2">9.1.2</a>).</li>
<li><a class="anchor" id="transferElement_comment_B_9_2"></a><a class="el" href="spec__transfer_element.html#transferElement_B_9_2">9.2</a> 'setException() triggers the actions' does not mean all those actions are completed. Especially it is not guaranteed that all async transfers are already done and the exceptions are already send when the setException() call returns.</li>
<li><a class="anchor" id="transferElement_comment_B_9_2_3"></a><a class="el" href="spec__transfer_element.html#transferElement_B_9_2_3">9.2.3</a> For instance a watchdog which monitors a reference register to detect firmware reboots that is not seen on the transport layer can trigger the exception state to inhibit asynchronous transfers while running a recovery procedure.</li>
<li>9.3.1 Open can be called again on an already opened backend to start error recovery.</li>
<li>9.3.2 If an asynchronous read transfer is the first one to detect the exception, the implementation must make sure that it is only pushed once into the queue, and informing "all" transfer elememnts with wait_for_new data does not send it again if it was already put into the queue.</li>
<li>9.3.4 Avoid race conditions here. The call to <a class="el" href="class_chimera_t_k_1_1_device.html#ad7c7d319aa029ecdb9a1e5aae5e667af" title="Activate asyncronous read for all transfer elements where AccessMode::wait_for_new_data is set.">Device::activateAsyncRead()</a> usually is done from a different thread than the transfer which caused the exception.</li>
<li><a class="anchor" id="transferElement_comment_B_11_2_1"></a><a class="el" href="spec__transfer_element.html#transferElement_B_11_2_1">11.2.1</a> This means the version number has to be created as soon as data is received, for instance in the receiver thread of a <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> with <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read.">AccessMode::wait_for_new_data</a>, and not in the doPostRead() of the <a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7aecae13117d6f0584c25a9da6c8f8415e">read()</a> operation.</li>
<li><a class="anchor" id="transferElement_comment_B_11_4_1"></a><a class="el" href="spec__transfer_element.html#transferElement_B_11_4_1">11.4.1</a> Smaller version numbers on later write calls of a different instance can conceptionally not be avoided if the instances are used by different, unsynchronised threads. Even within the same thread, the information written to different instances can come from different sources and hence might have independent version numbers.</li>
<li><a class="anchor" id="transferElement_comment_B_11_7_1"></a><a class="el" href="spec__transfer_element.html#transferElement_B_11_7_1">11.7.1</a> If a write call is done there might be older data in the read queue, which results in a lower version number once a read is called.</li>
<li><a class="anchor" id="transferElement_comment_B_11_7_2"></a><a class="el" href="spec__transfer_element.html#transferElement_B_11_7_2">11.7.2</a> The BiDirectionalProcessArray is implemented like this.</li>
<li><a class="anchor" id="transferElement_comment_B_12_1_5_1"></a><a class="el" href="spec__transfer_element.html#transferElement_B_12_1_5_1">12.1.5.1</a> Otherwise all implementations of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a791a4902b649e859fbadea20cc90ede2" title="Search for all underlying TransferElements which are considered identical (see sameRegister()) with t...">TransferElement::replaceTransferElement()</a> would have to do an additional check for equality of the incoming element with their target before putting a copy decorator. This is easily forgotten and leads to subtle bugs which are difficult to track down.</li>
<li><a class="anchor" id="transferElement_comment_B_12_8_2"></a><a class="el" href="spec__transfer_element.html#transferElement_B_12_8_2">12.8.2</a> The reason is that there needs to be some entity which holds the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> to be replaced. If it is directly used by the calling code, the <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group.">TransferGroup</a> has no means to replace it.</li>
</ul>
<h2><a class="anchor" id="autotoc_md10"></a>
C. Requirements for all implementations (full and decorator-like)</h2>
<ul>
<li>1. Other exceptions than <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured.">ChimeraTK::logic_error</a> and <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">ChimeraTK::runtime_error</a> are not allowed to be thrown or passed through at any place under any circumstance (unless of course they are guaranteed to be caught before they become visible to the application, like the detail::DiscardValueException). The framework (in particular ApplicationCore) may use "uncatchable" exceptions in some places to force the termination of the application. Backend implementations etc. may not do this, since it would lead to uncontrollable behaviour.</li>
<li><p class="startli"><a class="anchor" id="transferElement_C_2"></a>2. <b>This section wil be moved to</b> <a class="el" href="spec__transfer_element.html#transferElement_B_16">B.16</a>.</p>
<p class="startli">In doPostXxx no new <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">ChimeraTK::runtime_error</a> or <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured.">ChimeraTK::logic_error</a> are thrown. Exceptions that were risen in doPreXxx or doXxxTransferYyy, or that were received from the queue (see B.8.3) are rethrown. <a class="el" href="spec__transfer_element.html#transferElement_comment_C_2">(*)</a></p><ul>
<li><a class="anchor" id="transferElement_C_2_1"></a><a class="anchor" id="transferElement_B_16_1"></a>2.1 The <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> base class stores the caught exceptions in <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a779b431f4a3452f6e41bf3da48fb5bef" title="Exception to be rethrown in postXXX() in case hasSeenException == true Can be set via setActiveExcept...">TransferElement::_activeException</a>. [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_16_1">T</a>]</li>
<li><a class="anchor" id="transferElement_C_2_2"></a><a class="anchor" id="transferElement_B_16_2"></a>2.2 postXxx() is re-throwing the exception after delegating to doPostXxx(). [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_16_2">T</a>]</li>
<li><a class="anchor" id="transferElement_C_2_3"></a><a class="anchor" id="transferElement_B_16_3"></a>2.3 Decorators delegate the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a779b431f4a3452f6e41bf3da48fb5bef" title="Exception to be rethrown in postXXX() in case hasSeenException == true Can be set via setActiveExcept...">TransferElement::_activeException</a> to their target using <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#adb356d062ef74ccc271a2f58328b295e" title="Set an active exception.">TransferElement::setActiveException()</a>. If the decorator's _activeException is not nullptr, the targets _activeException is replaced by it, and the decorator's _activeException, which is handed by reference, is set to nullptr <a class="el" href="spec__transfer_element.html#transferElement_comment_C_2_3a">(*)</a>. The target is now responsible for handling the exception. If the decorator's _activeException already is nullptr, setActiveException() has no effect, so an active exception in the target is not overwritten <a class="el" href="spec__transfer_element.html#transferElement_comment_C_2_3b">(*)</a>. <a class="el" href="spec__transfer_element.html#transferElement_comment_C_2_3c">(*)</a> [<a class="el" href="test_transfer_element_8cpp.html#testTransferElement_B_16_3">T</a> (only setActiveException())]<ul>
<li>2.3.1 Decorators which are throwing themselves in doPreXxx(), before delegating to the target preXxx(), remember this. If they did throw in doPreXxx(), then in doPostXxx() they do not call setActiveException() of the target and do not delegate to postXxx(). The exception is then re-thrown by the decorator's postXxx().</li>
</ul>
</li>
</ul>
</li>
<li>3. <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">ChimeraTK::runtime_error</a> in principle are recoverable. It is thrown, if the device (including the communication link) does not behave as expected. A later call to the same function (after the recovery has been triggered, cf. <a class="el" href="spec__transfer_element.html#transferElement_B_9_3_1">B.9.3.1</a> resp. <a class="el" href="spec__transfer_element.html#transferElement_B_9_4_1">B.9.4.1</a>) must be able to succeed (for instance if a network outage has been resolved). <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">ChimeraTK::runtime_error</a> may only be thrown in<ul>
<li>3.1 doXxxTransferYyy(). It is the only exception that can occur in this function</li>
<li>3.2 <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a9045dd72e498456e821811ef551b9946" title="Check if transfer element is readable.">TransferElement::isReadable()</a>, <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#accfe1aea9752501fd25381d3e3bdbee8" title="Check if transfer element is writeable.">TransferElement::isWriteable()</a> or <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#afb77cfdfd4be6fbf76f16d9ada9d2134" title="Check if transfer element is read only, i.e.">TransferElement::isReadOnly()</a> if there is no map file or such, and it needs to be determined from the running device.</li>
<li><a class="anchor" id="transferElement_C_3_3"></a>3.3 doPreXxx(), if the device is not functional and the transfer needs to be skipped so it does not interfere with a device recovery procedure. <a class="el" href="spec__transfer_element.html#transferElement_comment_C_3_3">(*)</a></li>
</ul>
</li>
<li><a class="anchor" id="transferElement_C_4"></a>4. (removed)</li>
<li>5. <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured.">ChimeraTK::logic_error</a> must follow strict conditions. It is thrown, if the application (including its configuration files) does not behave as expected.<ul>
<li>5.1 logic_errors must be deterministic. They must always be avoidable by calling the corresponding test functions before executing a potentially failing action (*), and must occur if the logical condition is not fulfilled and the function is called anyway.</li>
<li><a class="anchor" id="transferElement_C_5_2"></a>5.2 Any <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured.">logic_error</a> must be thrown as early as possible <a class="el" href="spec__transfer_element.html#transferElement_comment_C_5_2">(*)</a>. They are thrown <b>if and only if</b> one of the following conditions are met:<ul>
<li>5.2.1 A register does not exists my that name<ul>
<li><a class="anchor" id="transferElement_C_5_2_1_1"></a>5.2.1.1 Can be checked in the catalogue <a class="el" href="spec__transfer_element.html#transferElement_comment_C_5_2_1_1">(*)</a></li>
<li><a class="anchor" id="transferElement_C_5_2_1_2"></a>5.2.1.2 Thrown in the constructor. [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_C_5_2_1_2">U</a>]</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_C_5_2_2"></a>5.2.2 The size or dimension of the requested <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> is too large <a class="el" href="spec__transfer_element.html#transferElement_comment_C_5_2_2">(*)</a><ul>
<li>5.2.2.1 Can be checked in the catalogue.</li>
<li><a class="anchor" id="transferElement_C_5_2_2_2"></a>5.2.2.2 Thrown in the constructor. [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_C_5_2_2_2">U</a>]</li>
</ul>
</li>
<li>5.2.3 The wrong AccessMode flags are provided<ul>
<li>5.2.3.1 Can be checked in the catalogue.</li>
<li><a class="anchor" id="transferElement_C_5_2_3_2"></a>5.2.3.2 Thrown in the constructor. [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_C_5_2_3_2">U</a>]</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_C_5_2_4"></a>5.2.4 (removed)</li>
<li>5.2.5 A read/write operation is started while the backend is still closed<ul>
<li>5.2.5.1 Check with <a class="el" href="class_chimera_t_k_1_1_device_backend.html#a877f0db7d0c63becf2bd8b8fb0955e60" title="Return whether a device has been opened or not.">DeviceBackend::isOpen()</a>.</li>
<li><a class="anchor" id="transferElement_C_5_2_5_2"></a>5.2.5.2 Thrown in doPreXxx() <a class="el" href="spec__transfer_element.html#transferElement_comment_C_5_2_5_2">(*)</a>. [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_C_5_2_5_2">U</a>]</li>
</ul>
</li>
<li>5.2.6 A read operation is executed on a transfer element that cannot be read<ul>
<li>5.2.6.1 Check with <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a9045dd72e498456e821811ef551b9946" title="Check if transfer element is readable.">TransferElement::isReadable()</a>.</li>
<li><a class="anchor" id="transferElement_C_5_2_6_2"></a>5.2.6.2 Thrown in doPreRead() [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_C_5_2_6_2">U</a>]</li>
</ul>
</li>
<li>5.2.7 A write operation is executed on a transfer element that cannot be written<ul>
<li>5.2.7.1 Check with <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#accfe1aea9752501fd25381d3e3bdbee8" title="Check if transfer element is writeable.">TransferElement::isWriteable()</a> or <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#afb77cfdfd4be6fbf76f16d9ada9d2134" title="Check if transfer element is read only, i.e.">TransferElement::isReadOnly()</a></li>
<li><a class="anchor" id="transferElement_C_5_2_7_2"></a>5.2.7.2 Thrown in doPreWrite() [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_C_5_2_7_2">U</a>]</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_C_5_2_8"></a>5.2.8 A <a class="el" href="class_chimera_t_k_1_1_scalar_register_accessor.html" title="Accessor class to read and write scalar registers transparently by using the accessor object like a v...">ScalarRegisterAccessor</a>, <a class="el" href="class_chimera_t_k_1_1_one_d_register_accessor.html" title="Accessor class to read and write registers transparently by using the accessor object like a vector o...">OneDRegisterAccessor</a> or <a class="el" href="class_chimera_t_k_1_1_two_d_register_accessor.html" title="Accessor class to read and write 2D registers.">TwoDRegisterAccessor</a> is instantiated with UserType <a class="el" href="class_chimera_t_k_1_1_void.html" title="Wrapper Class for void.">ChimeraTK::Void</a>. <a class="el" href="spec__transfer_element.html#transferElement_comment_C_5_2_8">(*)</a><ul>
<li>Throws in constructor</li>
</ul>
</li>
<li>5.2.9 A read-only <a class="el" href="class_chimera_t_k_1_1_void_register_accessor.html" title="Accessor class to read and write void-typed registers.">VoidRegisterAccessor</a> that does not have the wait_for_new_data flag is instantiated.<ul>
<li>Throws in constructor.</li>
</ul>
</li>
</ul>
</li>
<li><a class="anchor" id="transferElement_C_5_3"></a>5.3 The information mentioned in 5.2 which determines whether a <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured.">ChimeraTK::logic_error</a> is thrown is considered to be constant for each <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>. Only when a <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">ChimeraTK::runtime_error</a> is thrown by the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>, the information might change and applications are expected to check it again. [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_C_5_3">U</a>]<ul>
<li><a class="anchor" id="transferElement_C_5_3_1"></a>5.3.1 If a device is changing this information on its own (e.g. makes a register read-only which was readable before), and the application hence performes an operation which is no longer possible, a <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">ChimeraTK::runtime_error</a> must be thrown (unexpected behaviour of the device). <a class="el" href="spec__transfer_element.html#transferElement_comment_C_5_3_1">(*)</a> [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_C_5_3_1">U</a>]</li>
<li><a class="anchor" id="transferElement_C_5_3_2"></a>5.3.2 If an implementation needs to obtain the information from the device (and hence the information might potentially change), it caches the information for each <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> separately. [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_C_5_3_2">U</a>]</li>
<li><a class="anchor" id="transferElement_C_5_3_3"></a>5.3.3 Implementations of the test functions always return the cached information, if available. [<a class="el" href="class_chimera_t_k_1_1_unified_backend_test.html#UnifiedTest_TransferElement_C_5_3_3">U</a>]</li>
<li>5.3.4 If the test function needs to obtain the information from the device, a <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">runtime_error</a> might occur.</li>
</ul>
</li>
<li>5.4 Remarks about how to follow these rules:<ul>
<li>5.4.1 If there is an error in the map file and the backend does not want to fail on this in backend creation, the register must be hidden from the catalogue.</li>
<li>5.4.2 Implementations of doPreXxx() use these test functions to check the preconditions, but discard any <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">runtime_error</a> exception. The following doXxxTransferYyy() will then either throw a <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">runtime_error</a> (cf. 5.3.1) or succeed.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md11"></a>
(*) Comments</h3>
<ul>
<li><a class="anchor" id="transferElement_comment_C_2"></a><a class="el" href="spec__transfer_element.html#transferElement_C_2">2.</a> This concerns all exceptions that were caught, not only <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">ChimeraTK::runtime_error</a> and <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured.">ChimeraTK::logic_error</a>.</li>
<li><a class="anchor" id="transferElement_comment_C_2_3a"></a><a class="el" href="spec__transfer_element.html#transferElement_C_2_3">2.3</a> It is important that after calling the target's setActiveException(), the decorator has a nullptr in its _activeException. This is for instance required if the target is the ApplicationCore::ExceptionHandlingDecorator. It suppresses the exception and then the outer layers must not throw any more.</li>
<li><a class="anchor" id="transferElement_comment_C_2_3b"></a><a class="el" href="spec__transfer_element.html#transferElement_C_2_3">2.3</a> Notice that if both the decorator and the target <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> have an active exception, the exception in the target is replaced. This is intentional. It can only happen if the same low level <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> is used by several high level elements in a <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group.">TransferGroup</a>. In this case the tranfer had not been executed because the high level elements had already seen the exception in preXxx, and the exception in the target can only be the exception which had been put in by another high level element in its doPostXxx, and thus has already been thrown.</li>
<li><a class="anchor" id="transferElement_comment_C_2_3c"></a><a class="el" href="spec__transfer_element.html#transferElement_C_2_3">2.3</a> This behaviour is implemented in doPostXxx() of the <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html" title="Base class for decorators of the NDRegisterAccessor.">NDRegisterAccessorDecorator</a> base class, which is usually called by decorator implementations.</li>
<li><a class="anchor" id="transferElement_comment_C_3_3"></a><a class="el" href="spec__transfer_element.html#transferElement_C_3_3">3.3</a> This is for instance required by the ApplicationCore ExceptionHandlingDecorator, but also can in general be required in a multi-threaded scenario where the transfers happen in a different thread than the device recovery.</li>
<li>5.1 Test functions do not yet exist for everything. This needs to be changed!</li>
<li><a class="anchor" id="transferElement_comment_C_5_2"></a><a class="el" href="spec__transfer_element.html#transferElement_C_5_2">5.2</a> Especially no <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured.">logic_error</a> must be thrown in doXxxTransferYyy() or doPostXxx(). All tests for logical consistency must be done in doPreXxx() latest.</li>
<li><a class="anchor" id="transferElement_comment_C_5_2_1_1"></a><a class="el" href="spec__transfer_element.html#transferElement_C_5_2_1_1">5.2.1.1</a> It is legal to provide "hidden" registers not present in the catalogue, but a register listed in the catalogue must always work.</li>
<li><a class="anchor" id="transferElement_comment_C_5_2_2"></a><a class="el" href="spec__transfer_element.html#transferElement_C_5_2_2">5.2.2</a> This also includes that the offset in a one dimensional case is so large that there are not enough elements left to provide the requested data.</li>
<li><a class="anchor" id="transferElement_comment_C_5_2_5_2"></a><a class="el" href="spec__transfer_element.html#transferElement_C_5_2_5_2">5.2.5.2</a> The generic tests if a backend is opened, or if an accessor readable or writeable are intentionally not implemented in <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> because they would invovle additional virtual function calls. To avoid these each implementation has to implement the checks in doPreXxx().</li>
<li><a class="anchor" id="transferElement_comment_C_5_2_8"></a><a class="el" href="spec__transfer_element.html#transferElement_C_5_2_8">5.2.8</a> A <a class="el" href="class_chimera_t_k_1_1_void_register_accessor.html" title="Accessor class to read and write void-typed registers.">VoidRegisterAccessor</a> has to be used instead.</li>
<li><a class="anchor" id="transferElement_comment_C_5_3_1"></a><a class="el" href="spec__transfer_element.html#transferElement_C_5_3_1">5.3.1</a> To recover from the <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">ChimeraTK::runtime_error</a>, the application must call open(). At that point, the information is allowed to be changed. If the application fails to recheck the information, a retry of the failed operation will result in a <a class="el" href="class_chimera_t_k_1_1logic__error.html" title="Exception thrown when a logic error has occured.">ChimeraTK::logic_error</a>. This behaviour follows the requirement to throw logic_errors only in doPreXxx(): if during a transfer the backend discovers that the operation is no longer allowed, a <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">runtime_error</a> must be thrown.</li>
</ul>
<h2><a class="anchor" id="autotoc_md12"></a>
D. Requirements for full implementations (e.g. in backends)</h2>
<ul>
<li>1. If <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read.">AccessMode::wait_for_new_data</a> is specified:</li>
<li><a class="anchor" id="transferElement_D_1_1"></a>1.1 As the <em>implementation-specific data transport queue</em> has to work with push_overwrite and push_overwrite_exception, it has to have a minimum length of 2.<ul>
<li>1.2 <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab824c85c63163e76ccda588ef4768f68" title="The queue for asynchronous read transfers.">TransferElement::_readQueue</a> is initialised in the constructor. [TBD: Allow setting the queue length through the public API?]</li>
<li>1.3 <em>implementation-specific data transport queue</em> is pushed whenever new data has arrived. If important for the implementation, the return value of cppext::future_queue::push_overwrite() will tell whether data has been discarded (*).</li>
<li><a class="anchor" id="transferElement_D_1_4"></a>1.4 In case an exception is detected during an asychronous transfer (for instance in a separate thread), the exception must be pushed to the <em>implementation-specific data transport queue</em> so it can be received through the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab824c85c63163e76ccda588ef4768f68" title="The queue for asynchronous read transfers.">TransferElement::_readQueue</a> <a class="el" href="spec__transfer_element.html#transferElement_comment_D_1_4">(*)</a>. The <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> implementation will then make sure that the exception is properly rethrown in postRead (just like for synchronous transfers).</li>
</ul>
</li>
<li>2. In doPostRead() the whole application buffer (data buffer and meta data) must be updated together if updateDataBuffer is true and there was no exception, or not at all in all other cases.</li>
</ul>
<h3><a class="anchor" id="autotoc_md13"></a>
(*) Comments</h3>
<ul>
<li>1.3 Either the currently pushed data or older data on the queue might be discarded. In any case there will be one fewer read operation because the number of entries in the queue could not be increased because it was full.</li>
<li><a class="anchor" id="transferElement_comment_D_1_4"></a><a class="el" href="spec__transfer_element.html#transferElement_D_1_4">1.4</a> All data and exceptions must be pushed into the data transport queue. As <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab824c85c63163e76ccda588ef4768f68" title="The queue for asynchronous read transfers.">TransferElement::_readQueue</a> is a deferred continuation queue, a pop_wait() is waiting for data on the original queue and does not see that something has been but into the deferred queue.</li>
</ul>
<h2><a class="anchor" id="autotoc_md14"></a>
E. Requirements for decorator-like implementations</h2>
<ul>
<li>1. If <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read.">AccessMode::wait_for_new_data</a> is specified, <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab824c85c63163e76ccda588ef4768f68" title="The queue for asynchronous read transfers.">TransferElement::_readQueue</a> is initialised in the constructor with a copy of the readQueue of the target <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>.<ul>
<li>1.1 Decorator-like implementations with multiple targets must provide a readQueue e.g. by using cppext::future_queue::when_any() or cppext::future_queue::when_all().</li>
</ul>
</li>
<li>2. All functions doPreXxx, doXxxTransferYyy and doPostXxx must delegate to their non-do counterparts (preXxx, xxxTransferYyy and postXxx). Never delegate to the do... of the target implementation functions directly.</li>
<li>3. If a function of the same instance should be called, e.g. if doWriteTransferDestructively() should redirect to doWriteTransfer(), or if doPostRead() should call doPostRead() of a base class, call to do-version of the function. This is merely to avoid code duplication, hence the surrounding logic of the non-do function is not wanted here.</li>
<li>4. Decorators must merely delegate doXxxTransferYyy, never add any functionalty there. Reason: <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group.">TransferGroup</a> might effectively bypass the decorator implementation of these functions.</li>
<li>5. All real decorators are in fact decorators of NDRegisterAccessors&lt;USER_TYPE&gt;. Each decoration level contains one NDRegisterAccessors&lt;USER_TYPE&gt;::buffer_2D. The decorator implementation must make sure that its buffer is correctly synchronised with the target's buffer.(*)</li>
<li>6. <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a9ad34f0c2eaec6be3dc385f1c4acef46" title="The version number of the last successful transfer.">TransferElement::_versionNumber</a> and TransferElement::_dataValitiy are also part of the applicaton buffer. They also must be synchronised.<ul>
<li>6.1 When reading, <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a9ad34f0c2eaec6be3dc385f1c4acef46" title="The version number of the last successful transfer.">TransferElement::_versionNumber</a> and <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a39c613419eebb2f29590fecded7a96d0" title="The validity of the data in the application buffer.">TransferElement::_dataValidity</a> have to be copied over in doPostRead(), after a delegating to the target postRead() and only if there has been no exception.<ul>
<li><a class="anchor" id="transferElement_E_6_1_1"></a>6.1.1 Decorators then must always copy the meta data from their target, even if updateDataBuffer is false and NDRegisterAccessors&lt;USER_TYPE&gt;::buffer_2D is not updated. <a class="el" href="spec__transfer_element.html#transferElement_comment_E_6_1_1">(*)</a></li>
<li>6.1.2 The data buffer is updated if there has been no exception and if updateDataBuffer is true.</li>
</ul>
</li>
<li>6.2 When writing, <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a39c613419eebb2f29590fecded7a96d0" title="The validity of the data in the application buffer.">TransferElement::_dataValidity</a> has to be copied to the target in doPreWrite() before delegating. Do <b>not</b> manually synchonise the version number. This is done by the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> base class in postWrite according to <a class="el" href="spec__transfer_element.html#transferElement_B_4_3_2">B.4.3.2</a>.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md15"></a>
(*) Comments</h3>
<ul>
<li>5. The <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor_decorator.html" title="Base class for decorators of the NDRegisterAccessor.">NDRegisterAccessorDecorator</a> base class already contains an implementation which does this in doPreXxx() and doPostXxx(). You usually call it from the Decorators implementation, as mentioned in 3.</li>
<li><a class="anchor" id="transferElement_comment_E_6_1_1"></a><a class="el" href="spec__transfer_element.html#transferElement_E_6_1_1">6.1.1</a> This is required for by the ApplicationCore::ExceptionHandlingDecorator, which suppresses exceptions, but requires the meta data to be updated without changing the data buffer. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
