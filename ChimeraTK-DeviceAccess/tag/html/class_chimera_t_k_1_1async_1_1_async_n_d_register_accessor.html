<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ChimeraTK-DeviceAccess: ChimeraTK::async::AsyncNDRegisterAccessor&lt; UserType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="ChimeraTK_Logo_whitebg.png"/></td>
  <td id="projectalign">
   <div id="projectname">ChimeraTK-DeviceAccess<span id="projectnumber">&#160;03.24.01</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ChimeraTK::async::AsyncNDRegisterAccessor&lt; UserType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html" title="The AsyncNDRegisterAccessor implements a data transport queue with typed data as continuation of the ...">AsyncNDRegisterAccessor</a> implements a data transport queue with typed data as continuation of the void queue in <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>.  
 <a href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_async_n_d_register_accessor_8h_source.html">AsyncNDRegisterAccessor.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for ChimeraTK::async::AsyncNDRegisterAccessor&lt; UserType &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor__inherit__graph.svg" width="272" height="300"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for ChimeraTK::async::AsyncNDRegisterAccessor&lt; UserType &gt;:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor__coll__graph.svg" width="100%" height="562"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af28ebaa1c725105b973868d84120abff" id="r_af28ebaa1c725105b973868d84120abff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#af28ebaa1c725105b973868d84120abff">AsyncNDRegisterAccessor</a> (boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_device_backend.html">DeviceBackend</a> &gt; backend, boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1async_1_1_async_accessor_manager.html">AsyncAccessorManager</a> &gt; manager, boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1async_1_1_domain.html">Domain</a> &gt; asyncDomain, std::string const &amp;name, size_t nChannels, size_t nElements, <a class="el" href="class_chimera_t_k_1_1_access_mode_flags.html">AccessModeFlags</a> accessModeFlags, std::string const &amp;unit=std::string(<a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab731c2eedf2851f0e7a3c03a10a7bafb">TransferElement::unitNotSet</a>), std::string const &amp;description=std::string())</td></tr>
<tr class="memdesc:af28ebaa1c725105b973868d84120abff"><td class="mdescLeft">&#160;</td><td class="mdescRight">In addition to the arguments of the <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html" title="N-dimensional register accessor.">NDRegisterAccessor</a> constructor, you need an <a class="el" href="class_chimera_t_k_1_1async_1_1_async_accessor_manager.html" title="The AsyncAccessorManager has three main functionalities:">AsyncAccessorManager</a> where you can unsubscribe.  <br /></td></tr>
<tr class="separator:af28ebaa1c725105b973868d84120abff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89314c98a6bf9b4d8317db05cefbe57c" id="r_a89314c98a6bf9b4d8317db05cefbe57c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a89314c98a6bf9b4d8317db05cefbe57c">~AsyncNDRegisterAccessor</a> () override</td></tr>
<tr class="separator:a89314c98a6bf9b4d8317db05cefbe57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6268e66923f71937cba5404509c49b35" id="r_a6268e66923f71937cba5404509c49b35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a6268e66923f71937cba5404509c49b35">sendException</a> (std::exception_ptr &amp;e)</td></tr>
<tr class="memdesc:a6268e66923f71937cba5404509c49b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes the exception to the queue.  <br /></td></tr>
<tr class="separator:a6268e66923f71937cba5404509c49b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95496b70a36d84cfbdd5b7eb844c8a30" id="r_a95496b70a36d84cfbdd5b7eb844c8a30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a95496b70a36d84cfbdd5b7eb844c8a30">sendDestructively</a> (typename <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html">NDRegisterAccessor</a>&lt; UserType &gt;::Buffer &amp;data)</td></tr>
<tr class="memdesc:a95496b70a36d84cfbdd5b7eb844c8a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can only send destructively.  <br /></td></tr>
<tr class="separator:a95496b70a36d84cfbdd5b7eb844c8a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e0bc6a6b6d8363e80f705ed0c94209" id="r_a75e0bc6a6b6d8363e80f705ed0c94209"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a75e0bc6a6b6d8363e80f705ed0c94209">doReadTransferSynchronously</a> () override</td></tr>
<tr class="memdesc:a75e0bc6a6b6d8363e80f705ed0c94209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation version of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#adaf41bf7340270e223afc8ed96f46b77" title="Read the data from the device but do not fill it into the user buffer of this TransferElement.">readTransfer()</a> for synchronous reads.  <br /></td></tr>
<tr class="separator:a75e0bc6a6b6d8363e80f705ed0c94209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2edad68b5c2dbe0444adefe618a09552" id="r_a2edad68b5c2dbe0444adefe618a09552"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a2edad68b5c2dbe0444adefe618a09552">doWriteTransfer</a> (<a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> versionNumber) override</td></tr>
<tr class="memdesc:a2edad68b5c2dbe0444adefe618a09552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation version of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab472541c0dd3171f8bf34a8c7e4600ff" title="Write the data to the device.">writeTransfer()</a>.  <br /></td></tr>
<tr class="separator:a2edad68b5c2dbe0444adefe618a09552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673615ed9c4d6b0c477fda27b37702bb" id="r_a673615ed9c4d6b0c477fda27b37702bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a673615ed9c4d6b0c477fda27b37702bb">doWriteTransferDestructively</a> (<a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> versionNumber) override</td></tr>
<tr class="memdesc:a673615ed9c4d6b0c477fda27b37702bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation version of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a04427c0c30fd937a5c85a6bb60120a9e" title="Write the data to the device.">writeTransferDestructively()</a>.  <br /></td></tr>
<tr class="separator:a673615ed9c4d6b0c477fda27b37702bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908f96e2cfd5fc8c0303973a85ae307b" id="r_a908f96e2cfd5fc8c0303973a85ae307b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a908f96e2cfd5fc8c0303973a85ae307b">doPreWrite</a> (<a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7">TransferType</a> type, <a class="el" href="class_chimera_t_k_1_1_version_number.html">VersionNumber</a> versionNumber) override</td></tr>
<tr class="memdesc:a908f96e2cfd5fc8c0303973a85ae307b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backend specific implementation of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa8dbf971f07658c489d452016244e1a5" title="Transfer the data from the user buffer into the device send buffer, while converting the data from th...">preWrite()</a>.  <br /></td></tr>
<tr class="separator:a908f96e2cfd5fc8c0303973a85ae307b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1328c33347f8b08b5196812686049e31" id="r_a1328c33347f8b08b5196812686049e31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a1328c33347f8b08b5196812686049e31">doPreRead</a> (<a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7">TransferType</a> type) override</td></tr>
<tr class="memdesc:a1328c33347f8b08b5196812686049e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backend specific implementation of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a3b9d8f76450952744a6a046de7b4eb16" title="Perform any pre-read tasks if necessary.">preRead()</a>.  <br /></td></tr>
<tr class="separator:a1328c33347f8b08b5196812686049e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d23b676c80a29fd9f3332ea211712ed" id="r_a2d23b676c80a29fd9f3332ea211712ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a2d23b676c80a29fd9f3332ea211712ed">doPostRead</a> (<a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7">TransferType</a> type, bool updateDataBuffer) override</td></tr>
<tr class="memdesc:a2d23b676c80a29fd9f3332ea211712ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backend specific implementation of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aebd5de52d8f625ea84ec0b17224c316c" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a>.  <br /></td></tr>
<tr class="separator:a2d23b676c80a29fd9f3332ea211712ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31921ffdfa12871523d3b19614a06546" id="r_a31921ffdfa12871523d3b19614a06546"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a31921ffdfa12871523d3b19614a06546">isReadOnly</a> () const override</td></tr>
<tr class="memdesc:a31921ffdfa12871523d3b19614a06546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is read only, i.e.  <br /></td></tr>
<tr class="separator:a31921ffdfa12871523d3b19614a06546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c877062829331bac56277a6c82c037d" id="r_a8c877062829331bac56277a6c82c037d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a8c877062829331bac56277a6c82c037d">isReadable</a> () const override</td></tr>
<tr class="memdesc:a8c877062829331bac56277a6c82c037d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is readable.  <br /></td></tr>
<tr class="separator:a8c877062829331bac56277a6c82c037d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c042f3ad58ab41dfdb20e06a3249b8" id="r_a97c042f3ad58ab41dfdb20e06a3249b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a97c042f3ad58ab41dfdb20e06a3249b8">isWriteable</a> () const override</td></tr>
<tr class="memdesc:a97c042f3ad58ab41dfdb20e06a3249b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if transfer element is writeable.  <br /></td></tr>
<tr class="separator:a97c042f3ad58ab41dfdb20e06a3249b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc85a0281e225e0da518463e82ff3df" id="r_a4bc85a0281e225e0da518463e82ff3df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a4bc85a0281e225e0da518463e82ff3df">setExceptionBackend</a> (boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_device_backend.html">DeviceBackend</a> &gt; exceptionBackend) override</td></tr>
<tr class="memdesc:a4bc85a0281e225e0da518463e82ff3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the backend to which the exception has to be reported.  <br /></td></tr>
<tr class="separator:a4bc85a0281e225e0da518463e82ff3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c45b29e753aa2d881bbdedd3c2a365" id="r_a76c45b29e753aa2d881bbdedd3c2a365"><td class="memItemLeft" align="right" valign="top">std::vector&lt; boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a76c45b29e753aa2d881bbdedd3c2a365">getHardwareAccessingElements</a> () override</td></tr>
<tr class="memdesc:a76c45b29e753aa2d881bbdedd3c2a365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the underlying TransferElements with actual hardware access.  <br /></td></tr>
<tr class="separator:a76c45b29e753aa2d881bbdedd3c2a365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d10f5d5480e6271fe7822ae86de4e4" id="r_a95d10f5d5480e6271fe7822ae86de4e4"><td class="memItemLeft" align="right" valign="top">std::list&lt; boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a95d10f5d5480e6271fe7822ae86de4e4">getInternalElements</a> () override</td></tr>
<tr class="memdesc:a95d10f5d5480e6271fe7822ae86de4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the full list of TransferElements internally used by this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>.  <br /></td></tr>
<tr class="separator:a95d10f5d5480e6271fe7822ae86de4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5659d15cebbbc5f1b51e982cfa6df2ef" id="r_a5659d15cebbbc5f1b51e982cfa6df2ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a5659d15cebbbc5f1b51e982cfa6df2ef">replaceTransferElement</a> (boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt;) override</td></tr>
<tr class="memdesc:a5659d15cebbbc5f1b51e982cfa6df2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for all underlying TransferElements which are considered identical (see sameRegister()) with the given <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>.  <br /></td></tr>
<tr class="separator:a5659d15cebbbc5f1b51e982cfa6df2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3a367f4fde05e1e0bcec9880360083" id="r_aba3a367f4fde05e1e0bcec9880360083"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#aba3a367f4fde05e1e0bcec9880360083">interrupt</a> () override</td></tr>
<tr class="memdesc:aba3a367f4fde05e1e0bcec9880360083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return from a blocking read immediately and throw boost::thread_interrupted.  <br /></td></tr>
<tr class="separator:aba3a367f4fde05e1e0bcec9880360083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_chimera_t_k_1_1_n_d_register_accessor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html">ChimeraTK::NDRegisterAccessor&lt; UserType &gt;</a></td></tr>
<tr class="memitem:a26aa0043b2e832914f208dbe14b9df78 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor" id="r_a26aa0043b2e832914f208dbe14b9df78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#a26aa0043b2e832914f208dbe14b9df78">NDRegisterAccessor</a> (std::string const &amp;name, <a class="el" href="class_chimera_t_k_1_1_access_mode_flags.html">AccessModeFlags</a> accessModeFlags, std::string const &amp;unit=std::string(<a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab731c2eedf2851f0e7a3c03a10a7bafb">TransferElement::unitNotSet</a>), std::string const &amp;description=std::string())</td></tr>
<tr class="memdesc:a26aa0043b2e832914f208dbe14b9df78 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html" title="N-dimensional register accessor.">NDRegisterAccessor</a> with the specified name (passed on to the transfer element).  <br /></td></tr>
<tr class="separator:a26aa0043b2e832914f208dbe14b9df78 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd318c2ad0a1690fb18a61fe8d91f487 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor" id="r_abd318c2ad0a1690fb18a61fe8d91f487"><td class="memItemLeft" align="right" valign="top">UserType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#abd318c2ad0a1690fb18a61fe8d91f487">accessData</a> (size_t sample)</td></tr>
<tr class="memdesc:abd318c2ad0a1690fb18a61fe8d91f487 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or set register accessor's buffer content (1D version).  <br /></td></tr>
<tr class="separator:abd318c2ad0a1690fb18a61fe8d91f487 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9199d4344bbabcb10b39d4337c74a7 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor" id="r_afa9199d4344bbabcb10b39d4337c74a7"><td class="memItemLeft" align="right" valign="top">const UserType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#afa9199d4344bbabcb10b39d4337c74a7">accessData</a> (size_t sample) const</td></tr>
<tr class="separator:afa9199d4344bbabcb10b39d4337c74a7 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80774502fb4e727ee81057bd2562e606 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor" id="r_a80774502fb4e727ee81057bd2562e606"><td class="memItemLeft" align="right" valign="top">UserType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#a80774502fb4e727ee81057bd2562e606">accessData</a> (unsigned int channel, unsigned int sample)</td></tr>
<tr class="memdesc:a80774502fb4e727ee81057bd2562e606 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or set register accessor's buffer content (2D version).  <br /></td></tr>
<tr class="separator:a80774502fb4e727ee81057bd2562e606 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70f4d074b5e956f211281d5682e67e2 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor" id="r_ae70f4d074b5e956f211281d5682e67e2"><td class="memItemLeft" align="right" valign="top">const UserType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#ae70f4d074b5e956f211281d5682e67e2">accessData</a> (unsigned int channel, unsigned int sample) const</td></tr>
<tr class="separator:ae70f4d074b5e956f211281d5682e67e2 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891f298ac5c1a11178e50801c4563141 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor" id="r_a891f298ac5c1a11178e50801c4563141"><td class="memItemLeft" align="right" valign="top">std::vector&lt; UserType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#a891f298ac5c1a11178e50801c4563141">accessChannel</a> (unsigned int channel)</td></tr>
<tr class="memdesc:a891f298ac5c1a11178e50801c4563141 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or set register accessor's channel vector.  <br /></td></tr>
<tr class="separator:a891f298ac5c1a11178e50801c4563141 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae073d07541742ebc7ae7268bba7f38c7 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor" id="r_ae073d07541742ebc7ae7268bba7f38c7"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; UserType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#ae073d07541742ebc7ae7268bba7f38c7">accessChannel</a> (unsigned int channel) const</td></tr>
<tr class="separator:ae073d07541742ebc7ae7268bba7f38c7 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70b98198c5a4722f50c8566bba3567c inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor" id="r_ab70b98198c5a4722f50c8566bba3567c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; UserType &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#ab70b98198c5a4722f50c8566bba3567c">accessChannels</a> ()</td></tr>
<tr class="memdesc:ab70b98198c5a4722f50c8566bba3567c inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or set register accessor's 2D channel vector.  <br /></td></tr>
<tr class="separator:ab70b98198c5a4722f50c8566bba3567c inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ba27cbbef007a28dd8d23d04b1516e inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor" id="r_a82ba27cbbef007a28dd8d23d04b1516e"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; UserType &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#a82ba27cbbef007a28dd8d23d04b1516e">accessChannels</a> () const</td></tr>
<tr class="separator:a82ba27cbbef007a28dd8d23d04b1516e inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d9ce8dc4707ad5fa6ebe0a7fc448fc inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor" id="r_a70d9ce8dc4707ad5fa6ebe0a7fc448fc"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#a70d9ce8dc4707ad5fa6ebe0a7fc448fc">getNumberOfSamples</a> () const</td></tr>
<tr class="memdesc:a70d9ce8dc4707ad5fa6ebe0a7fc448fc inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of elements per channel.  <br /></td></tr>
<tr class="separator:a70d9ce8dc4707ad5fa6ebe0a7fc448fc inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec38a08af97e339e6d0920fa9285c309 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor" id="r_aec38a08af97e339e6d0920fa9285c309"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#aec38a08af97e339e6d0920fa9285c309">getNumberOfChannels</a> () const</td></tr>
<tr class="memdesc:aec38a08af97e339e6d0920fa9285c309 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of channels.  <br /></td></tr>
<tr class="separator:aec38a08af97e339e6d0920fa9285c309 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b65fe58eaa7cc21d2ce4a42d989c1d inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor" id="r_a09b65fe58eaa7cc21d2ce4a42d989c1d"><td class="memItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#a09b65fe58eaa7cc21d2ce4a42d989c1d">getValueType</a> () const override</td></tr>
<tr class="memdesc:a09b65fe58eaa7cc21d2ce4a42d989c1d inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>std::type_info</code> for the value type of this transfer element.  <br /></td></tr>
<tr class="separator:a09b65fe58eaa7cc21d2ce4a42d989c1d inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4923b0dda3dfba2fbfd3bf6c9bad66 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor" id="r_ade4923b0dda3dfba2fbfd3bf6c9bad66"><td class="memTemplParams" colspan="2">template&lt;typename COOKED_TYPE &gt; </td></tr>
<tr class="memitem:ade4923b0dda3dfba2fbfd3bf6c9bad66 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memTemplItemLeft" align="right" valign="top">COOKED_TYPE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#ade4923b0dda3dfba2fbfd3bf6c9bad66">getAsCooked</a> (unsigned int channel, unsigned int sample) const</td></tr>
<tr class="separator:ade4923b0dda3dfba2fbfd3bf6c9bad66 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d7c22ec91a68482159315571e5fc96 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor" id="r_ae9d7c22ec91a68482159315571e5fc96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#ae9d7c22ec91a68482159315571e5fc96">DEFINE_VIRTUAL_FUNCTION_TEMPLATE_VTABLE</a> (<a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#a0d4c94f0fd0e6fb1b5049017c1d62135">getAsCooked_impl</a>, T const(unsigned int, unsigned int))</td></tr>
<tr class="separator:ae9d7c22ec91a68482159315571e5fc96 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4c94f0fd0e6fb1b5049017c1d62135 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor" id="r_a0d4c94f0fd0e6fb1b5049017c1d62135"><td class="memTemplParams" colspan="2">template&lt;typename COOKED_TYPE &gt; </td></tr>
<tr class="memitem:a0d4c94f0fd0e6fb1b5049017c1d62135 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memTemplItemLeft" align="right" valign="top">COOKED_TYPE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#a0d4c94f0fd0e6fb1b5049017c1d62135">getAsCooked_impl</a> (unsigned int channel, unsigned int sample) const</td></tr>
<tr class="separator:a0d4c94f0fd0e6fb1b5049017c1d62135 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bc09c1cd931bd3144461f4929d257e inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor" id="r_ac8bc09c1cd931bd3144461f4929d257e"><td class="memTemplParams" colspan="2">template&lt;typename COOKED_TYPE &gt; </td></tr>
<tr class="memitem:ac8bc09c1cd931bd3144461f4929d257e inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#ac8bc09c1cd931bd3144461f4929d257e">setAsCooked</a> (unsigned int channel, unsigned int sample, COOKED_TYPE value)</td></tr>
<tr class="separator:ac8bc09c1cd931bd3144461f4929d257e inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d3e9dc838577b6c8be65fd5b004633 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor" id="r_a25d3e9dc838577b6c8be65fd5b004633"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#a25d3e9dc838577b6c8be65fd5b004633">DEFINE_VIRTUAL_FUNCTION_TEMPLATE_VTABLE</a> (<a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#acced6e77f634ed68e4d66eef4cb48a41">setAsCooked_impl</a>, void(unsigned int, unsigned int, T))</td></tr>
<tr class="separator:a25d3e9dc838577b6c8be65fd5b004633 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acced6e77f634ed68e4d66eef4cb48a41 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor" id="r_acced6e77f634ed68e4d66eef4cb48a41"><td class="memTemplParams" colspan="2">template&lt;typename COOKED_TYPE &gt; </td></tr>
<tr class="memitem:acced6e77f634ed68e4d66eef4cb48a41 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#acced6e77f634ed68e4d66eef4cb48a41">setAsCooked_impl</a> (unsigned int channel, unsigned int sample, COOKED_TYPE value)</td></tr>
<tr class="separator:acced6e77f634ed68e4d66eef4cb48a41 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add81fefa0d27a7844637a7a6f4e79104 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor" id="r_add81fefa0d27a7844637a7a6f4e79104"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#add81fefa0d27a7844637a7a6f4e79104">makeCopyRegisterDecorator</a> () override</td></tr>
<tr class="memdesc:add81fefa0d27a7844637a7a6f4e79104 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="struct_chimera_t_k_1_1_copy_register_decorator.html" title="Decorator for NDRegisterAccessors which makes a copy of the data from the target accessor.">CopyRegisterDecorator</a> of the right type decorating this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>.  <br /></td></tr>
<tr class="separator:add81fefa0d27a7844637a7a6f4e79104 inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877cac1e0fb7c9c92e4e323b61fc8acb inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor" id="r_a877cac1e0fb7c9c92e4e323b61fc8acb"><td class="memItemLeft" align="right" valign="top">virtual boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html">NDRegisterAccessor</a>&lt; UserType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#a877cac1e0fb7c9c92e4e323b61fc8acb">decorateDeepInside</a> (std::function&lt; boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html">NDRegisterAccessor</a>&lt; UserType &gt; &gt;(const boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html">NDRegisterAccessor</a>&lt; UserType &gt; &gt; &amp;)&gt; factory)</td></tr>
<tr class="memdesc:a877cac1e0fb7c9c92e4e323b61fc8acb inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decorate the innermost <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> of the stack of decorators or decorator-like accessors.  <br /></td></tr>
<tr class="separator:a877cac1e0fb7c9c92e4e323b61fc8acb inherit pub_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_chimera_t_k_1_1_transfer_element"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_chimera_t_k_1_1_transfer_element')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">ChimeraTK::TransferElement</a></td></tr>
<tr class="memitem:aec2ac9c273c4a8da4b6eb24ea7e73b8a inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_aec2ac9c273c4a8da4b6eb24ea7e73b8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aec2ac9c273c4a8da4b6eb24ea7e73b8a">TransferElement</a> (std::string name, <a class="el" href="class_chimera_t_k_1_1_access_mode_flags.html">AccessModeFlags</a> accessModeFlags, std::string unit=std::string(<a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab731c2eedf2851f0e7a3c03a10a7bafb">unitNotSet</a>), std::string description=std::string())</td></tr>
<tr class="memdesc:aec2ac9c273c4a8da4b6eb24ea7e73b8a inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a transfer element with the specified name.  <br /></td></tr>
<tr class="separator:aec2ac9c273c4a8da4b6eb24ea7e73b8a inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90287ea25d81da5a74b41c04a89851c4 inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_a90287ea25d81da5a74b41c04a89851c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a90287ea25d81da5a74b41c04a89851c4">TransferElement</a> (const <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &amp;other)=delete</td></tr>
<tr class="memdesc:a90287ea25d81da5a74b41c04a89851c4 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying and moving is not allowed.  <br /></td></tr>
<tr class="separator:a90287ea25d81da5a74b41c04a89851c4 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9c4064e91701c64ececb079179dd70 inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_acf9c4064e91701c64ececb079179dd70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#acf9c4064e91701c64ececb079179dd70">TransferElement</a> (<a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &amp;&amp;other)=delete</td></tr>
<tr class="separator:acf9c4064e91701c64ececb079179dd70 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68cacd1868e265eb6d37f7f7fab5e3f inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_ae68cacd1868e265eb6d37f7f7fab5e3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ae68cacd1868e265eb6d37f7f7fab5e3f">operator=</a> (const <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &amp;other)=delete</td></tr>
<tr class="separator:ae68cacd1868e265eb6d37f7f7fab5e3f inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b8d55ee492f34ebfd16d9f3640b55e inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_ab0b8d55ee492f34ebfd16d9f3640b55e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab0b8d55ee492f34ebfd16d9f3640b55e">operator=</a> (<a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &amp;&amp;other)=delete</td></tr>
<tr class="separator:ab0b8d55ee492f34ebfd16d9f3640b55e inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b467d0d5928acde74af35e8740ec88 inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_a54b467d0d5928acde74af35e8740ec88"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a54b467d0d5928acde74af35e8740ec88">~TransferElement</a> ()=default</td></tr>
<tr class="memdesc:a54b467d0d5928acde74af35e8740ec88 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base classes need a virtual destructor.  <br /></td></tr>
<tr class="separator:a54b467d0d5928acde74af35e8740ec88 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae329d92a5809b75f8ff1cfc0a591231f inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_ae329d92a5809b75f8ff1cfc0a591231f"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ae329d92a5809b75f8ff1cfc0a591231f">getName</a> () const</td></tr>
<tr class="memdesc:ae329d92a5809b75f8ff1cfc0a591231f inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name that identifies the process variable.  <br /></td></tr>
<tr class="separator:ae329d92a5809b75f8ff1cfc0a591231f inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837191e9b1002deb6aff5fdbc14c7103 inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_a837191e9b1002deb6aff5fdbc14c7103"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a837191e9b1002deb6aff5fdbc14c7103">getUnit</a> () const</td></tr>
<tr class="memdesc:a837191e9b1002deb6aff5fdbc14c7103 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the engineering unit.  <br /></td></tr>
<tr class="separator:a837191e9b1002deb6aff5fdbc14c7103 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98c29154a5f96c13b2bd473d844809b inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_ac98c29154a5f96c13b2bd473d844809b"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ac98c29154a5f96c13b2bd473d844809b">getDescription</a> () const</td></tr>
<tr class="memdesc:ac98c29154a5f96c13b2bd473d844809b inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the description of this variable/register.  <br /></td></tr>
<tr class="separator:ac98c29154a5f96c13b2bd473d844809b inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f56d7bf9861f32b695d863a646d7dc8 inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_a8f56d7bf9861f32b695d863a646d7dc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_access_mode_flags.html">AccessModeFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a8f56d7bf9861f32b695d863a646d7dc8">getAccessModeFlags</a> () const</td></tr>
<tr class="memdesc:a8f56d7bf9861f32b695d863a646d7dc8 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="class_chimera_t_k_1_1_access_mode_flags.html" title="Set of AccessMode flags with additional functionality for an easier handling.">AccessModeFlags</a> for this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>.  <br /></td></tr>
<tr class="separator:a8f56d7bf9861f32b695d863a646d7dc8 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a63b80ca5f72d59f7d265b4242ed824 inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_a0a63b80ca5f72d59f7d265b4242ed824"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a0a63b80ca5f72d59f7d265b4242ed824">setDataValidity</a> (<a class="el" href="namespace_chimera_t_k.html#a9a7d226a45242c6825eb7a26235298df">DataValidity</a> validity=<a class="el" href="namespace_chimera_t_k.html#a9a7d226a45242c6825eb7a26235298dfa444bcb3a3fcf8389296c49467f27e1d6">DataValidity::ok</a>)</td></tr>
<tr class="memdesc:a0a63b80ca5f72d59f7d265b4242ed824 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current DataValidity for this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>.  <br /></td></tr>
<tr class="separator:a0a63b80ca5f72d59f7d265b4242ed824 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739e4e90911c3af3fa9aef9c56b08cda inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_a739e4e90911c3af3fa9aef9c56b08cda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_chimera_t_k.html#a9a7d226a45242c6825eb7a26235298df">DataValidity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a739e4e90911c3af3fa9aef9c56b08cda">dataValidity</a> () const</td></tr>
<tr class="memdesc:a739e4e90911c3af3fa9aef9c56b08cda inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return current validity of the data.  <br /></td></tr>
<tr class="separator:a739e4e90911c3af3fa9aef9c56b08cda inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21ae3855a6df0e877865702df066f5e inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_aa21ae3855a6df0e877865702df066f5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa21ae3855a6df0e877865702df066f5e">read</a> ()</td></tr>
<tr class="memdesc:aa21ae3855a6df0e877865702df066f5e inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from the device.  <br /></td></tr>
<tr class="separator:aa21ae3855a6df0e877865702df066f5e inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5dce57ab971b6fc68bc13fbd00401c inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_a0e5dce57ab971b6fc68bc13fbd00401c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a0e5dce57ab971b6fc68bc13fbd00401c">readNonBlocking</a> ()</td></tr>
<tr class="memdesc:a0e5dce57ab971b6fc68bc13fbd00401c inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next value, if available in the input buffer.  <br /></td></tr>
<tr class="separator:a0e5dce57ab971b6fc68bc13fbd00401c inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9488e50bea018025dd4b061afdf2f52b inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_a9488e50bea018025dd4b061afdf2f52b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a9488e50bea018025dd4b061afdf2f52b">readLatest</a> ()</td></tr>
<tr class="memdesc:a9488e50bea018025dd4b061afdf2f52b inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the latest value, discarding any other update since the last read if present.  <br /></td></tr>
<tr class="separator:a9488e50bea018025dd4b061afdf2f52b inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a9be48fa8f5cab72e62ce20d99004b inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_ae9a9be48fa8f5cab72e62ce20d99004b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ae9a9be48fa8f5cab72e62ce20d99004b">write</a> (<a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> versionNumber={})</td></tr>
<tr class="memdesc:ae9a9be48fa8f5cab72e62ce20d99004b inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the data to device.  <br /></td></tr>
<tr class="separator:ae9a9be48fa8f5cab72e62ce20d99004b inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e44b68014588b44adea0d17ec45599 inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_a91e44b68014588b44adea0d17ec45599"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a91e44b68014588b44adea0d17ec45599">writeDestructively</a> (<a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> versionNumber={})</td></tr>
<tr class="memdesc:a91e44b68014588b44adea0d17ec45599 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like <a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7aefb2a684e4afb7d55e6147fbe5a332ee">write()</a>, but allows the implementation to destroy the content of the user buffer in the process.  <br /></td></tr>
<tr class="separator:a91e44b68014588b44adea0d17ec45599 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69298f31fe4a42e779bca3669d06c2bd inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_a69298f31fe4a42e779bca3669d06c2bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a69298f31fe4a42e779bca3669d06c2bd">getVersionNumber</a> () const</td></tr>
<tr class="memdesc:a69298f31fe4a42e779bca3669d06c2bd inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the version number that is associated with the last transfer (i.e.  <br /></td></tr>
<tr class="separator:a69298f31fe4a42e779bca3669d06c2bd inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb356d062ef74ccc271a2f58328b295e inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_adb356d062ef74ccc271a2f58328b295e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#adb356d062ef74ccc271a2f58328b295e">setActiveException</a> (std::exception_ptr &amp;setThisException)</td></tr>
<tr class="memdesc:adb356d062ef74ccc271a2f58328b295e inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an active exception.  <br /></td></tr>
<tr class="separator:adb356d062ef74ccc271a2f58328b295e inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdbfd412e951412ea2432bc0b28fa2b inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_adcdbfd412e951412ea2432bc0b28fa2b"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_device_backend.html">DeviceBackend</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#adcdbfd412e951412ea2432bc0b28fa2b">getExceptionBackend</a> ()</td></tr>
<tr class="memdesc:adcdbfd412e951412ea2432bc0b28fa2b inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the exception backend.  <br /></td></tr>
<tr class="separator:adcdbfd412e951412ea2432bc0b28fa2b inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d771dff97bc899b78717a2488c3c9f7 inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_a0d771dff97bc899b78717a2488c3c9f7"><td class="memItemLeft" align="right" valign="top">cppext::future_queue&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a0d771dff97bc899b78717a2488c3c9f7">getReadQueue</a> ()</td></tr>
<tr class="memdesc:a0d771dff97bc899b78717a2488c3c9f7 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get a copy of the read queue.  <br /></td></tr>
<tr class="separator:a0d771dff97bc899b78717a2488c3c9f7 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf41bf7340270e223afc8ed96f46b77 inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_adaf41bf7340270e223afc8ed96f46b77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#adaf41bf7340270e223afc8ed96f46b77">readTransfer</a> ()</td></tr>
<tr class="memdesc:adaf41bf7340270e223afc8ed96f46b77 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from the device but do not fill it into the user buffer of this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>.  <br /></td></tr>
<tr class="separator:adaf41bf7340270e223afc8ed96f46b77 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53f4e5fb0474ea69ab4ae2f6348cef0 inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_ac53f4e5fb0474ea69ab4ae2f6348cef0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ac53f4e5fb0474ea69ab4ae2f6348cef0">readTransferNonBlocking</a> ()</td></tr>
<tr class="memdesc:ac53f4e5fb0474ea69ab4ae2f6348cef0 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from the device but do not fill it into the user buffer of this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>.  <br /></td></tr>
<tr class="separator:ac53f4e5fb0474ea69ab4ae2f6348cef0 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9d8f76450952744a6a046de7b4eb16 inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_a3b9d8f76450952744a6a046de7b4eb16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a3b9d8f76450952744a6a046de7b4eb16">preRead</a> (<a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7">TransferType</a> type)</td></tr>
<tr class="memdesc:a3b9d8f76450952744a6a046de7b4eb16 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any pre-read tasks if necessary.  <br /></td></tr>
<tr class="separator:a3b9d8f76450952744a6a046de7b4eb16 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd5de52d8f625ea84ec0b17224c316c inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_aebd5de52d8f625ea84ec0b17224c316c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aebd5de52d8f625ea84ec0b17224c316c">postRead</a> (<a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7">TransferType</a> type, bool updateDataBuffer)</td></tr>
<tr class="memdesc:aebd5de52d8f625ea84ec0b17224c316c inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer the data from the device receive buffer into the user buffer, while converting the data into the user data format if needed.  <br /></td></tr>
<tr class="separator:aebd5de52d8f625ea84ec0b17224c316c inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8dbf971f07658c489d452016244e1a5 inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_aa8dbf971f07658c489d452016244e1a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa8dbf971f07658c489d452016244e1a5">preWrite</a> (<a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7">TransferType</a> type, <a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> versionNumber)</td></tr>
<tr class="memdesc:aa8dbf971f07658c489d452016244e1a5 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer the data from the user buffer into the device send buffer, while converting the data from then user data format if needed.  <br /></td></tr>
<tr class="separator:aa8dbf971f07658c489d452016244e1a5 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fface1764b83bf0f8535616dc08d02 inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_a79fface1764b83bf0f8535616dc08d02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a79fface1764b83bf0f8535616dc08d02">postWrite</a> (<a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7">TransferType</a> type, <a class="el" href="class_chimera_t_k_1_1_version_number.html">VersionNumber</a> versionNumber)</td></tr>
<tr class="memdesc:a79fface1764b83bf0f8535616dc08d02 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any post-write clean-ups if necessary.  <br /></td></tr>
<tr class="separator:a79fface1764b83bf0f8535616dc08d02 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab472541c0dd3171f8bf34a8c7e4600ff inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_ab472541c0dd3171f8bf34a8c7e4600ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab472541c0dd3171f8bf34a8c7e4600ff">writeTransfer</a> (<a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> versionNumber)</td></tr>
<tr class="memdesc:ab472541c0dd3171f8bf34a8c7e4600ff inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the data to the device.  <br /></td></tr>
<tr class="separator:ab472541c0dd3171f8bf34a8c7e4600ff inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04427c0c30fd937a5c85a6bb60120a9e inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_a04427c0c30fd937a5c85a6bb60120a9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a04427c0c30fd937a5c85a6bb60120a9e">writeTransferDestructively</a> (<a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a> versionNumber)</td></tr>
<tr class="memdesc:a04427c0c30fd937a5c85a6bb60120a9e inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the data to the device.  <br /></td></tr>
<tr class="separator:a04427c0c30fd937a5c85a6bb60120a9e inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe89e1cf7c5d45797fd062b9faaea6a inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_acfe89e1cf7c5d45797fd062b9faaea6a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#acfe89e1cf7c5d45797fd062b9faaea6a">mayReplaceOther</a> (const boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> const &gt; &amp;other) const</td></tr>
<tr class="memdesc:acfe89e1cf7c5d45797fd062b9faaea6a inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> can be used in places where the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> "other" is currently used, e.g.  <br /></td></tr>
<tr class="separator:acfe89e1cf7c5d45797fd062b9faaea6a inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd0b94364db44d4c8e7021bb908d08c inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_afdd0b94364db44d4c8e7021bb908d08c"><td class="memItemLeft" align="right" valign="top">virtual boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#afdd0b94364db44d4c8e7021bb908d08c">getHighLevelImplElement</a> ()</td></tr>
<tr class="memdesc:afdd0b94364db44d4c8e7021bb908d08c inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the highest level implementation <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>.  <br /></td></tr>
<tr class="separator:afdd0b94364db44d4c8e7021bb908d08c inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d4c154c564848bfb6b08992cdf7059 inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_a70d4c154c564848bfb6b08992cdf7059"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a70d4c154c564848bfb6b08992cdf7059">setPersistentDataStorage</a> (boost::shared_ptr&lt; ChimeraTK::PersistentDataStorage &gt;)</td></tr>
<tr class="memdesc:a70d4c154c564848bfb6b08992cdf7059 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate a persistent data storage object to be updated on each write operation of this ProcessArray.  <br /></td></tr>
<tr class="separator:a70d4c154c564848bfb6b08992cdf7059 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae9512ec3459b8b320678e4af4c1334 inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_a5ae9512ec3459b8b320678e4af4c1334"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_transfer_element_i_d.html">TransferElementID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a5ae9512ec3459b8b320678e4af4c1334">getId</a> () const</td></tr>
<tr class="memdesc:a5ae9512ec3459b8b320678e4af4c1334 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain unique ID for this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>, see <a class="el" href="class_chimera_t_k_1_1_transfer_element_i_d.html" title="Simple class holding a unique ID for a TransferElement.">TransferElementID</a> for details.  <br /></td></tr>
<tr class="separator:a5ae9512ec3459b8b320678e4af4c1334 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc6f496a4965a7e81b0c36463ac9ce9 inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_a7dc6f496a4965a7e81b0c36463ac9ce9"><td class="memTemplParams" colspan="2">template&lt;typename QUEUE_TYPE &gt; </td></tr>
<tr class="memitem:a7dc6f496a4965a7e81b0c36463ac9ce9 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a7dc6f496a4965a7e81b0c36463ac9ce9">interrupt_impl</a> (QUEUE_TYPE &amp;dataTransportQueue)</td></tr>
<tr class="memdesc:a7dc6f496a4965a7e81b0c36463ac9ce9 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#af92b78c177bc98923a78a0d4faaf9e05" title="Return from a blocking read immediately and throw boost::thread_interrupted.">interrupt()</a>  <br /></td></tr>
<tr class="separator:a7dc6f496a4965a7e81b0c36463ac9ce9 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883d5da312cd47c4e0544dac4ab6b83c inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_a883d5da312cd47c4e0544dac4ab6b83c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a883d5da312cd47c4e0544dac4ab6b83c">isReadTransactionInProgress</a> () const</td></tr>
<tr class="memdesc:a883d5da312cd47c4e0544dac4ab6b83c inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a read transaction is in progress, i.e.  <br /></td></tr>
<tr class="separator:a883d5da312cd47c4e0544dac4ab6b83c inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf184b701b7e4f038d5f39ad1176a67 inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_adbf184b701b7e4f038d5f39ad1176a67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#adbf184b701b7e4f038d5f39ad1176a67">isWriteTransactionInProgress</a> () const</td></tr>
<tr class="memdesc:adbf184b701b7e4f038d5f39ad1176a67 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a write transaction is in progress, i.e.  <br /></td></tr>
<tr class="separator:adbf184b701b7e4f038d5f39ad1176a67 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2265961d8482bc4035d741dc77967d inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_a7f2265961d8482bc4035d741dc77967d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_read_any_group.html">ReadAnyGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a7f2265961d8482bc4035d741dc77967d">getReadAnyGroup</a> () const</td></tr>
<tr class="memdesc:a7f2265961d8482bc4035d741dc77967d inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the <a class="el" href="class_chimera_t_k_1_1_read_any_group.html" title="Group several registers (= TransferElement) to allow waiting for an update of any of the registers.">ReadAnyGroup</a> this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> is part of, or nullptr if not in a <a class="el" href="class_chimera_t_k_1_1_read_any_group.html" title="Group several registers (= TransferElement) to allow waiting for an update of any of the registers.">ReadAnyGroup</a>.  <br /></td></tr>
<tr class="separator:a7f2265961d8482bc4035d741dc77967d inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ca2fc42809ca55f606c626235c7b91 inherit pub_methods_class_chimera_t_k_1_1_transfer_element" id="r_ab8ca2fc42809ca55f606c626235c7b91"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab8ca2fc42809ca55f606c626235c7b91">setInReadAnyGroup</a> (<a class="el" href="class_chimera_t_k_1_1_read_any_group.html">ReadAnyGroup</a> *rag)</td></tr>
<tr class="memdesc:ab8ca2fc42809ca55f606c626235c7b91 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <a class="el" href="class_chimera_t_k_1_1_read_any_group.html" title="Group several registers (= TransferElement) to allow waiting for an update of any of the registers.">ReadAnyGroup</a> of which this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> is part of.  <br /></td></tr>
<tr class="separator:ab8ca2fc42809ca55f606c626235c7b91 inherit pub_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a25648a4a60832eee5ae680208b51d497" id="r_a25648a4a60832eee5ae680208b51d497"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_device_backend.html">DeviceBackend</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a25648a4a60832eee5ae680208b51d497">_backend</a></td></tr>
<tr class="separator:a25648a4a60832eee5ae680208b51d497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033c01e34dfb98f9dba7750807d880f4" id="r_a033c01e34dfb98f9dba7750807d880f4"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1async_1_1_async_accessor_manager.html">AsyncAccessorManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a033c01e34dfb98f9dba7750807d880f4">_accessorManager</a></td></tr>
<tr class="separator:a033c01e34dfb98f9dba7750807d880f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9dea49599566380d7a2f4a37098d744" id="r_ab9dea49599566380d7a2f4a37098d744"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1async_1_1_domain.html">Domain</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#ab9dea49599566380d7a2f4a37098d744">_asyncDomain</a></td></tr>
<tr class="separator:ab9dea49599566380d7a2f4a37098d744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9282370d4f42695e956abc633de3e8f7" id="r_a9282370d4f42695e956abc633de3e8f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_chimera_t_k_1_1_n_d_register_accessor_1_1_buffer.html">Buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a9282370d4f42695e956abc633de3e8f7">_receiveBuffer</a></td></tr>
<tr class="separator:a9282370d4f42695e956abc633de3e8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ec81eeb45b092c2ba25cefddf5bb33" id="r_ad1ec81eeb45b092c2ba25cefddf5bb33"><td class="memItemLeft" align="right" valign="top">cppext::future_queue&lt; <a class="el" href="struct_chimera_t_k_1_1_n_d_register_accessor_1_1_buffer.html">Buffer</a>, cppext::SWAP_DATA &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#ad1ec81eeb45b092c2ba25cefddf5bb33">_dataTransportQueue</a> {_queueSize}</td></tr>
<tr class="separator:ad1ec81eeb45b092c2ba25cefddf5bb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_chimera_t_k_1_1_n_d_register_accessor"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_chimera_t_k_1_1_n_d_register_accessor')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html">ChimeraTK::NDRegisterAccessor&lt; UserType &gt;</a></td></tr>
<tr class="memitem:ab3e9f790076370e901fd8c6079ed6770 inherit pro_attribs_class_chimera_t_k_1_1_n_d_register_accessor" id="r_ab3e9f790076370e901fd8c6079ed6770"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; UserType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#ab3e9f790076370e901fd8c6079ed6770">buffer_2D</a></td></tr>
<tr class="memdesc:ab3e9f790076370e901fd8c6079ed6770 inherit pro_attribs_class_chimera_t_k_1_1_n_d_register_accessor"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_chimera_t_k_1_1_n_d_register_accessor_1_1_buffer.html" title="Data type to create individual buffers.">Buffer</a> of converted data elements.  <br /></td></tr>
<tr class="separator:ab3e9f790076370e901fd8c6079ed6770 inherit pro_attribs_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_chimera_t_k_1_1_transfer_element"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_chimera_t_k_1_1_transfer_element')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">ChimeraTK::TransferElement</a></td></tr>
<tr class="memitem:aee95f5dfccb41075150d0a7d00f5e494 inherit pro_attribs_class_chimera_t_k_1_1_transfer_element" id="r_aee95f5dfccb41075150d0a7d00f5e494"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_device_backend.html">DeviceBackend</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aee95f5dfccb41075150d0a7d00f5e494">_exceptionBackend</a></td></tr>
<tr class="memdesc:aee95f5dfccb41075150d0a7d00f5e494 inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">The backend to which the runtime_errors are reported via <a class="el" href="class_chimera_t_k_1_1_device_backend.html#ab3d996241286ea3b233e3ea59824b670" title="Set the backend into an exception state.">DeviceBackend::setException()</a>.  <br /></td></tr>
<tr class="separator:aee95f5dfccb41075150d0a7d00f5e494 inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13235d15a13bfc43764e464f1b6fe50d inherit pro_attribs_class_chimera_t_k_1_1_transfer_element" id="r_a13235d15a13bfc43764e464f1b6fe50d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a13235d15a13bfc43764e464f1b6fe50d">_name</a></td></tr>
<tr class="memdesc:a13235d15a13bfc43764e464f1b6fe50d inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier uniquely identifying the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>.  <br /></td></tr>
<tr class="separator:a13235d15a13bfc43764e464f1b6fe50d inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fffb069722f43530cecbcaa40b7c670 inherit pro_attribs_class_chimera_t_k_1_1_transfer_element" id="r_a8fffb069722f43530cecbcaa40b7c670"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a8fffb069722f43530cecbcaa40b7c670">_unit</a></td></tr>
<tr class="memdesc:a8fffb069722f43530cecbcaa40b7c670 inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Engineering unit.  <br /></td></tr>
<tr class="separator:a8fffb069722f43530cecbcaa40b7c670 inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f52cb447c14f6e01f716c3d040238e inherit pro_attribs_class_chimera_t_k_1_1_transfer_element" id="r_a66f52cb447c14f6e01f716c3d040238e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a66f52cb447c14f6e01f716c3d040238e">_description</a></td></tr>
<tr class="memdesc:a66f52cb447c14f6e01f716c3d040238e inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of this variable/register.  <br /></td></tr>
<tr class="separator:a66f52cb447c14f6e01f716c3d040238e inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a42fc668a7d9243dd024729737f35a7 inherit pro_attribs_class_chimera_t_k_1_1_transfer_element" id="r_a1a42fc668a7d9243dd024729737f35a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_transfer_element_i_d.html">TransferElementID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a1a42fc668a7d9243dd024729737f35a7">_id</a></td></tr>
<tr class="memdesc:a1a42fc668a7d9243dd024729737f35a7 inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ID of this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>.  <br /></td></tr>
<tr class="separator:a1a42fc668a7d9243dd024729737f35a7 inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa340a8029a130735f2412c1a60290d6 inherit pro_attribs_class_chimera_t_k_1_1_transfer_element" id="r_aaa340a8029a130735f2412c1a60290d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aaa340a8029a130735f2412c1a60290d6">_isInTransferGroup</a> {false}</td></tr>
<tr class="memdesc:aaa340a8029a130735f2412c1a60290d6 inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag whether this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> has been added to a <a class="el" href="class_chimera_t_k_1_1_transfer_group.html" title="Group multiple data accessors to efficiently trigger data transfers on the whole group.">TransferGroup</a> or not.  <br /></td></tr>
<tr class="separator:aaa340a8029a130735f2412c1a60290d6 inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd66d3892c6af0934288f4fc3b06cac inherit pro_attribs_class_chimera_t_k_1_1_transfer_element" id="r_a1dd66d3892c6af0934288f4fc3b06cac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_read_any_group.html">ReadAnyGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a1dd66d3892c6af0934288f4fc3b06cac">_inReadAnyGroup</a> {nullptr}</td></tr>
<tr class="memdesc:a1dd66d3892c6af0934288f4fc3b06cac inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_chimera_t_k_1_1_read_any_group.html" title="Group several registers (= TransferElement) to allow waiting for an update of any of the registers.">ReadAnyGroup</a> this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> has been added to, nullptr if not in a <a class="el" href="class_chimera_t_k_1_1_read_any_group.html" title="Group several registers (= TransferElement) to allow waiting for an update of any of the registers.">ReadAnyGroup</a>.  <br /></td></tr>
<tr class="separator:a1dd66d3892c6af0934288f4fc3b06cac inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e5595381e62b6f86d524761c3be44b inherit pro_attribs_class_chimera_t_k_1_1_transfer_element" id="r_a35e5595381e62b6f86d524761c3be44b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_access_mode_flags.html">AccessModeFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a35e5595381e62b6f86d524761c3be44b">_accessModeFlags</a></td></tr>
<tr class="memdesc:a35e5595381e62b6f86d524761c3be44b inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">The access mode flags for this transfer element.  <br /></td></tr>
<tr class="separator:a35e5595381e62b6f86d524761c3be44b inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab824c85c63163e76ccda588ef4768f68 inherit pro_attribs_class_chimera_t_k_1_1_transfer_element" id="r_ab824c85c63163e76ccda588ef4768f68"><td class="memItemLeft" align="right" valign="top">cppext::future_queue&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab824c85c63163e76ccda588ef4768f68">_readQueue</a></td></tr>
<tr class="memdesc:ab824c85c63163e76ccda588ef4768f68 inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">The queue for asynchronous read transfers.  <br /></td></tr>
<tr class="separator:ab824c85c63163e76ccda588ef4768f68 inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad34f0c2eaec6be3dc385f1c4acef46 inherit pro_attribs_class_chimera_t_k_1_1_transfer_element" id="r_a9ad34f0c2eaec6be3dc385f1c4acef46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chimera_t_k_1_1_version_number.html">VersionNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a9ad34f0c2eaec6be3dc385f1c4acef46">_versionNumber</a> {nullptr}</td></tr>
<tr class="memdesc:a9ad34f0c2eaec6be3dc385f1c4acef46 inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">The version number of the last successful transfer.  <br /></td></tr>
<tr class="separator:a9ad34f0c2eaec6be3dc385f1c4acef46 inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c613419eebb2f29590fecded7a96d0 inherit pro_attribs_class_chimera_t_k_1_1_transfer_element" id="r_a39c613419eebb2f29590fecded7a96d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_chimera_t_k.html#a9a7d226a45242c6825eb7a26235298df">DataValidity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a39c613419eebb2f29590fecded7a96d0">_dataValidity</a> {<a class="el" href="namespace_chimera_t_k.html#a9a7d226a45242c6825eb7a26235298dfa444bcb3a3fcf8389296c49467f27e1d6">DataValidity::ok</a>}</td></tr>
<tr class="memdesc:a39c613419eebb2f29590fecded7a96d0 inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">The validity of the data in the application buffer.  <br /></td></tr>
<tr class="separator:a39c613419eebb2f29590fecded7a96d0 inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779b431f4a3452f6e41bf3da48fb5bef inherit pro_attribs_class_chimera_t_k_1_1_transfer_element" id="r_a779b431f4a3452f6e41bf3da48fb5bef"><td class="memItemLeft" align="right" valign="top">std::exception_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a779b431f4a3452f6e41bf3da48fb5bef">_activeException</a> {nullptr}</td></tr>
<tr class="memdesc:a779b431f4a3452f6e41bf3da48fb5bef inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception to be rethrown in postXXX() in case hasSeenException == true Can be set via <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#adb356d062ef74ccc271a2f58328b295e" title="Set an active exception.">setActiveException()</a>.  <br /></td></tr>
<tr class="separator:a779b431f4a3452f6e41bf3da48fb5bef inherit pro_attribs_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_class_chimera_t_k_1_1_transfer_element"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_chimera_t_k_1_1_transfer_element')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">ChimeraTK::TransferElement</a></td></tr>
<tr class="memitem:a3520f1783f455f328d06205ec1462a94 inherit pub_types_class_chimera_t_k_1_1_transfer_element" id="r_a3520f1783f455f328d06205ec1462a94"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a3520f1783f455f328d06205ec1462a94">SharedPtr</a> = boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt;</td></tr>
<tr class="memdesc:a3520f1783f455f328d06205ec1462a94 inherit pub_types_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typedef for more compact syntax.  <br /></td></tr>
<tr class="separator:a3520f1783f455f328d06205ec1462a94 inherit pub_types_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_class_chimera_t_k_1_1_transfer_element"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_class_chimera_t_k_1_1_transfer_element')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">ChimeraTK::TransferElement</a></td></tr>
<tr class="memitem:ab731c2eedf2851f0e7a3c03a10a7bafb inherit pub_static_attribs_class_chimera_t_k_1_1_transfer_element" id="r_ab731c2eedf2851f0e7a3c03a10a7bafb"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab731c2eedf2851f0e7a3c03a10a7bafb">unitNotSet</a> [] = &quot;n./a.&quot;</td></tr>
<tr class="memdesc:ab731c2eedf2851f0e7a3c03a10a7bafb inherit pub_static_attribs_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant string to be used as a unit when the unit is not provided or known.  <br /></td></tr>
<tr class="separator:ab731c2eedf2851f0e7a3c03a10a7bafb inherit pub_static_attribs_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_chimera_t_k_1_1_n_d_register_accessor')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html">ChimeraTK::NDRegisterAccessor&lt; UserType &gt;</a></td></tr>
<tr class="memitem:ac2b41bf5123ae657a3d10283ff484a9d inherit pro_methods_class_chimera_t_k_1_1_n_d_register_accessor" id="r_ac2b41bf5123ae657a3d10283ff484a9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#ac2b41bf5123ae657a3d10283ff484a9d">DEFINE_VIRTUAL_FUNCTION_TEMPLATE_VTABLE_FILLER</a> (<a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html">NDRegisterAccessor</a>&lt; UserType &gt;, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#a0d4c94f0fd0e6fb1b5049017c1d62135">getAsCooked_impl</a>, 2)</td></tr>
<tr class="separator:ac2b41bf5123ae657a3d10283ff484a9d inherit pro_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abbf917c5276bc3f776088e0d97366a inherit pro_methods_class_chimera_t_k_1_1_n_d_register_accessor" id="r_a7abbf917c5276bc3f776088e0d97366a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#a7abbf917c5276bc3f776088e0d97366a">DEFINE_VIRTUAL_FUNCTION_TEMPLATE_VTABLE_FILLER</a> (<a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html">NDRegisterAccessor</a>&lt; UserType &gt;, <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html#acced6e77f634ed68e4d66eef4cb48a41">setAsCooked_impl</a>, 3)</td></tr>
<tr class="separator:a7abbf917c5276bc3f776088e0d97366a inherit pro_methods_class_chimera_t_k_1_1_n_d_register_accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_chimera_t_k_1_1_transfer_element"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_chimera_t_k_1_1_transfer_element')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">ChimeraTK::TransferElement</a></td></tr>
<tr class="memitem:a7c0a6bc5c1779ce47afe7871573ef2a1 inherit pro_methods_class_chimera_t_k_1_1_transfer_element" id="r_a7c0a6bc5c1779ce47afe7871573ef2a1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a7c0a6bc5c1779ce47afe7871573ef2a1">doPostWrite</a> (<a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7">TransferType</a>, <a class="el" href="class_chimera_t_k_1_1_version_number.html">VersionNumber</a>)</td></tr>
<tr class="memdesc:a7c0a6bc5c1779ce47afe7871573ef2a1 inherit pro_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backend specific implementation of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a79fface1764b83bf0f8535616dc08d02" title="Perform any post-write clean-ups if necessary.">postWrite()</a>.  <br /></td></tr>
<tr class="separator:a7c0a6bc5c1779ce47afe7871573ef2a1 inherit pro_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833c655eca8c53f5ff0d97c3d81c1376 inherit pro_methods_class_chimera_t_k_1_1_transfer_element" id="r_a833c655eca8c53f5ff0d97c3d81c1376"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a833c655eca8c53f5ff0d97c3d81c1376">makeUniqueId</a> ()</td></tr>
<tr class="memdesc:a833c655eca8c53f5ff0d97c3d81c1376 inherit pro_methods_class_chimera_t_k_1_1_transfer_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow generating a unique ID from derived classes.  <br /></td></tr>
<tr class="separator:a833c655eca8c53f5ff0d97c3d81c1376 inherit pro_methods_class_chimera_t_k_1_1_transfer_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename UserType&gt;<br />
class ChimeraTK::async::AsyncNDRegisterAccessor&lt; UserType &gt;</div><p>The <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html" title="The AsyncNDRegisterAccessor implements a data transport queue with typed data as continuation of the ...">AsyncNDRegisterAccessor</a> implements a data transport queue with typed data as continuation of the void queue in <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>. </p>
<p>This allows to receive the content of the buffer_2D, the version number and the data validity flag. The implementation is complete. The interrupt handling thread in the backend implementation can write to the queues through the member functions. </p>

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8h_source.html#l00023">23</a> of file <a class="el" href="_async_n_d_register_accessor_8h_source.html">AsyncNDRegisterAccessor.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af28ebaa1c725105b973868d84120abff" name="af28ebaa1c725105b973868d84120abff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af28ebaa1c725105b973868d84120abff">&#9670;&#160;</a></span>AsyncNDRegisterAccessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">ChimeraTK::async::AsyncNDRegisterAccessor</a>&lt; UserType &gt;::AsyncNDRegisterAccessor </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_device_backend.html">DeviceBackend</a> &gt;&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1async_1_1_async_accessor_manager.html">AsyncAccessorManager</a> &gt;&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1async_1_1_domain.html">Domain</a> &gt;&#160;</td>
          <td class="paramname"><em>asyncDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_chimera_t_k_1_1_access_mode_flags.html">AccessModeFlags</a>&#160;</td>
          <td class="paramname"><em>accessModeFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>unit</em> = <code>std::string(<a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab731c2eedf2851f0e7a3c03a10a7bafb">TransferElement::unitNotSet</a>)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>description</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In addition to the arguments of the <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html" title="N-dimensional register accessor.">NDRegisterAccessor</a> constructor, you need an <a class="el" href="class_chimera_t_k_1_1async_1_1_async_accessor_manager.html" title="The AsyncAccessorManager has three main functionalities:">AsyncAccessorManager</a> where you can unsubscribe. </p>
<p>As the <a class="el" href="class_chimera_t_k_1_1async_1_1_async_accessor_manager.html" title="The AsyncAccessorManager has three main functionalities:">AsyncAccessorManager</a> is the factory for <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html" title="The AsyncNDRegisterAccessor implements a data transport queue with typed data as continuation of the ...">AsyncNDRegisterAccessor</a>, this is only an implementation detail. </p>

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8cc_source.html#l00016">16</a> of file <a class="el" href="_async_n_d_register_accessor_8cc_source.html">AsyncNDRegisterAccessor.cc</a>.</p>

</div>
</div>
<a id="a89314c98a6bf9b4d8317db05cefbe57c" name="a89314c98a6bf9b4d8317db05cefbe57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89314c98a6bf9b4d8317db05cefbe57c">&#9670;&#160;</a></span>~AsyncNDRegisterAccessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">ChimeraTK::async::AsyncNDRegisterAccessor</a>&lt; UserType &gt;::~<a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">AsyncNDRegisterAccessor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8cc_source.html#l00011">11</a> of file <a class="el" href="_async_n_d_register_accessor_8cc_source.html">AsyncNDRegisterAccessor.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2d23b676c80a29fd9f3332ea211712ed" name="a2d23b676c80a29fd9f3332ea211712ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d23b676c80a29fd9f3332ea211712ed">&#9670;&#160;</a></span>doPostRead()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">ChimeraTK::async::AsyncNDRegisterAccessor</a>&lt; UserType &gt;::doPostRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7">TransferType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Backend specific implementation of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aebd5de52d8f625ea84ec0b17224c316c" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a>. </p>
<p><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aebd5de52d8f625ea84ec0b17224c316c" title="Transfer the data from the device receive buffer into the user buffer, while converting the data into...">postRead()</a> will call this function, but it will make sure that it gets called only once per transfer.</p>
<p>No actual communication may be done. Hence, no <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">runtime_error</a> exception may be thrown by this function. Also it must be acceptable to call this function while the device is closed or not functional (see isFunctional()) and no exception is thrown.</p>
<p>Notes for backend implementations:</p><ul>
<li>If the flag updateDataBuffer is false, the data buffer must stay unaltered. Full implementations (backends) must also leave the meta data (version number and data validity) unchanged. Decorators are allowed to change the meta data (for instance set the <a class="el" href="namespace_chimera_t_k.html#a9a7d226a45242c6825eb7a26235298dfac4ef1e7ec5c765839c8acdd9968542b2" title="The data is considered valid.">DataValidity::faulty</a>). </li>
</ul>

<p>Reimplemented from <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a650d977e62e54324d6fc1b281feb0ba7">ChimeraTK::TransferElement</a>.</p>

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8cc_source.html#l00047">47</a> of file <a class="el" href="_async_n_d_register_accessor_8cc_source.html">AsyncNDRegisterAccessor.cc</a>.</p>

</div>
</div>
<a id="a1328c33347f8b08b5196812686049e31" name="a1328c33347f8b08b5196812686049e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1328c33347f8b08b5196812686049e31">&#9670;&#160;</a></span>doPreRead()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">ChimeraTK::async::AsyncNDRegisterAccessor</a>&lt; UserType &gt;::doPreRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7">TransferType</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Backend specific implementation of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a3b9d8f76450952744a6a046de7b4eb16" title="Perform any pre-read tasks if necessary.">preRead()</a>. </p>
<p><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a3b9d8f76450952744a6a046de7b4eb16" title="Perform any pre-read tasks if necessary.">preRead()</a> will call this function, but it will make sure that it gets called only once per transfer.</p>
<p>No actual communication may be done. Hence, no <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">runtime_error</a> exception may be thrown by this function. Also it must be acceptable to call this function while the device is closed or not functional (see isFunctional()) and no exception is thrown. </p>

<p>Reimplemented from <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a60d3b43f03bed1cf27c57fd7e0c76127">ChimeraTK::TransferElement</a>.</p>

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8h_source.html#l00071">71</a> of file <a class="el" href="_async_n_d_register_accessor_8h_source.html">AsyncNDRegisterAccessor.h</a>.</p>

</div>
</div>
<a id="a908f96e2cfd5fc8c0303973a85ae307b" name="a908f96e2cfd5fc8c0303973a85ae307b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908f96e2cfd5fc8c0303973a85ae307b">&#9670;&#160;</a></span>doPreWrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">ChimeraTK::async::AsyncNDRegisterAccessor</a>&lt; UserType &gt;::doPreWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_chimera_t_k.html#aefbbe1fd9e4eefc7aa088b1242274ee7">TransferType</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_chimera_t_k_1_1_version_number.html">VersionNumber</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Backend specific implementation of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa8dbf971f07658c489d452016244e1a5" title="Transfer the data from the user buffer into the device send buffer, while converting the data from th...">preWrite()</a>. </p>
<p><a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa8dbf971f07658c489d452016244e1a5" title="Transfer the data from the user buffer into the device send buffer, while converting the data from th...">preWrite()</a> will call this function, but it will make sure that it gets called only once per transfer.</p>
<p>No actual communication may be done. Hence, no <a class="el" href="class_chimera_t_k_1_1runtime__error.html" title="Exception thrown when a runtime error has occured.">runtime_error</a> exception may be thrown by this function. Also it must be acceptable to call this function while the device is closed or not functional (see isFunctional()) and no exception is thrown. </p>

<p>Reimplemented from <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa6ae99999ae6548d80d9f744e93f03bd">ChimeraTK::TransferElement</a>.</p>

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8h_source.html#l00067">67</a> of file <a class="el" href="_async_n_d_register_accessor_8h_source.html">AsyncNDRegisterAccessor.h</a>.</p>

</div>
</div>
<a id="a75e0bc6a6b6d8363e80f705ed0c94209" name="a75e0bc6a6b6d8363e80f705ed0c94209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e0bc6a6b6d8363e80f705ed0c94209">&#9670;&#160;</a></span>doReadTransferSynchronously()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">ChimeraTK::async::AsyncNDRegisterAccessor</a>&lt; UserType &gt;::doReadTransferSynchronously </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation version of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#adaf41bf7340270e223afc8ed96f46b77" title="Read the data from the device but do not fill it into the user buffer of this TransferElement.">readTransfer()</a> for synchronous reads. </p>
<p>This function must be implemented by the backend. For the functional description read the documentation of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#adaf41bf7340270e223afc8ed96f46b77" title="Read the data from the device but do not fill it into the user buffer of this TransferElement.">readTransfer()</a>.</p>
<p>Implementation notes:</p><ul>
<li>This function must return within ~1 second after both boost::thread::interrupt() (on the thread calling this function) and <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#af92b78c177bc98923a78a0d4faaf9e05" title="Return from a blocking read immediately and throw boost::thread_interrupted.">TransferElement::interrupt()</a> have been called (reliable termination requires both calls; implementation needs to react to one of the call only).</li>
<li>Decorators must delegate the call to <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#adaf41bf7340270e223afc8ed96f46b77" title="Read the data from the device but do not fill it into the user buffer of this TransferElement.">readTransfer()</a> of the decorated target.</li>
<li>Delegations within the same object should go to the "do" version, e.g. to BaseClass::doReadTransferSynchronously() </li>
</ul>

<p>Implements <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a948f1bec4d00fce4ef5d5ea8fc35f8d5">ChimeraTK::TransferElement</a>.</p>

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8h_source.html#l00052">52</a> of file <a class="el" href="_async_n_d_register_accessor_8h_source.html">AsyncNDRegisterAccessor.h</a>.</p>

</div>
</div>
<a id="a2edad68b5c2dbe0444adefe618a09552" name="a2edad68b5c2dbe0444adefe618a09552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2edad68b5c2dbe0444adefe618a09552">&#9670;&#160;</a></span>doWriteTransfer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">ChimeraTK::async::AsyncNDRegisterAccessor</a>&lt; UserType &gt;::doWriteTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a>&#160;</td>
          <td class="paramname"><em>versionNumber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation version of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab472541c0dd3171f8bf34a8c7e4600ff" title="Write the data to the device.">writeTransfer()</a>. </p>
<p>This function must be implemented by the backend. For the functional description read the documentation of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab472541c0dd3171f8bf34a8c7e4600ff" title="Write the data to the device.">writeTransfer()</a>.</p>
<p>Implementation notes:</p><ul>
<li>Decorators must delegate the call to <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab472541c0dd3171f8bf34a8c7e4600ff" title="Write the data to the device.">writeTransfer()</a> of the decorated target. </li>
</ul>

<p>Implements <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aae3498d969f1eff074cb2a431a3ad687">ChimeraTK::TransferElement</a>.</p>

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8h_source.html#l00057">57</a> of file <a class="el" href="_async_n_d_register_accessor_8h_source.html">AsyncNDRegisterAccessor.h</a>.</p>

</div>
</div>
<a id="a673615ed9c4d6b0c477fda27b37702bb" name="a673615ed9c4d6b0c477fda27b37702bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673615ed9c4d6b0c477fda27b37702bb">&#9670;&#160;</a></span>doWriteTransferDestructively()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">ChimeraTK::async::AsyncNDRegisterAccessor</a>&lt; UserType &gt;::doWriteTransferDestructively </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_chimera_t_k_1_1_version_number.html">ChimeraTK::VersionNumber</a>&#160;</td>
          <td class="paramname"><em>versionNumber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation version of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a04427c0c30fd937a5c85a6bb60120a9e" title="Write the data to the device.">writeTransferDestructively()</a>. </p>
<p>This function must be implemented by the backend. For the functional description read the documentation of <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab472541c0dd3171f8bf34a8c7e4600ff" title="Write the data to the device.">writeTransfer()</a>.</p>
<p>Implementation notes:</p><ul>
<li>Decorators must delegate the call to <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ab472541c0dd3171f8bf34a8c7e4600ff" title="Write the data to the device.">writeTransfer()</a> of the decorated target.</li>
<li>Delegations within the same object should go to the "do" version, e.g. to this-&gt;<a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a2edad68b5c2dbe0444adefe618a09552" title="Implementation version of writeTransfer().">doWriteTransfer()</a></li>
<li>The implementation may destroy the content of the user buffer in the process. This is an optional optimisation, hence there is a default implementation which just calls the normal <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a2edad68b5c2dbe0444adefe618a09552" title="Implementation version of writeTransfer().">doWriteTransfer()</a>. </li>
</ul>

<p>Reimplemented from <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a98f467545b6682f18cec6b113c5898cc">ChimeraTK::TransferElement</a>.</p>

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8h_source.html#l00062">62</a> of file <a class="el" href="_async_n_d_register_accessor_8h_source.html">AsyncNDRegisterAccessor.h</a>.</p>

</div>
</div>
<a id="a76c45b29e753aa2d881bbdedd3c2a365" name="a76c45b29e753aa2d881bbdedd3c2a365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c45b29e753aa2d881bbdedd3c2a365">&#9670;&#160;</a></span>getHardwareAccessingElements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt; &gt; <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">ChimeraTK::async::AsyncNDRegisterAccessor</a>&lt; UserType &gt;::getHardwareAccessingElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the underlying TransferElements with actual hardware access. </p>
<p>If this transfer element is directly reading from / writing to the hardware, it will return a list just containing a shared pointer of itself.</p>
<p>Note: Avoid using this in application code, since it will break the abstraction! </p>

<p>Implements <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#ac69c35862286b6a67cd5a11536c8a408">ChimeraTK::TransferElement</a>.</p>

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8h_source.html#l00090">90</a> of file <a class="el" href="_async_n_d_register_accessor_8h_source.html">AsyncNDRegisterAccessor.h</a>.</p>

</div>
</div>
<a id="a95d10f5d5480e6271fe7822ae86de4e4" name="a95d10f5d5480e6271fe7822ae86de4e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d10f5d5480e6271fe7822ae86de4e4">&#9670;&#160;</a></span>getInternalElements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt; &gt; <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">ChimeraTK::async::AsyncNDRegisterAccessor</a>&lt; UserType &gt;::getInternalElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the full list of TransferElements internally used by this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>. </p>
<p>The function is recursive, i.e. elements used by the elements returned by this function are also added to the list. It is guaranteed that the directly used elements are first in the list and the result from recursion is appended to the list.</p>
<p>Example: A decorator would return a list with its target <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> followed by the result of <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a95d10f5d5480e6271fe7822ae86de4e4" title="Obtain the full list of TransferElements internally used by this TransferElement.">getInternalElements()</a> called on its target <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>.</p>
<p>If this <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> is not using any other element, it should return an empty vector. Thus those elements which return a list just containing themselves in <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a76c45b29e753aa2d881bbdedd3c2a365" title="Obtain the underlying TransferElements with actual hardware access.">getHardwareAccessingElements()</a> will return an empty list here in <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a95d10f5d5480e6271fe7822ae86de4e4" title="Obtain the full list of TransferElements internally used by this TransferElement.">getInternalElements()</a>.</p>
<p>Note: Avoid using this in application code, since it will break the abstraction! </p>

<p>Implements <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a4a511b856a6d966647f3ed38feca55cc">ChimeraTK::TransferElement</a>.</p>

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8h_source.html#l00093">93</a> of file <a class="el" href="_async_n_d_register_accessor_8h_source.html">AsyncNDRegisterAccessor.h</a>.</p>

</div>
</div>
<a id="aba3a367f4fde05e1e0bcec9880360083" name="aba3a367f4fde05e1e0bcec9880360083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3a367f4fde05e1e0bcec9880360083">&#9670;&#160;</a></span>interrupt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">ChimeraTK::async::AsyncNDRegisterAccessor</a>&lt; UserType &gt;::interrupt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return from a blocking read immediately and throw boost::thread_interrupted. </p>
<p>This function can be used to shutdown a thread waiting on data to arrive, which might never happen because the sending part of the application is already shut down, or there is no new data at the moment.</p>
<p>Note that this function does not stop the sending thread. It just places a boost::thread_interrupted exception on the _TransferElement::_readQueue, so a waiting <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#aa21ae3855a6df0e877865702df066f5e" title="Read the data from the device.">read()</a> has something to receive and returns. If regular data is put into the queue just before the exception, this is received first. Hence it is not guaranteed that the read call that is supposed to be interrupted will actually throw an exception. But it is guaranteed that it returns immediately. Also it is guaranteed that eventually the boost::thread_interrupted exception will be received, unless more values are written to the queue and the exception is overwritten.</p>
<p>See <a class="el" href="spec__transfer_element.html#transferElement_B_8_6">Technical specification: TransferElement B.8.6</a></p>
<p>Implementation notice: This default implementation is always doing nothing. Each <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> implementation that supports <a class="el" href="namespace_chimera_t_k.html#ab626f75a2569cda2f3b0869d754aee11aa32635b4f0dfdd132457f6a499d6f031" title="Make any read blocking until new data has arrived since the last read.">AccessMode::wait_for_new_data</a> (or may need to interrupt synchronous read calls) has to override it like this (unless the <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a> has special requirements): void <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#aba3a367f4fde05e1e0bcec9880360083" title="Return from a blocking read immediately and throw boost::thread_interrupted.">interrupt()</a> override { this-&gt;interrupt_impl(this-&gt;_myDataTransportQueue); } </p>

<p>Reimplemented from <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#af92b78c177bc98923a78a0d4faaf9e05">ChimeraTK::TransferElement</a>.</p>

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8h_source.html#l00097">97</a> of file <a class="el" href="_async_n_d_register_accessor_8h_source.html">AsyncNDRegisterAccessor.h</a>.</p>

</div>
</div>
<a id="a8c877062829331bac56277a6c82c037d" name="a8c877062829331bac56277a6c82c037d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c877062829331bac56277a6c82c037d">&#9670;&#160;</a></span>isReadable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">ChimeraTK::async::AsyncNDRegisterAccessor</a>&lt; UserType &gt;::isReadable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if transfer element is readable. </p>
<p>It throws an exception if you try to read and <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a8c877062829331bac56277a6c82c037d" title="Check if transfer element is readable.">isReadable()</a> is not true. </p>

<p>Implements <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a9045dd72e498456e821811ef551b9946">ChimeraTK::TransferElement</a>.</p>

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8h_source.html#l00083">83</a> of file <a class="el" href="_async_n_d_register_accessor_8h_source.html">AsyncNDRegisterAccessor.h</a>.</p>

</div>
</div>
<a id="a31921ffdfa12871523d3b19614a06546" name="a31921ffdfa12871523d3b19614a06546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31921ffdfa12871523d3b19614a06546">&#9670;&#160;</a></span>isReadOnly()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">ChimeraTK::async::AsyncNDRegisterAccessor</a>&lt; UserType &gt;::isReadOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if transfer element is read only, i.e. </p>
<p>it is readable but not writeable. </p>

<p>Implements <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#afb77cfdfd4be6fbf76f16d9ada9d2134">ChimeraTK::TransferElement</a>.</p>

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8h_source.html#l00080">80</a> of file <a class="el" href="_async_n_d_register_accessor_8h_source.html">AsyncNDRegisterAccessor.h</a>.</p>

</div>
</div>
<a id="a97c042f3ad58ab41dfdb20e06a3249b8" name="a97c042f3ad58ab41dfdb20e06a3249b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c042f3ad58ab41dfdb20e06a3249b8">&#9670;&#160;</a></span>isWriteable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">ChimeraTK::async::AsyncNDRegisterAccessor</a>&lt; UserType &gt;::isWriteable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if transfer element is writeable. </p>
<p>It throws an exception if you try to write and <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html#a97c042f3ad58ab41dfdb20e06a3249b8" title="Check if transfer element is writeable.">isWriteable()</a> is not true. </p>

<p>Implements <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#accfe1aea9752501fd25381d3e3bdbee8">ChimeraTK::TransferElement</a>.</p>

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8h_source.html#l00084">84</a> of file <a class="el" href="_async_n_d_register_accessor_8h_source.html">AsyncNDRegisterAccessor.h</a>.</p>

</div>
</div>
<a id="a5659d15cebbbc5f1b51e982cfa6df2ef" name="a5659d15cebbbc5f1b51e982cfa6df2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5659d15cebbbc5f1b51e982cfa6df2ef">&#9670;&#160;</a></span>replaceTransferElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">ChimeraTK::async::AsyncNDRegisterAccessor</a>&lt; UserType &gt;::replaceTransferElement </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_transfer_element.html">TransferElement</a> &gt;&#160;</td>
          <td class="paramname"><em>newElement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for all underlying TransferElements which are considered identical (see sameRegister()) with the given <a class="el" href="class_chimera_t_k_1_1_transfer_element.html" title="Base class for register accessors which can be part of a TransferGroup.">TransferElement</a>. </p>
<p>These TransferElements are then replaced with the new element. If no underlying element matches the new element, this function has no effect. </p>

<p>Reimplemented from <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a791a4902b649e859fbadea20cc90ede2">ChimeraTK::TransferElement</a>.</p>

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8h_source.html#l00095">95</a> of file <a class="el" href="_async_n_d_register_accessor_8h_source.html">AsyncNDRegisterAccessor.h</a>.</p>

</div>
</div>
<a id="a95496b70a36d84cfbdd5b7eb844c8a30" name="a95496b70a36d84cfbdd5b7eb844c8a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95496b70a36d84cfbdd5b7eb844c8a30">&#9670;&#160;</a></span>sendDestructively()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">ChimeraTK::async::AsyncNDRegisterAccessor</a>&lt; UserType &gt;::sendDestructively </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="class_chimera_t_k_1_1_n_d_register_accessor.html">NDRegisterAccessor</a>&lt; UserType &gt;::Buffer &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You can only send destructively. </p>
<p>If you want to keep a copy you have to make one yourself. This is more efficient that having one extra buffer within each <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html" title="The AsyncNDRegisterAccessor implements a data transport queue with typed data as continuation of the ...">AsyncNDRegisterAccessor</a>. </p>

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8cc_source.html#l00065">65</a> of file <a class="el" href="_async_n_d_register_accessor_8cc_source.html">AsyncNDRegisterAccessor.cc</a>.</p>

</div>
</div>
<a id="a6268e66923f71937cba5404509c49b35" name="a6268e66923f71937cba5404509c49b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6268e66923f71937cba5404509c49b35">&#9670;&#160;</a></span>sendException()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">ChimeraTK::async::AsyncNDRegisterAccessor</a>&lt; UserType &gt;::sendException </td>
          <td>(</td>
          <td class="paramtype">std::exception_ptr &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes the exception to the queue. </p>
<p>Must only be called from within deactivateAsyncAndExecute() to make sure it does not conflict with a re-enabling, which might violate the order guarantee in the spec. </p>

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8h_source.html#l00041">41</a> of file <a class="el" href="_async_n_d_register_accessor_8h_source.html">AsyncNDRegisterAccessor.h</a>.</p>

</div>
</div>
<a id="a4bc85a0281e225e0da518463e82ff3df" name="a4bc85a0281e225e0da518463e82ff3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc85a0281e225e0da518463e82ff3df">&#9670;&#160;</a></span>setExceptionBackend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">ChimeraTK::async::AsyncNDRegisterAccessor</a>&lt; UserType &gt;::setExceptionBackend </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_chimera_t_k_1_1_device_backend.html">DeviceBackend</a> &gt;&#160;</td>
          <td class="paramname"><em>exceptionBackend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the backend to which the exception has to be reported. </p>
<p>Each backend has to do this when creating TransferElements. However, not all TransferElements will have it set, for instance ProcessArrays in the ControlSystemAdapter and Application core,# which don't have backends at all. This function is only to be called inside of <a class="el" href="class_chimera_t_k_1_1_device_backend.html#a85a134106068b02a89cbfa9a4559ccfc" title="Get a NDRegisterAccessor object from the register name.">DeviceBackend::getRegisterAccessor()</a>!</p>
<p>It is virtual because some accessor implementations like <a class="el" href="class_chimera_t_k_1_1_numeric_addressed_backend_register_accessor.html" title="Implementation of the NDRegisterAccessor for NumericAddressedBackends for scalar and 1D registers.">NumericAddressedBackendRegisterAccessor</a> have an inner layer (LowLevelTransferElement), and all layers need to know the exception backend. Hence the functions needs to be overridden in this case. </p>

<p>Reimplemented from <a class="el" href="class_chimera_t_k_1_1_transfer_element.html#a23782060d06fa418950b74f8b10d4ec8">ChimeraTK::TransferElement</a>.</p>

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8h_source.html#l00086">86</a> of file <a class="el" href="_async_n_d_register_accessor_8h_source.html">AsyncNDRegisterAccessor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a033c01e34dfb98f9dba7750807d880f4" name="a033c01e34dfb98f9dba7750807d880f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033c01e34dfb98f9dba7750807d880f4">&#9670;&#160;</a></span>_accessorManager</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_chimera_t_k_1_1async_1_1_async_accessor_manager.html">AsyncAccessorManager</a>&gt; <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">ChimeraTK::async::AsyncNDRegisterAccessor</a>&lt; UserType &gt;::_accessorManager</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8h_source.html#l00101">101</a> of file <a class="el" href="_async_n_d_register_accessor_8h_source.html">AsyncNDRegisterAccessor.h</a>.</p>

</div>
</div>
<a id="ab9dea49599566380d7a2f4a37098d744" name="ab9dea49599566380d7a2f4a37098d744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9dea49599566380d7a2f4a37098d744">&#9670;&#160;</a></span>_asyncDomain</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_chimera_t_k_1_1async_1_1_domain.html">Domain</a>&gt; <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">ChimeraTK::async::AsyncNDRegisterAccessor</a>&lt; UserType &gt;::_asyncDomain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8h_source.html#l00102">102</a> of file <a class="el" href="_async_n_d_register_accessor_8h_source.html">AsyncNDRegisterAccessor.h</a>.</p>

</div>
</div>
<a id="a25648a4a60832eee5ae680208b51d497" name="a25648a4a60832eee5ae680208b51d497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25648a4a60832eee5ae680208b51d497">&#9670;&#160;</a></span>_backend</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;<a class="el" href="class_chimera_t_k_1_1_device_backend.html">DeviceBackend</a>&gt; <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">ChimeraTK::async::AsyncNDRegisterAccessor</a>&lt; UserType &gt;::_backend</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8h_source.html#l00100">100</a> of file <a class="el" href="_async_n_d_register_accessor_8h_source.html">AsyncNDRegisterAccessor.h</a>.</p>

</div>
</div>
<a id="ad1ec81eeb45b092c2ba25cefddf5bb33" name="ad1ec81eeb45b092c2ba25cefddf5bb33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ec81eeb45b092c2ba25cefddf5bb33">&#9670;&#160;</a></span>_dataTransportQueue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cppext::future_queue&lt;<a class="el" href="struct_chimera_t_k_1_1_n_d_register_accessor_1_1_buffer.html">Buffer</a>, cppext::SWAP_DATA&gt; <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">ChimeraTK::async::AsyncNDRegisterAccessor</a>&lt; UserType &gt;::_dataTransportQueue {_queueSize}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8h_source.html#l00107">107</a> of file <a class="el" href="_async_n_d_register_accessor_8h_source.html">AsyncNDRegisterAccessor.h</a>.</p>

</div>
</div>
<a id="a9282370d4f42695e956abc633de3e8f7" name="a9282370d4f42695e956abc633de3e8f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9282370d4f42695e956abc633de3e8f7">&#9670;&#160;</a></span>_receiveBuffer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UserType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_chimera_t_k_1_1_n_d_register_accessor_1_1_buffer.html">Buffer</a> <a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">ChimeraTK::async::AsyncNDRegisterAccessor</a>&lt; UserType &gt;::_receiveBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_async_n_d_register_accessor_8h_source.html#l00105">105</a> of file <a class="el" href="_async_n_d_register_accessor_8h_source.html">AsyncNDRegisterAccessor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/scratch/dragon/sources/ChimeraTK-DeviceAccess/include/async/<a class="el" href="_async_n_d_register_accessor_8h_source.html">AsyncNDRegisterAccessor.h</a></li>
<li>/scratch/dragon/sources/ChimeraTK-DeviceAccess/src/async/<a class="el" href="_async_n_d_register_accessor_8cc_source.html">AsyncNDRegisterAccessor.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_chimera_t_k.html">ChimeraTK</a></li><li class="navelem"><a class="el" href="namespace_chimera_t_k_1_1async.html">async</a></li><li class="navelem"><a class="el" href="class_chimera_t_k_1_1async_1_1_async_n_d_register_accessor.html">AsyncNDRegisterAccessor</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
