<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>mtca4u &#8212; ChimeraTK-DeviceAccess-PythonBindings 04.00.01 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=e7e61a73" />
    <script src="../_static/documentation_options.js?v=96af6e75"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for mtca4u</h1><div class="highlight"><pre>
<span></span><span class="c1"># SPDX-FileCopyrightText: Deutsches Elektronen-Synchrotron DESY, MSK, ChimeraTK Project &lt;chimeratk-support@desy.de&gt;</span>
<span class="c1"># SPDX-License-Identifier: LGPL-3.0-or-later</span>

<span class="kn">import</span> <span class="nn">deviceaccess</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;02.03.00&quot;</span>

<span class="c1"># http://stackoverflow.com/questions/4219717/how-to-assert-output-with-nosetest-unittest-in-python</span>


<div class="viewcode-block" id="get_info">
<a class="viewcode-back" href="../mtca4u.html#mtca4u.get_info">[docs]</a>
<span class="k">def</span> <span class="nf">get_info</span><span class="p">(</span><span class="n">outputStream</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; prints details about the module and the deviceaccess library</span>
<span class="sd">    against which it was linked</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    outputStream: optional</span>
<span class="sd">      default: sys.stdout</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import mtca4u</span>
<span class="sd">    &gt;&gt;&gt; mtca4u.get_info()</span>
<span class="sd">    mtca4uPy v02.03.00, linked with mtca4u-deviceaccess v$ChimeraTK-DeviceAccess_VERSION}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">outputStream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
        <span class="s2">&quot;mtca4uPy v02.03.00, linked with mtca4u-deviceaccess v02.06&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="set_dmap_location">
<a class="viewcode-back" href="../mtca4u.html#mtca4u.set_dmap_location">[docs]</a>
<span class="k">def</span> <span class="nf">set_dmap_location</span><span class="p">(</span><span class="n">dmapFileLocation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Sets the location of the dmap file to use</span>

<span class="sd">    The library will check the user specified device Alias names (when creating</span>
<span class="sd">    devices) in this dmap file. Once set, the library will look at this dmap file</span>
<span class="sd">    through out the program lifetime. This is true until a new dmap file is</span>
<span class="sd">    set again using set_dmap_location</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dmapFileLocation: string</span>
<span class="sd">      Path to the desired dmap file.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">      &gt;&gt;&gt; import mtca4u</span>
<span class="sd">      &gt;&gt;&gt; mtca4u.set_dmap_location(&quot;../my_example_dmap_file.dmap&quot;)</span>
<span class="sd">      &gt;&gt;&gt; device = mtca4u.Device(&quot;my_card&quot;) # my_card is a alias in my_example_dmap_file.dmap</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    get_dmap_location: View the current dmap file which the library uses for device name (alias) lookup.</span>
<span class="sd">    Device : Open device using specified alias names or using device id and mapfile</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># os.environ[&quot;DMAP_FILE&quot;] = dmapFileLocation</span>
    <span class="n">deviceaccess</span><span class="o">.</span><span class="n">setDMapFilePath</span><span class="p">(</span><span class="n">dmapFileLocation</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_dmap_location">
<a class="viewcode-back" href="../mtca4u.html#mtca4u.get_dmap_location">[docs]</a>
<span class="k">def</span> <span class="nf">get_dmap_location</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Get the dmap file which is currently in use by the library.</span>

<span class="sd">    Method returns the file path of the dmap file the library currently uses.</span>
<span class="sd">    This is the dmap file the library uses to look up the device name(alias) and</span>
<span class="sd">    its details</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string: File path of the dmap file the library currently uses.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">      &gt;&gt;&gt; import mtca4u</span>
<span class="sd">      &gt;&gt;&gt; mtca4u.set_dmap_location(&quot;../my_example_dmap_file.dmap&quot;)</span>
<span class="sd">      &gt;&gt;&gt; dmapPath = mtca4u.get_dmap_location()</span>
<span class="sd">      &gt;&gt;&gt; print dmapPath # prints &#39;../my_example_dmap_file.dmap&#39;</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    set_dmap_location : set dmap file path for the library.</span>
<span class="sd">    Device : Open device using specified alias names or using device id and mapfile</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">deviceaccess</span><span class="o">.</span><span class="n">getDMapFilePath</span><span class="p">()</span></div>



<div class="viewcode-block" id="Device">
<a class="viewcode-back" href="../mtca4u.html#mtca4u.Device">[docs]</a>
<span class="k">class</span> <span class="nc">Device</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Construct Device from user provided device information</span>

<span class="sd">    This constructor is used to open a device listed in the dmap file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    alias : str</span>
<span class="sd">      The device alias/name in the dmap file for the hardware</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Creating a device using dmap file:</span>
<span class="sd">      &gt;&gt;&gt; import mtca4u</span>
<span class="sd">      &gt;&gt;&gt; mtca4u.set_dmap_location(&quot;../my_example_dmap_file.dmap&quot;)</span>
<span class="sd">      &gt;&gt;&gt; device = mtca4u.Device(&quot;my_card&quot;) # my_card is a alias in my_example_dmap_file.dmap</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cddOrAlias</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__openedDevice</span> <span class="o">=</span> <span class="n">deviceaccess</span><span class="o">.</span><span class="n">Device</span><span class="p">(</span><span class="n">cddOrAlias</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__openedDevice</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>

<div class="viewcode-block" id="Device.read">
<a class="viewcode-back" href="../mtca4u.html#mtca4u.Device.read">[docs]</a>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moduleName</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">registerName</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numberOfElementsToRead</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
             <span class="n">elementIndexInRegister</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">registerPath</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Reads out Fixed point converted values from the opened device</span>

<span class="sd">        This method uses the map file to return Fixed Point converted values from a</span>
<span class="sd">        register. It can read the whole register or an arbitary number of register</span>
<span class="sd">        elements. Data can also be read from an offset within the register (through</span>
<span class="sd">        the &#39;elementIndexInRegister&#39; parameter).</span>

<span class="sd">        .. note::     Both moduleName and registerName parameters are ignored when</span>
<span class="sd">                      registerPath is provided.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        moduleName : str, optional</span>
<span class="sd">          The name of the device module to which the register belongs to. If the</span>
<span class="sd">          register is not contained in a  module, then provide an empty string as</span>
<span class="sd">          the parameter value.</span>

<span class="sd">        registerName : str, optional</span>
<span class="sd">          The name of the register to read from.</span>

<span class="sd">        numberOfElementsToRead : int, optional</span>
<span class="sd">          Specifies the number of register elements that should</span>
<span class="sd">          be read out. The width and fixed point representation of the register</span>
<span class="sd">          element are internally obtained from the map file.</span>

<span class="sd">          The method returns all elements in the register if this parameter is</span>
<span class="sd">          ommitted or when its value is set as 0.</span>

<span class="sd">          If the value provided as this parameter exceeds the register size, an</span>
<span class="sd">          array with all elements upto the last element is returned</span>

<span class="sd">        elementIndexInRegister : int, optional</span>
<span class="sd">          This is a zero indexed offset from the first element of the register. When</span>
<span class="sd">          an elementIndexInRegister parameter is specified, the method reads out</span>
<span class="sd">          elements starting from this element index. The elemnt at the index</span>
<span class="sd">          position is included in the read as well.</span>

<span class="sd">        registerPath : str, optional</span>
<span class="sd">          When provided, it takes precedences over moduleName and registerName for</span>
<span class="sd">          location lookup.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        readoutValues: numpy.array, dtype == numpy.float64</span>
<span class="sd">          The return type for the method is a 1-Dimensional numpy array with</span>
<span class="sd">          datatype numpy.float64. The returned numpy.array would either contain all</span>
<span class="sd">          elements in the register or only the number specified by the</span>
<span class="sd">          numberOfElementsToRead parameter</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        register &quot;WORD_STATUS&quot; is 1 element long..</span>
<span class="sd">          &gt;&gt;&gt; import mtca4u</span>
<span class="sd">          &gt;&gt;&gt; mtca4u.set_dmap_location(&quot;../my_example_dmap_file.dmap&quot;)</span>
<span class="sd">          &gt;&gt;&gt; boardWithModules = mtca4u.Device(&quot;device_name&quot;)</span>
<span class="sd">          &gt;&gt;&gt; boardWithModules.read(&quot;BOARD&quot;, &quot;WORD_STATUS&quot;)</span>
<span class="sd">          array([15.0], dtype=float64)</span>
<span class="sd">          &gt;&gt;&gt; boardWithModules.read(registerPath=&quot;/BOARD/WORD_STATUS&quot;)</span>
<span class="sd">          array([15.0], dtype=float64)</span>


<span class="sd">        register &quot;WORD_CLK_MUX&quot; is 4 elements long.</span>
<span class="sd">          &gt;&gt;&gt; import mtca4u</span>
<span class="sd">          &gt;&gt;&gt; device = mtca4u.Device(&quot;device_name&quot;)</span>
<span class="sd">          &gt;&gt;&gt; device.read(&quot;&quot;, &quot;WORD_CLK_MUX&quot;)</span>
<span class="sd">          array([15.0, 14.0, 13.0, 12.0], dtype=float64)</span>
<span class="sd">          &gt;&gt;&gt; device.read(&quot;&quot;, &quot;WORD_CLK_MUX&quot;, 0)</span>
<span class="sd">          array([15.0, 14.0, 13.0, 12.0], dtype=float64)</span>
<span class="sd">        read out select number of elements from specified locations:</span>
<span class="sd">          &gt;&gt;&gt; device.read(&quot;&quot;, &quot;WORD_CLK_MUX&quot;, 1)</span>
<span class="sd">          array([15.0], dtype=float64)</span>
<span class="sd">          &gt;&gt;&gt; device.read(&quot;&quot;, &quot;WORD_CLK_MUX&quot;, 1, 2 )</span>
<span class="sd">          array([13.0], dtype=float64)</span>
<span class="sd">          &gt;&gt;&gt; device.read(&quot;&quot;, &quot;WORD_CLK_MUX&quot;, 0, 2 )</span>
<span class="sd">          array([13.0, 12.0], dtype=float64)</span>
<span class="sd">          &gt;&gt;&gt; device.read(&quot;&quot;, &quot;WORD_CLK_MUX&quot;, 5, 2 )</span>
<span class="sd">          array([13.0, 12.0], dtype=float64)</span>
<span class="sd">          &gt;&gt;&gt; device.read(&quot;&quot;, &quot;WORD_CLK_MUX&quot;, numberOfElementsToRead=1, elementIndexInRegister=2 )</span>
<span class="sd">          array([13.0], dtype=float64)</span>
<span class="sd">          &gt;&gt;&gt; device.read(&quot;&quot;, &quot;WORD_CLK_MUX&quot;, elementIndexInRegister=2 )</span>
<span class="sd">          array([13.0, 12.0], dtype=float64)</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Device.read_raw : Read in &#39;raw&#39; bit values from a device register</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">registerPath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">registerPath</span> <span class="o">=</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">moduleName</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">registerName</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__openedDevice</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">registerPath</span><span class="p">,</span> <span class="n">numberOfWords</span><span class="o">=</span><span class="n">numberOfElementsToRead</span><span class="p">,</span>
                                       <span class="n">wordOffsetInRegister</span><span class="o">=</span><span class="n">elementIndexInRegister</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">val</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">val</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span></div>


<div class="viewcode-block" id="Device.write">
<a class="viewcode-back" href="../mtca4u.html#mtca4u.Device.write">[docs]</a>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moduleName</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">registerName</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dataToWrite</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">elementIndexInRegister</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">registerPath</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Sets data into a desired register</span>

<span class="sd">        This method writes values into a register on the board. The method</span>
<span class="sd">        internally uses a fixed point converter that is aware of the register width</span>
<span class="sd">        on the device and its fractional representation. This Fixed point converter</span>
<span class="sd">        converts the input into corresponding Fixed Point representaions that fit</span>
<span class="sd">        into the decive register.</span>

<span class="sd">        .. note::     Both moduleName and registerName parameters are ignored when</span>
<span class="sd">                      registerPath is provided.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        moduleName : str, optional</span>
<span class="sd">          The name of the device module which has the register to write into.</span>
<span class="sd">          If module name is not applicable to the register, then provide an empty</span>
<span class="sd">          string as the parameter value.</span>

<span class="sd">        registerName : str, optional</span>
<span class="sd">          Mapped name of the register to write to</span>

<span class="sd">        dataToWrite : int, float, \</span>
<span class="sd">        list of int/float, numpy.array(dtype numpy.float32/64), \</span>
<span class="sd">        numpy.array(dtype = numpy.int32/64)</span>
<span class="sd">          The data to be written in to the register. it may be a numpy.float32/64 or a</span>
<span class="sd">          numpy.int32/64 array or a list with int or float values . Each value in this</span>
<span class="sd">          array represents an induvidual element of the register. dataToWrite may also</span>
<span class="sd">          take on int/float type when single vaues are passesed</span>

<span class="sd">        elementIndexInRegister : int, optional</span>
<span class="sd">          This is a zero indexed offset from the first element of the register. When</span>
<span class="sd">          an elementIndexInRegister parameter is specified, the method starts the</span>
<span class="sd">          write from this index</span>

<span class="sd">        registerPath : str, optional</span>
<span class="sd">          When provided, it takes precedences over moduleName and registerName for</span>
<span class="sd">          location lookup.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        register &quot;WORD_STATUS&quot; is 1 element long and belongs to module &quot;BOARD&quot;.</span>
<span class="sd">          &gt;&gt;&gt; import mtca4u</span>
<span class="sd">          &gt;&gt;&gt; mtca4u.set_dmap_location(&quot;../my_example_dmap_file.dmap&quot;)</span>
<span class="sd">          &gt;&gt;&gt; boardWithModules = mtca4u.Device(&quot;device_name&quot;)</span>
<span class="sd">          &gt;&gt;&gt; boardWithModules.write(&quot;BOARD&quot;, &quot;WORD_STATUS&quot;, 15)</span>
<span class="sd">          &gt;&gt;&gt; boardWithModules.write(&quot;BOARD&quot;, &quot;WORD_STATUS&quot;, 15.0)</span>
<span class="sd">          &gt;&gt;&gt; boardWithModules.write(&quot;BOARD&quot;, &quot;WORD_STATUS&quot;, [15])</span>
<span class="sd">          &gt;&gt;&gt; boardWithModules.write(&quot;BOARD&quot;, &quot;WORD_STATUS&quot;, [15.0])</span>

<span class="sd">          &gt;&gt;&gt; boardWithModules.write(registerPath = &quot;/BOARD/WORD_STATUS&quot;,</span>
<span class="sd">                                     dataToWrite = [15.0])</span>

<span class="sd">          &gt;&gt;&gt; dataToWrite = numpy.array([15.0])</span>
<span class="sd">          &gt;&gt;&gt; boardWithModules.write(&quot;BOARD&quot;, &quot;WORD_STATUS&quot;, dataToWrite)</span>

<span class="sd">        register &quot;WORD_CLK_MUX&quot; is 4 elements long.</span>
<span class="sd">          &gt;&gt;&gt; import mtca4u</span>
<span class="sd">          &gt;&gt;&gt; mtca4u.set_dmap_location(&quot;../my_example_dmap_file.dmap&quot;)</span>
<span class="sd">          &gt;&gt;&gt; device = mtca4u.Device(&quot;device_name&quot;)</span>
<span class="sd">          &gt;&gt;&gt; dataToWrite = numpy.array([15.0, 14.0, 13.0, 12.0])</span>
<span class="sd">          &gt;&gt;&gt; device.write(&quot;&quot;, &quot;WORD_CLK_MUX&quot;, dataToWrite)</span>
<span class="sd">          &gt;&gt;&gt; dataToWrite = numpy.array([13, 12])</span>
<span class="sd">          &gt;&gt;&gt; device.write(&quot;&quot;, &quot;WORD_CLK_MUX&quot;, dataToWrite, 2)</span>
<span class="sd">          &gt;&gt;&gt; device.write(&quot;&quot;, &quot;WORD_CLK_MUX&quot;, 2.78) # writes value to first element of register</span>
<span class="sd">          &gt;&gt;&gt; device.write(&quot;&quot;, &quot;WORD_CLK_MUX&quot;, 10, elementIndexInRegister=3)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Device.write_raw : Write &#39;raw&#39; bit values to a device register</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">registerPath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">registerPath</span> <span class="o">=</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">moduleName</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">registerName</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__openedDevice</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="n">registerPath</span><span class="p">,</span> <span class="n">dataToWrite</span><span class="o">=</span><span class="n">dataToWrite</span><span class="p">,</span> <span class="n">wordOffsetInRegister</span><span class="o">=</span><span class="n">elementIndexInRegister</span><span class="p">)</span></div>


<div class="viewcode-block" id="Device.read_raw">
<a class="viewcode-back" href="../mtca4u.html#mtca4u.Device.read_raw">[docs]</a>
    <span class="k">def</span> <span class="nf">read_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moduleName</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">registerName</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numberOfElementsToRead</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">elementIndexInRegister</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">registerPath</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns &#39;raw values&#39; (Without fixed point conversion applied) from a device&#39;s register</span>

<span class="sd">        This method returns the raw bit values contained in the queried register.</span>
<span class="sd">        The returned values are not Fixed Point converted, but direct binary values</span>
<span class="sd">        contained in the register elements.</span>

<span class="sd">        .. note::     Both moduleName and registerName parameters are ignored when</span>
<span class="sd">                      registerPath is provided.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        moduleName : str, optional</span>
<span class="sd">          The name of the device module to which the register to read from belongs.</span>
<span class="sd">          If module name is not applicable to the register, then provide an empty</span>
<span class="sd">          string as the parameter value.</span>

<span class="sd">        registerName : str, optional</span>
<span class="sd">          The name of the device register to read from.</span>

<span class="sd">        numberOfElementsToRead : int, optional</span>
<span class="sd">          Specifies the number of register elements that should be read out.</span>
<span class="sd">          The method returns all elements in the register if this parameter is</span>
<span class="sd">          ommitted or when its value is set as 0.</span>
<span class="sd">          If the value provided as this parameter exceeds the register size, an</span>
<span class="sd">          array will all elements upto the last element is returned</span>

<span class="sd">        elementIndexInRegister : int, optional</span>
<span class="sd">          This is a zero indexed offset from the first element of the register. When</span>
<span class="sd">          an elementIndexInRegister parameter is specified, the method reads out</span>
<span class="sd">          elements starting from this element index. The element at the index</span>
<span class="sd">          position is included in the read as well.</span>

<span class="sd">        registerPath : str, optional</span>
<span class="sd">          When provided, it takes precedences over moduleName and registerName for</span>
<span class="sd">          location lookup.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        readInRawValues: numpy.array, dtype == numpy.int32</span>
<span class="sd">          The method returns a numpy.int32 array containing the raw bit values of</span>
<span class="sd">          the register elements. The length of the array either equals the number of</span>
<span class="sd">          elements that make up the register or the number specified through the</span>
<span class="sd">          numberOfElementsToRead parameter</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        register &quot;WORD_STATUS&quot; is 1 element long.</span>
<span class="sd">          &gt;&gt;&gt; import mtca4u</span>
<span class="sd">          &gt;&gt;&gt; mtca4u.set_dmap_location(&quot;../my_example_dmap_file.dmap&quot;)</span>
<span class="sd">          &gt;&gt;&gt; boardWithModules = mtca4u.Device(&quot;device_name&quot;)</span>
<span class="sd">          &gt;&gt;&gt; boardWithModules.read_raw(&quot;BOARD&quot;, &quot;WORD_STATUS&quot;)</span>
<span class="sd">          array([15], dtype=int32)</span>
<span class="sd">          &gt;&gt;&gt; boardWithModules.read_raw(registerPath=&quot;/BOARD/WORD_STATUS&quot;)</span>
<span class="sd">          array([15], dtype=int32)</span>

<span class="sd">        register &quot;WORD_CLK_MUX&quot; is 4 elements long.</span>
<span class="sd">          &gt;&gt;&gt; import mtca4u</span>
<span class="sd">          &gt;&gt;&gt; mtca4u.set_dmap_location(&quot;../my_example_dmap_file.dmap&quot;)</span>
<span class="sd">          &gt;&gt;&gt; device = mtca4u.Device(&quot;device_name&quot;)</span>
<span class="sd">          &gt;&gt;&gt; device.read_raw(&quot;&quot;, &quot;WORD_CLK_MUX&quot;)</span>
<span class="sd">          array([15, 14, 13, 12], dtype=int32)</span>
<span class="sd">          &gt;&gt;&gt; device.read_raw(&quot;&quot;, &quot;WORD_CLK_MUX&quot;, 0)</span>
<span class="sd">          array([15, 14, 13, 12], dtype=int32)</span>
<span class="sd">          &gt;&gt;&gt; device.read_raw(&quot;&quot;, &quot;WORD_CLK_MUX&quot;, 1)</span>
<span class="sd">          array([15], dtype=int32)</span>
<span class="sd">          &gt;&gt;&gt; device.read_raw(&quot;&quot;, &quot;WORD_CLK_MUX&quot;, 1, 2 )</span>
<span class="sd">          array([13], dtype = int32)</span>
<span class="sd">          &gt;&gt;&gt; device.read_raw(&quot;&quot;, &quot;WORD_CLK_MUX&quot;, 0, 2 )</span>
<span class="sd">          array([13, 12], dtype=int32)</span>
<span class="sd">          &gt;&gt;&gt; device.read_raw(&quot;&quot;, &quot;WORD_CLK_MUX&quot;, numberOfElementsToRead=1, elementIndexInRegister=2 )</span>
<span class="sd">          array([13], dtype=int32)</span>
<span class="sd">          &gt;&gt;&gt; device.read_raw(&quot;&quot;, &quot;WORD_CLK_MUX&quot;, elementIndexInRegister=2 )</span>
<span class="sd">          array([13, 12], dtype=int32)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Device.read : Read in Fixed Point converted bit values from a device register</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">registerPath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">registerPath</span> <span class="o">=</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">moduleName</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">registerName</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__openedDevice</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">registerPath</span><span class="p">,</span> <span class="n">numberOfWords</span><span class="o">=</span><span class="n">numberOfElementsToRead</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
                                       <span class="n">wordOffsetInRegister</span><span class="o">=</span><span class="n">elementIndexInRegister</span><span class="p">,</span> <span class="n">accessModeFlags</span><span class="o">=</span><span class="p">[</span><span class="n">deviceaccess</span><span class="o">.</span><span class="n">AccessMode</span><span class="o">.</span><span class="n">raw</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">val</span><span class="p">])</span></div>


<div class="viewcode-block" id="Device.write_raw">
<a class="viewcode-back" href="../mtca4u.html#mtca4u.Device.write_raw">[docs]</a>
    <span class="k">def</span> <span class="nf">write_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moduleName</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">registerName</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dataToWrite</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">elementIndexInRegister</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">registerPath</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Write raw bit values (no fixed point conversion applied) into the register</span>

<span class="sd">        Provides a way to put in a desired bit value into individual register</span>
<span class="sd">        elements.</span>

<span class="sd">        .. note::     Both moduleName and registerName parameters are ignored when</span>
<span class="sd">                      registerPath is provided.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        moduleName : str, optional</span>
<span class="sd">          The name of the device module that has the register we intend to write to.</span>
<span class="sd">          If module name is not applicable to the register, then provide an empty</span>
<span class="sd">          string as the parameter value.</span>

<span class="sd">        registerName : str, optional</span>
<span class="sd">          The name of the desired register to write into.</span>

<span class="sd">        dataToWrite : numpy.array, dtype == numpy.int32</span>
<span class="sd">         The array holding the bit values to be written into the register. The numpy</span>
<span class="sd">         array is expected to contain numpy.int32 values</span>

<span class="sd">        elementIndexInRegister : int, optional</span>
<span class="sd">          This is a zero indexed offset from the first element of the register. When</span>
<span class="sd">          an elementIndexInRegister parameter is specified, the method starts the</span>
<span class="sd">          write from this index</span>

<span class="sd">        registerPath : str, optional</span>
<span class="sd">          When provided, it takes precedences over moduleName and registerName for</span>
<span class="sd">          location lookup.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        register &quot;WORD_STATUS&quot; is 1 element long and is part of the module &quot;BOARD&quot;.</span>
<span class="sd">          &gt;&gt;&gt; import mtca4u</span>
<span class="sd">          &gt;&gt;&gt; mtca4u.set_dmap_location(&quot;../my_example_dmap_file.dmap&quot;)</span>
<span class="sd">          &gt;&gt;&gt; boardWithModules = mtca4u.Device(&quot;device_name&quot;)</span>
<span class="sd">          &gt;&gt;&gt; _dataToWrite = numpy.array([15], dtype=int32)</span>
<span class="sd">          &gt;&gt;&gt; boardWithModules.write_raw(&quot;BOARD&quot;, &quot;WORD_STATUS&quot;, dataToWrite=_dataToWrite)</span>
<span class="sd">          &gt;&gt;&gt; boardWithModules.write_raw(registerPath = &quot;/BOARD/WORD_STATUS&quot;,</span>
<span class="sd">                                          dataToWrite=_dataToWrite)</span>

<span class="sd">        register &quot;WORD_CLK_MUX&quot; is 4 elements long.</span>
<span class="sd">          &gt;&gt;&gt; import mtca4u</span>
<span class="sd">          &gt;&gt;&gt; mtca4u.set_dmap_location(&quot;../my_example_dmap_file.dmap&quot;)</span>
<span class="sd">          &gt;&gt;&gt; device = mtca4u.Device(&quot;device_name&quot;)</span>
<span class="sd">          &gt;&gt;&gt; dataToWrite = numpy.array([15, 14, 13, 12], dtype=int32)</span>
<span class="sd">          &gt;&gt;&gt; device.write_raw(&quot;&quot;, &quot;WORD_CLK_MUX&quot;, dataToWrite)</span>
<span class="sd">          &gt;&gt;&gt; dataToWrite = numpy.array([13, 12], dtype=int32)</span>
<span class="sd">          &gt;&gt;&gt; device.write_raw(&quot;MODULE1&quot;, &quot;WORD_CLK_MUX&quot;, dataToWrite, 2)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Device.write : Write values that get fixed point converted to the device</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">registerPath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">registerPath</span> <span class="o">=</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">moduleName</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">registerName</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__openedDevice</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">registerPath</span><span class="p">,</span> <span class="n">dataToWrite</span><span class="o">=</span><span class="n">dataToWrite</span><span class="p">,</span>
                                  <span class="n">wordOffsetInRegister</span><span class="o">=</span><span class="n">elementIndexInRegister</span><span class="p">,</span> <span class="n">accessModeFlags</span><span class="o">=</span><span class="p">[</span><span class="n">deviceaccess</span><span class="o">.</span><span class="n">AccessMode</span><span class="o">.</span><span class="n">raw</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span></div>


<div class="viewcode-block" id="Device.read_dma_raw">
<a class="viewcode-back" href="../mtca4u.html#mtca4u.Device.read_dma_raw">[docs]</a>
    <span class="k">def</span> <span class="nf">read_dma_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moduleName</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">DMARegisterName</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">numberOfElementsToRead</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">elementIndexInRegister</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                     <span class="n">registerPath</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Read in Data from the DMA region of the card</span>

<span class="sd">        This method can be used to fetch data copied to a dma memory block. The</span>
<span class="sd">        method assumes that the device maps the DMA memory block to a register made</span>
<span class="sd">        up of 32 bit elements.</span>


<span class="sd">        .. note:: Deprecated since 1.0.0; use Device.read_raw instead.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        moduleName : str, optional</span>
<span class="sd">          The name of the device module that has the register we intend to write to.</span>
<span class="sd">          If module name is not applicable to the device, then provide an empty</span>
<span class="sd">          string as the parameter value.</span>

<span class="sd">        DMARegisterName : str, optional</span>
<span class="sd">          The register name to which the DMA memory region is mapped</span>

<span class="sd">        numberOfElementsToRead : int, optional</span>
<span class="sd">          This optional parameter specifies the number of 32 bit elements that have</span>
<span class="sd">          to be returned from the mapped dma register. When this parameter is not</span>
<span class="sd">          specified or is provided with a value of 0,  every  element in the DMA</span>
<span class="sd">          memory block is returned.</span>

<span class="sd">          If the value provided as this parameter exceeds the register size, an</span>
<span class="sd">          array with all elements upto the last element is returned</span>

<span class="sd">        elementIndexInRegister : int, optional</span>
<span class="sd">          This parameter specifies the index from which the read should commence.</span>

<span class="sd">        registerPath : str, optional</span>
<span class="sd">          When provided, it takes precedences over moduleName and registerName for</span>
<span class="sd">          location lookup.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        arrayOfRawValues: numpy.array, dtype == numpy.int32</span>
<span class="sd">          The method returns a numpy.int32 array containing the raw bit values</span>
<span class="sd">          contained in the DMA register elements. The length of the array either</span>
<span class="sd">          equals the number of 32 bit elements that make up the whole DMA region or</span>
<span class="sd">          the number specified through the numberOfElementsToRead parameter</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Use Device.read_raw: In the example, register &quot;AREA_DMA_VIA_DMA&quot; is the DMA mapped memory made up of 32 bit elements.</span>
<span class="sd">          &gt;&gt;&gt; import mtca4u</span>
<span class="sd">          &gt;&gt;&gt; mtca4u.set_dmap_location(&quot;../my_example_dmap_file.dmap&quot;)</span>
<span class="sd">          &gt;&gt;&gt; device = mtca4u.Device(&quot;device_name&quot;)</span>
<span class="sd">          &gt;&gt;&gt; device.read__raw(&quot;&quot;, &quot;AREA_DMA_VIA_DMA&quot;, 10)</span>
<span class="sd">          array([0, 1, 4, 9, 16, 25, 36, 49, 64, 81], dtype=int32)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Device.read_raw : Use this method for the same purpose instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_raw</span><span class="p">(</span><span class="n">moduleName</span><span class="p">,</span> <span class="n">DMARegisterName</span><span class="p">,</span>
                             <span class="n">numberOfElementsToRead</span><span class="p">,</span>
                             <span class="n">elementIndexInRegister</span><span class="p">,</span> <span class="n">registerPath</span><span class="p">)</span></div>


<div class="viewcode-block" id="Device.read_sequences">
<a class="viewcode-back" href="../mtca4u.html#mtca4u.Device.read_sequences">[docs]</a>
    <span class="k">def</span> <span class="nf">read_sequences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moduleName</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">regionName</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">registerPath</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Read in all sequences from a Multiplexed data Region</span>

<span class="sd">        This method returns the demultiplexed sequences in the memory area specified</span>
<span class="sd">        by regionName. The data is returned as a 2D numpy array with the coulums</span>
<span class="sd">        representing induvidual sequences</span>

<span class="sd">        .. note::     Both moduleName and regionName parameters are ignored when</span>
<span class="sd">                      registerPath is provided.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        moduleName : str, optional</span>
<span class="sd">          The name of the device module that has the register we intend to write to.</span>
<span class="sd">          If module name is not applicable to the device, then provide an empty</span>
<span class="sd">          string as the parameter value.</span>

<span class="sd">        regionName : str, optional</span>
<span class="sd">          The name of the memory area containing the multiplexed data.</span>

<span class="sd">        registerPath : str, optional</span>
<span class="sd">          When provided, it takes precedences over moduleName and regionName for</span>
<span class="sd">          location lookup.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        2DarrayOfValues: numpy.array, dtype == numpy.double</span>
<span class="sd">          The method returns a 2D numpy.double array containing extracted</span>
<span class="sd">          induvidual sequences as the columns</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &quot;DMA&quot; is the Multiplexed data region name. This region is defined by &#39;AREA_MULTIPLEXED_SEQUENCE_DMA&#39; in the mapfile.</span>
<span class="sd">          &gt;&gt;&gt; import mtca4u</span>
<span class="sd">          &gt;&gt;&gt; mtca4u.set_dmap_location(&quot;../my_example_dmap_file.dmap&quot;)</span>
<span class="sd">          &gt;&gt;&gt; device = mtca4u.Device(&quot;device_name&quot;)</span>
<span class="sd">          &gt;&gt;&gt; device.read_sequences(&quot;BOARD.0&quot;, &quot;DMA&quot;)</span>
<span class="sd">          array([[   0.,    1.,    4.,    9.,   16.],</span>
<span class="sd">                 [  25.,   36.,   49.,   64.,   81.],</span>
<span class="sd">                 [ 100.,  121.,  144.,  169.,  196.],</span>
<span class="sd">                 [ 225.,  256.,  289.,  324.,  361.]</span>
<span class="sd">                 [ 400.,  441.,  484.,  529.,  576.]], dtype=double)</span>
<span class="sd">          &gt;&gt;&gt; device.read_sequences(registerPath= &#39;/BOARD.0/DMA&#39;)</span>
<span class="sd">          array([[   0.,    1.,    4.,    9.,   16.],</span>
<span class="sd">                 [  25.,   36.,   49.,   64.,   81.],</span>
<span class="sd">                 [ 100.,  121.,  144.,  169.,  196.],</span>
<span class="sd">                 [ 225.,  256.,  289.,  324.,  361.]</span>
<span class="sd">                 [ 400.,  441.,  484.,  529.,  576.]], dtype=double)</span>

<span class="sd">        Each column of the 2D matrix represents an extracted sequence:</span>
<span class="sd">         &gt;&gt;&gt; data = device.read_sequences(&quot;BOARD.0&quot;, &quot;DMA&quot;)</span>
<span class="sd">         &gt;&gt;&gt; adc0_values = data[:,0] # array([0., 25., 100., 225., 400.])</span>
<span class="sd">         &gt;&gt;&gt; adc1_values = data[:,1] # array([1., 36., 49., 64., 81.])</span>
<span class="sd">         &gt;&gt;&gt; adc3_values = data[:,3] # array([9., 64., 169., 324., 529.])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">registerPath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">registerPath</span> <span class="o">=</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">moduleName</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">regionName</span>
        <span class="n">accessor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__openedDevice</span><span class="o">.</span><span class="n">getTwoDRegisterAccessor</span><span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">registerPath</span><span class="p">)</span>
        <span class="n">accessor</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">accessor</span><span class="o">.</span><span class="n">get</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span></div>


<div class="viewcode-block" id="Device.getCatalogueMetadata">
<a class="viewcode-back" href="../mtca4u.html#mtca4u.Device.getCatalogueMetadata">[docs]</a>
    <span class="k">def</span> <span class="nf">getCatalogueMetadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameterName</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Reads out metadata form the device catalogue</span>

<span class="sd">        The available metadata depends on the use backend. E.g. for</span>
<span class="sd">        NumericAddressedBackends, metadata will come from the map file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parameterName : str</span>
<span class="sd">          Name of the metadata parameter to read.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        metadataValue: str</span>
<span class="sd">          The value corresponding to the given parameterName.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__openedDevice</span><span class="o">.</span><span class="n">getCatalogueMetadata</span><span class="p">(</span><span class="n">parameterName</span><span class="p">)</span></div>
</div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/DESY_logo.png" alt="Logo"/>
            </a></p><h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../mtca4u.html">mtca4u module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deviceaccess.html">deviceaccess module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../matlab.html">Using the Python bindings with Matlab</a></li>
</ul>


<h1 class="logo"><a href="../index.html">ChimeraTK-DeviceAccess-PythonBindings</a></h1>








<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;Deutsches Elektronen-Synchrotron DESY, MSK, ChimeraTK Project <chimeratk-support@desy.de>.
      
    </div>

    

    
  </body>
</html>